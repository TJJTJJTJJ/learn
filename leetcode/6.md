# 2547.拆分数组的最小代价

标签：多个子区间、每个子区间求和

解法：枚举最后一个区间

https://leetcode.cn/problems/minimum-cost-to-split-an-array/

https://leetcode.cn/problems/minimum-cost-to-split-an-array/solution/by-endlesscheng-05s0/

```
class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        n = len(nums)
        f = [0 for _ in range(n+1)]
        for i in range(n):
            state = [0 for _ in range(n)]
            unique = 0
            res = sys.maxsize
            for j in range(i, -1, -1):
                if state[nums[j]]==0:
                    state[nums[j]]=1
                    unique+=1
                elif state[nums[j]]==1:
                    state[nums[j]]=2
                    unique-=1
                res = min(res, f[j]+i-j+1-unique+k)
            f[i+1] = res
        return f[n]

```

# [6361. 修改两个元素的最小分数](https://leetcode.cn/problems/minimum-score-by-changing-two-elements/)

https://leetcode.cn/problems/minimum-score-by-changing-two-elements/solution/nao-jin-ji-zhuan-wan-by-endlesscheng-9l4m/

```python
class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        res = min(nums[-3]-nums[0], nums[-2]-nums[1], nums[-1]-nums[2])
        return res
```

# [6360. 最小无法得到的或值](https://leetcode.cn/problems/minimum-impossible-or/)

https://leetcode.cn/problems/minimum-impossible-or/solution/nao-jin-ji-zhuan-wan-pythonjavacgo-by-en-7j89/

```python-repl
class Solution:
    def minImpossibleOR(self, nums: List[int]) -> int:
        mask = 0
        for x in nums:
            if x & (x-1)==0:
                mask |= x
        mask = ~mask 
        res = mask & (-mask)
        return res
```

保留最后一个bit：x&(-x)

删除最后一个bit/是2的幂次方 : x & (x-1)

# [2569. 更新数组后处理求和查询](https://leetcode.cn/problems/handling-sum-queries-after-update/)

https://leetcode.cn/problems/handling-sum-queries-after-update/

线段树，区间更新，区间查询

```python

class Node():
    def __init__(self, left=None, right=None, cnt_1=None):
        self.left = left
        self.right = right 
        self.cnt_1 = cnt_1
        self.lz = False

class SegmentTree():
    def __init__(self, arr):
        # arr, tree的下标从1开始，到n结束
        self.arr = arr 
        n = len(arr)-1
        self.tree = [Node() for _ in range(4*n)]
        self.build(1, 1, n)
  
    def push_up(self, i):
        self.tree[i].cnt_1 = self.tree[2*i].cnt_1 + self.tree[2*i+1].cnt_1
  
    def build(self, i, left, right):
        # 第i个节点对应的左右区间是left和right
        self.tree[i].left = left 
        self.tree[i].right = right 
        if left==right:
            self.tree[i].cnt_1 = self.arr[left]
            return 
        mid = (left+right)//2
        self.build(2*i, left, mid)
        self.build(2*i+1, mid+1, right)
        self.push_up(i)
  
    # 区间更新，区间查询，需要使用lazytag
    def push_down(self, i):
        # 没有下推标记或者已经是子节点，结束下推
        if self.tree[i].lz == False or self.tree[i].left == self.tree[i].right:
            return 
        self.tree[2*i].lz = not self.tree[2*i].lz
        self.tree[2*i].cnt_1 = self.tree[2*i].right - self.tree[2*i].left+1-self.tree[2*i].cnt_1
  
        self.tree[2*i+1].lz = not self.tree[2*i+1].lz
        self.tree[2*i+1].cnt_1 = self.tree[2*i+1].right - self.tree[2*i+1].left+1-self.tree[2*i+1].cnt_1

        self.tree[i].lz = not self.tree[i].lz
        return 
   


    def add(self, i, left, right):
        # 第i个节点修改, self.arr [left, right] 0 1反转
        if left <= self.tree[i].left and self.tree[i].right <= right:
            self.tree[i].cnt_1 = self.tree[i].right - self.tree[i].left+1-self.tree[i].cnt_1
            self.tree[i].lz = not self.tree[i].lz 
            return 
        self.push_down(i) # 先下推
        if left<=self.tree[2*i].right:
            self.add(2*i, left, right)
        if self.tree[2*i+1].left<=right:
            self.add(2*i+1, left, right)
        self.push_up(i)
  
    def search(self, i, left, right):
        if left<=self.tree[i].left and self.tree[i].right<=right:
            return self.tree[i].cnt_1 
        self.push_down(i) # 先下推
        ans = 0
        if left<=self.tree[2*i].right:
            ans += self.search(2*i, left, right)
        if self.tree[2*i+1].right<=right:
            ans += self.search(2*i+1, left, right)
        return ans 

class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        res = sum(nums2)
  
        nums1 = [0]+nums1
        segmenttree = SegmentTree(nums1)
        n = len(nums1)-1
        res_list = list()
        # print(queries)
        for i, (t, left, right) in enumerate(queries):
  
            if t==1:
                left, right = left+1, right+1
                segmenttree.add(1, left, right)
            elif t==2:
                # print('segmenttree.search(1, 1, n): ', segmenttree.search(1, 1, n), res, t, left, right)
                res += segmenttree.search(1, 1, n)*left
            else:
                res_list.append(res)
            # print("i, res: ", i, t, left, right, segmenttree.search(1, 1, n), res)
        return res_list
```

# [2571. 将整数减少到零需要的最少操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/)

https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solution/ji-yi-hua-sou-suo-by-endlesscheng-cm6l/

```python
class Solution:
    def minOperations(self, n: int) -> int:
        res = 1
        while n & (n-1): # 是否是2的幂次
            lb = n & (-n)
            if n & (lb<<1): # 有连续的1
                n += lb 
            else:
                n -= lb 
            res += 1
        return res

```

# [2577. 在网格图中访问一个格子的最少时间](https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/)

https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution/zui-duan-lu-by-tsreaper-otha/

https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution/er-fen-da-an-bfspythonjavacgo-by-endless-j10w/

最短路算法：dijkstra算法

限制条件：每个点的最短路有限制 的 dijkstra算法

每次进入下一个点时，如果满足条件，直接进入；如果不满足条件，需要等满足条件才能进去

```python
from queue import PriorityQueue
import math

class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        # dijkstra算法
        pq = PriorityQueue()
        m, n = len(grid), len(grid[0])
        dis = [[sys.maxsize for _ in range(n)] for _ in range(m)]
        if grid[0][1]>1 and grid[1][0]>1:
            return -1
        pq.put((0, 0, 0)) # d, i, j
        while not pq.empty():
            d, i, j = pq.get()
            if i==m-1 and j==n-1:
                return d 
            if d>dis[i][j]:
                continue
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0<=ni<m and 0<=nj<n:
                    if d+1>=grid[ni][nj]:
                        nd = d+1
                    else:
                        nd = d+1+2*math.ceil((grid[ni][nj]-d-1)/2)
                    if nd < dis[ni][nj]:
                        dis[ni][nj] = nd 
                        pq.put((nd, ni, nj))
        return dis[m-1][n-1]
```

# [2581. 统计可能的树根数目](https://leetcode.cn/problems/count-number-of-possible-root-nodes/)

https://leetcode.cn/problems/count-number-of-possible-root-nodes/solution/huan-gen-dppythonjavacgo-by-endlesscheng-ccwy/

换根DP

**换根 dp(全方位木 DP)** 换根 DP，又叫二次扫描，是树形 DP 的一种。

其相比于一般的树形 DP 具有以下特点：

* `以树上的不同点作为根，其解不同`。
* 故为求解答案，不能单求某点的信息，`需要求解每个节点的信息`。
* 故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。

**换根 dp 的技巧**

1. 指定某个节点为根节点。
2. 第一次搜索完成预处理（如子树大小等），同时得到该节点的解。 eg:`子树更新父结点`向下的最远距离,求出根 0 的答案
   * `后序 dfs 先处理出每个节点的信息`
3. 第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。 eg:`非子树(父结点+兄弟结点)更新子树`向上的最远距离
   * `前序 dfs 换根求解其他位置的答案`

```python
class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        n = len(edges)+1
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        guesses = set( (x, y) for x, y in guesses)
        cnt = 0
        def dfs(x, fa):
            nonlocal cnt 
            for y in graph[x]:
                if y!=fa:
                    if (x, y) in guesses:
                        cnt+=1
                    dfs(y, x)
  
        dfs(0, -1)
        # print("cnt: ", cnt)
        res = 0
        def reroot(x, fa, cnt):
            nonlocal res
            # cnt: 表示以x为根节点时的命中数量
            # print("reroot: ", x, cnt) 
            if cnt>=k:
                res+=1
            for y in graph[x]:
                if y!=fa:
                    cnt_ = cnt
                    if (x, y) in guesses:
                        cnt_-=1
                    if (y, x) in guesses:
                        cnt_+=1
                    reroot(y, x, cnt_)
        reroot(0, -1, cnt)
        return res
```

换根DP：

https://zhuanlan.zhihu.com/p/348349531

# [834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/)

换根DP：

https://leetcode.cn/problems/sum-of-distances-in-tree/solution/by-kingbuffalo-9sz1/

```python
class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        size_ = [1 for _ in range(n)]
        res = [0 for _ in range(n) ]
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        dp = [0 for _ in range(n)]
        def dfs(x, fa): 
            for y in graph[x]:
                if y!=fa:
                    dfs(y, x)
                    dp[x] += dp[y]+size_[y]
                    size_[x] += size_[y]
            # print(x, dp, size_)
        dfs(0, -1)
        # print("dp:", dp)
        # print("size_: ", size_)
  
        def reroot(x, fa, cnt):
            # cnt 表示以x为根时的距离
            res[x] = cnt 
            for y in graph[x]:
                if y!=fa:
                    cnt_= cnt - 2*size_[y] + size_[0]
                    reroot(y, x, cnt_)
        reroot(0, -1, dp[0])
        return res

  

```

# [2589. 完成所有任务的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/)

https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution/tan-xin-pythonjavacgo-by-endlesscheng-w3k3/

贪心+暴力

提示 1
按照右端点排序。

提示 2
对于tasks[i] 来说，它右侧的任务要么和它没有交集，要么包含它的区间后缀。

提示 3
遍历排序后的任务，先统计区间内的已有的电脑运行时间点，如果个数小于duration，则需要新增时间点。根据提示 2，尽量把新增的时间点安排在区间[start,end] 的后缀上，这样下一个区间就能统计到更多已有的时间点。

```python
class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        run = [False for _ in range(tasks[-1][1]+1)]
        for start, end, d in tasks:
            d = d - sum(run[start:end+1])
            if d>0:
                for i in range(end, start-1, -1):
                    if run[i]:
                        continue
                    run[i] = True 
                    d-=1
                    if d<=0:
                        break 
        return sum(run)
```

# 背包九讲

## 1. 01背包

题目：N件物品，重量是C，价值是W，背包的容量是m，求解背包总价值最大

定义dp[i][j] 表示前i件商品选了部分商品恰好放入一个容量是j的背包的最大价值

对于dp[i][j]，有两种情况：1. 不装第i件商品，2. 装第i件商品

状态转移公式： dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v )

```python
dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
初始化：全0
for i in range(1, n+1):
    for j in range(w, m+1):
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)


等价于==>
def ZeroOnePack(dp, w, v, m):
    for j in range(m, w-1, -1): # 这里是倒着遍历，因为需要利用的是dp[i-1][j] dp[i-1][j-w]，对于i，需要先计算j，后计算j-w
        dp[j] = max(dp[j], dp[j-w]+v)

F = [0 for _ in range(m+1)] # 这里是为了和下面多重背包对齐
for i in range(1, n+1):
    ZeroOnePack(dp, w, v, m)
```

初始化：

1. 如果要求“恰好装满背包”：dp[0][0] = 0, 其他是-sys.maxsize，表示没有合法解
2. 没有要求恰好装满背包：dp全0

## 2. 完全背包

题目：n种物品，数量无限，重量是w，价值是v，背包总容量是m

定义dp[i][j] 表示前i件商品放入若干个若干种商品恰好放入一个容量是j的背包的最大价值

dp[i][j] ，对于第i种商品有多种可能：放入0个，放入1个，放入2个..放入m/w个

状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v, dp[i-1][j-2*w]+2 * v...)

优化1：

如果两件物品i, j, 有重量 wi < wj, 并且价值 vi>vj，则把物品j直接去掉，对结果没有影响。或者随着重量增加，价值也必须增加。O(m+n)的算法复杂度

```python
left_list = [0 for _ in range(m+1)] # 大于背包容量m的物品直接不用考虑  
# 同等重量的保留最大价值的物品
for i in range(n):
    left_list[w] = max(left_list[w], v)
# 随着重量增加，价值也必须增加
pre_v = 0
left_item = list()
for i in range(m+1):
    if left_list[i] > pre_v:
        left_item.append((i, left_list[i]))
        pre_v = left_list[i]

```

优化2：

转换成2进制：把第i种商品拆分成 w * 2**k, v * 2 ** k的若干种物品，这是因为不管选几个，都可以写成2进制的表达方式

优化3：

dp[i][j]：不从放入的角度，而是从dp[i][j]拿掉最后一个放入的商品i考虑，有两种情况：1. 没有第i种商品，无法拿掉最后一个商品i，dp[i-1][j]  2. 有多个第i种商品，去掉最后1个后是dp[i][j-w]

等价于 dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v)

```python
dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
初始化：全0
for i in range(1, n+1):
    for j in range(w, m+1):
        dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v) # 这里和01背包不同


等价于==>
def CompletePack(dp, w, v, m):
    for j in range(w, m+1): # 这里和01背包不同，正着遍历，因为用到的是dp[i-1][j] dp[i][j-w]，对于i，需要先计算j-w，然后计算j
        dp[j] = max(dp[j], dp[j-w]+v)

dp = [0 for _ in range(m+1)]
for i in range(1, n+1):
    CompletePack(dp, w, v, m)
```

## 3. 多重背包

题目：n种物品，数量k，重量是w，价值是v，背包总容量是m

定义dp[i][j] 表示前i件商品放入若干个若干种商品恰好放入一个容量是j的背包的最大价值

dp[i][j] ，对于第i种商品有多种可能：放入0个，放入1个，放入2个..放入k个

状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v, dp[i-1][j-2*w]+2 * v...)

优化1：

转换成2进制：把第i种商品拆分成 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1), k-2 ** a+1的若干种物品，其中a表示 2 ** a<=k的最大整数，这是因为不管选几个，都可以写成2进制的表达方式，且数量不会超过k。比如对于k=13，可以分成 1, 2, 4, 6 种商品。或者可以简化成将k不停地减去2 ** a，直到减不动，即 13-1=12, 12-2=10, 10-4=6, 6-8=-2<0.

时间复杂度O(nmlogk)

可以从 0...2 ** a -1 和 2 ** a...k 分段讨论

0....2 ** a-1 一定可以由 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1) 组成

k 可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1))

k-1可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1)) - 1

2 ** a 可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1)) - (2 ** a-1)

减去的数字也一定可以由 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1) 组成

```python
# 简单版：
def MultiplePack(dp, k, w, v, m):
    for j in range(w, m+1):
        for a in range(k+1):
            if j-aw>=0:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-aw]+av)

dp = [ [0 for _ in range(m+1)] for _ in range(n+1)]
for i in range(1, n+1):
    MultiplePack(dp, k, w, v, m)

# 优化版：
def ZeroOnePack(dp, w, v, m):
    for j in range(m, w-1, -1): # 这里是倒着遍历，因为需要利用的是dp[i-1][j] dp[i-1][j-w]，对于i，需要先计算j，后计算j-w
        dp[j] = max(dp[j], dp[j-w]+v)

def CompletePack(dp, w, v, m):
    for j in range(w, m+1): # 这里和01背包不同，正着遍历，因为用到的是dp[i-1][j] dp[i][j-w]，对于i，需要先计算j-w，然后计算j
        dp[j] = max(dp[j], dp[j-w]+v)

def MultiplePack(dp, k, w, v, m):
    if k * w >= m:
        CompletePack(dp, w, v, m )
        return 
    a = 1
    while a<k:
        ZeroOnePack(dp, a*w, a*v)
        k = k-a # 还剩下多少
        a = 2*a
    ZeroOnePack(dp, k*w, k*v)

dp = [0 for _ in range(m+1)] # 必须是一行的形式
for i in range(1, n+1):
    MultiplePack(dp, k, w, v, m)
  

```

### 3.1 可行性 O(nm)

问题：每种物品n有若干个k，能否填满给定容量m的背包

dp[i][j] : 表示当前 1..i 种物品填满容量是j的背包后，最多还剩下几个第i种物品可用。

dp[i][j] = - 1: 表示这种状态不可行

```python
dp = [[-1 for _ in range(m+1)] for _ in range(n+1)]
dp[0][0] = 0
for i in range(1, n+1):
    # 初始化，如果前i-1种物品可以填满容量j，那么前i种物品填满容量j时，最多还剩下k个可以用
    for j in range(1, m+1):
        if dp[i-1][j]>0:
            dp[i][j] = k # 
        else:
            dp[i][j] = -1 
    # 状态转移，如果dp[i][j]可行，那么dp[i][j+C]也可以满足，且数量减1
    for j in range(1, m+1):
        if dp[i][j]>0:
            dp[i][j+C] = max(dp[i][j+C], dp[i][j]-1)
```

## 5. 二维费用的背包问题

问题：对于每种物品，有两种不同的费用C, D，以及价值W。对于每种费用，都有可以付出的最大值V, U。问怎么才能得到最大价值。

 dp[i, v, u] 表示前i种物品时付出费用v和u的最大价值。

01背包状态转移过程:

dp[i, v, u] = max(dp[i-1, v, u], dp[i-1, v-C, u-D]+w)

### 5.1 物品总个数的限制

如果限制了物品总个数U，则可以认为每种商品都有一个件数费用，为1，可以付出的最大件数费用是U。

## 6. 分组背包

问题：N种物品，背包容量是V。物品费用是C，价值是W。这些物品被分为K组，每组内物品互相冲突，最多选1件。求解容量不超过V的情况下的最大价值。

算法：每组物品有两种策略：或者一件不选，或者只选一件

F[k, v]:表示前k组物品花费费用是v时的最大价值

状态转移公式：F[k, v] = max(F[k-1, v], F[k-1, v-C]+W | C, W 属于组k)

```python
dp = [0 for _ in range(V)]
for k in range(1, K):
    for v in range(V, 0):
        for item i in range(group k):
            dp[v] = max(dp[v], dp[v-C]+W)
```

## 7. 有依赖的背包问题

### 7. 1 简化版问题：

物品之间有依赖性，物品i依赖于物品j，表示如果要选物品i，必须先选物品j。为了简化，假设没有物品既依赖于其他物品，又被其他物品依赖；另外，没有某件物品同时依赖多种物品。

### 7.2 算法：

称不依赖其他物品的为“主件”，依赖于主件的物品成为“附件”。

仅考虑一个主件和它的附件集合。可用策略有2 ^ n+1种：一个不选，只选主件，主件+任意一个附件，主件+任意两个附件。

时间复杂度 O(2 ^ n+1)

优化：

对于第k个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响最后结果。

所以，对于主件k的附件集合先进行一次01背包，得到费用是 0...V-C时对应的最大价值Fk[0... V-C]。那么，这个主件以及它的附件集合相同于 V-Ck+1物品的物品组，其中费用v的物品的价值为Fk[v-C]+W. 时间复杂度O(VN)

然后按照分组背包问题解决。O(VNk)

整体时间复杂度O(VN+VNK)，远小于指数级。

## 9. 背包问题的问法变化

### 9.1 输出方案

记录下每个状态的最优值是状态转移方程的哪一项转移过来的。

### 9.2 输出字典序最小的方案

字典序最小，优先输出数字最小的物品。

将物品编号做 N+1-x 的变换。

状态F[i, v] = F[i-1, v], F[i-1, v-C]+W时，优选选择后者方案，优先选择物品i，字典序最大。

然后输出方案时重新变换回来。

### 9.3 方案总数

装满背包容量的方案总数

01背包：F[i, v] = sum(F[i-1, v] , F[i-1, v-C])

初始化 F[0, 0] = 1

### 9.4 最优方案总数

最大价值时的方案总数

01 背包：F[i, v] 表示最大价值，G[i, v]表示最大价值对应的方案总数

```python
F[i, v] = 0
G[i, v] = 0
G[0, 0] = 1
for i in range(1, N):
    for j in range(0, V):
        F[i, v] = max(F[i-1, v], F[i-1, v-C]+W)
        G[i, v] = 0
        if F[i, v] == F[i-1, v]:
            G[i, v] += G[i-1, v]
        if F[i, v] == F[i-1, v-C]+W:
            G[i, v] += G[i-1, v-C]
```

### 9.5 求次优解、第K优解

基本思想：将每个状态表示成有序队列，将状态转移转化成有序队列的合并。

F[i, v, 1...K] = max(F[i-1, v, 1...K], F[i-1, v-C, 1...K]+w)

有序队列的合并：每次取两个队列的队首最大值。

# [2597. 美丽子集的数目](https://leetcode.cn/problems/the-number-of-beautiful-subsets/)

**难度**中等22收藏分享切换为英文接收动态反馈

https://leetcode.cn/problems/the-number-of-beautiful-subsets/

https://leetcode.cn/problems/the-number-of-beautiful-subsets/solution/tao-lu-zi-ji-xing-hui-su-pythonjavacgo-b-fcgs/

打家劫舍：

```python
class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        group = defaultdict(Counter)
        for val in nums:
            group[val%k][val] += 1
    
        res = 1
        for key, value in group.items():
            g = sorted(list(value.keys()))
            m = len(g)
            f = [0 for _ in range(m+1)]
            f[0] = 1
            f[1] = 2**value[g[0]]
            for i in range(2, m+1):
                if g[i-1]-g[i-2] == k:
                    f[i] = f[i-1] + f[i-2] * (2**value[g[i-1]]-1)
                else:
                    f[i] = f[i-1] * (2**value[g[i-1]])
            res *= f[-1]
            # print(key, value, f, res)
        res = res-1 # 去除空集
        return res


```

# [2612. 最少翻转操作数](https://leetcode.cn/problems/minimum-reverse-operations/)

https://leetcode.cn/problems/minimum-reverse-operations/

https://leetcode.cn/problems/minimum-reverse-operations/solution/liang-chong-zuo-fa-ping-heng-shu-bing-ch-vr0z/ 中表明：位置 i 的一次翻转后的范围是 [max(i-k+1, k-i-1), min(i+k-1, 2n-k-i-1)]中的公差为2的等差数列。

https://leetcode.cn/problems/minimum-reverse-operations/solution/python-zai-xian-bfs-jie-jue-bian-shu-hen-y58m/ 中表明：所有的位置之间的一次翻转构成一个无向权重为1的图。翻转次数等于最短路径。bfs就可以完成。

与一般的无向无权重的图不同的是，需要在线bfs，没有提前构建好的图。


**难度**困难19收藏分享切换为英文接收动态反馈

# 下一行
