# 2547.拆分数组的最小代价

标签：多个子区间、每个子区间求和

解法：枚举最后一个区间

https://leetcode.cn/problems/minimum-cost-to-split-an-array/

https://leetcode.cn/problems/minimum-cost-to-split-an-array/solution/by-endlesscheng-05s0/

```
class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        n = len(nums)
        f = [0 for _ in range(n+1)]
        for i in range(n):
            state = [0 for _ in range(n)]
            unique = 0
            res = sys.maxsize
            for j in range(i, -1, -1):
                if state[nums[j]]==0:
                    state[nums[j]]=1
                    unique+=1
                elif state[nums[j]]==1:
                    state[nums[j]]=2
                    unique-=1
                res = min(res, f[j]+i-j+1-unique+k)
            f[i+1] = res
        return f[n]

```

# [6361. 修改两个元素的最小分数](https://leetcode.cn/problems/minimum-score-by-changing-two-elements/)

https://leetcode.cn/problems/minimum-score-by-changing-two-elements/solution/nao-jin-ji-zhuan-wan-by-endlesscheng-9l4m/

```python
class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        res = min(nums[-3]-nums[0], nums[-2]-nums[1], nums[-1]-nums[2])
        return res
```

# [6360. 最小无法得到的或值](https://leetcode.cn/problems/minimum-impossible-or/)

https://leetcode.cn/problems/minimum-impossible-or/solution/nao-jin-ji-zhuan-wan-pythonjavacgo-by-en-7j89/

```python-repl
class Solution:
    def minImpossibleOR(self, nums: List[int]) -> int:
        mask = 0
        for x in nums:
            if x & (x-1)==0:
                mask |= x
        mask = ~mask 
        res = mask & (-mask)
        return res
```

保留最后一个bit：x&(-x)

删除最后一个bit/是2的幂次方 : x & (x-1)

# [2569. 更新数组后处理求和查询](https://leetcode.cn/problems/handling-sum-queries-after-update/)

https://leetcode.cn/problems/handling-sum-queries-after-update/

线段树，区间更新，区间查询

```python

class Node():
    def __init__(self, left=None, right=None, cnt_1=None):
        self.left = left
        self.right = right 
        self.cnt_1 = cnt_1
        self.lz = False

class SegmentTree():
    def __init__(self, arr):
        # arr, tree的下标从1开始，到n结束
        self.arr = arr 
        n = len(arr)-1
        self.tree = [Node() for _ in range(4*n)]
        self.build(1, 1, n)
  
    def push_up(self, i):
        self.tree[i].cnt_1 = self.tree[2*i].cnt_1 + self.tree[2*i+1].cnt_1
  
    def build(self, i, left, right):
        # 第i个节点对应的左右区间是left和right
        self.tree[i].left = left 
        self.tree[i].right = right 
        if left==right:
            self.tree[i].cnt_1 = self.arr[left]
            return 
        mid = (left+right)//2
        self.build(2*i, left, mid)
        self.build(2*i+1, mid+1, right)
        self.push_up(i)
  
    # 区间更新，区间查询，需要使用lazytag
    def push_down(self, i):
        # 没有下推标记或者已经是子节点，结束下推
        if self.tree[i].lz == False or self.tree[i].left == self.tree[i].right:
            return 
        self.tree[2*i].lz = not self.tree[2*i].lz
        self.tree[2*i].cnt_1 = self.tree[2*i].right - self.tree[2*i].left+1-self.tree[2*i].cnt_1
  
        self.tree[2*i+1].lz = not self.tree[2*i+1].lz
        self.tree[2*i+1].cnt_1 = self.tree[2*i+1].right - self.tree[2*i+1].left+1-self.tree[2*i+1].cnt_1

        self.tree[i].lz = not self.tree[i].lz
        return 
   


    def add(self, i, left, right):
        # 第i个节点修改, self.arr [left, right] 0 1反转
        if left <= self.tree[i].left and self.tree[i].right <= right:
            self.tree[i].cnt_1 = self.tree[i].right - self.tree[i].left+1-self.tree[i].cnt_1
            self.tree[i].lz = not self.tree[i].lz 
            return 
        self.push_down(i) # 先下推
        if left<=self.tree[2*i].right:
            self.add(2*i, left, right)
        if self.tree[2*i+1].left<=right:
            self.add(2*i+1, left, right)
        self.push_up(i)
  
    def search(self, i, left, right):
        if left<=self.tree[i].left and self.tree[i].right<=right:
            return self.tree[i].cnt_1 
        self.push_down(i) # 先下推
        ans = 0
        if left<=self.tree[2*i].right:
            ans += self.search(2*i, left, right)
        if self.tree[2*i+1].right<=right:
            ans += self.search(2*i+1, left, right)
        return ans 

class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        res = sum(nums2)
  
        nums1 = [0]+nums1
        segmenttree = SegmentTree(nums1)
        n = len(nums1)-1
        res_list = list()
        # print(queries)
        for i, (t, left, right) in enumerate(queries):
    
            if t==1:
                left, right = left+1, right+1
                segmenttree.add(1, left, right)
            elif t==2:
                # print('segmenttree.search(1, 1, n): ', segmenttree.search(1, 1, n), res, t, left, right)
                res += segmenttree.search(1, 1, n)*left
            else:
                res_list.append(res)
            # print("i, res: ", i, t, left, right, segmenttree.search(1, 1, n), res)
        return res_list
```

# [2571. 将整数减少到零需要的最少操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/)

https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solution/ji-yi-hua-sou-suo-by-endlesscheng-cm6l/

```python
class Solution:
    def minOperations(self, n: int) -> int:
        res = 1
        while n & (n-1): # 是否是2的幂次
            lb = n & (-n)
            if n & (lb<<1): # 有连续的1
                n += lb 
            else:
                n -= lb 
            res += 1
        return res

```

# [2577. 在网格图中访问一个格子的最少时间](https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/)

https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution/zui-duan-lu-by-tsreaper-otha/

https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution/er-fen-da-an-bfspythonjavacgo-by-endless-j10w/

最短路算法：dijkstra算法

限制条件：每个点的最短路有限制 的 dijkstra算法

每次进入下一个点时，如果满足条件，直接进入；如果不满足条件，需要等满足条件才能进去

```python
from queue import PriorityQueue
import math

class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        # dijkstra算法
        pq = PriorityQueue()
        m, n = len(grid), len(grid[0])
        dis = [[sys.maxsize for _ in range(n)] for _ in range(m)]
        if grid[0][1]>1 and grid[1][0]>1:
            return -1
        pq.put((0, 0, 0)) # d, i, j
        while not pq.empty():
            d, i, j = pq.get()
            if i==m-1 and j==n-1:
                return d 
            if d>dis[i][j]:
                continue
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0<=ni<m and 0<=nj<n:
                    if d+1>=grid[ni][nj]:
                        nd = d+1
                    else:
                        nd = d+1+2*math.ceil((grid[ni][nj]-d-1)/2)
                    if nd < dis[ni][nj]:
                        dis[ni][nj] = nd 
                        pq.put((nd, ni, nj))
        return dis[m-1][n-1]
```

# [2581. 统计可能的树根数目](https://leetcode.cn/problems/count-number-of-possible-root-nodes/)

https://leetcode.cn/problems/count-number-of-possible-root-nodes/solution/huan-gen-dppythonjavacgo-by-endlesscheng-ccwy/

换根DP

**换根 dp(全方位木 DP)** 换根 DP，又叫二次扫描，是树形 DP 的一种。

其相比于一般的树形 DP 具有以下特点：

* `以树上的不同点作为根，其解不同`。
* 故为求解答案，不能单求某点的信息，`需要求解每个节点的信息`。
* 故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。

**换根 dp 的技巧**

1. 指定某个节点为根节点。
2. 第一次搜索完成预处理（如子树大小等），同时得到该节点的解。 eg:`子树更新父结点`向下的最远距离,求出根 0 的答案
   * `后序 dfs 先处理出每个节点的信息`
3. 第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。 eg:`非子树(父结点+兄弟结点)更新子树`向上的最远距离
   * `前序 dfs 换根求解其他位置的答案`

```python
class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        n = len(edges)+1
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        guesses = set( (x, y) for x, y in guesses)
        cnt = 0
        def dfs(x, fa):
            nonlocal cnt 
            for y in graph[x]:
                if y!=fa:
                    if (x, y) in guesses:
                        cnt+=1
                    dfs(y, x)
  
        dfs(0, -1)
        # print("cnt: ", cnt)
        res = 0
        def reroot(x, fa, cnt):
            nonlocal res
            # cnt: 表示以x为根节点时的命中数量
            # print("reroot: ", x, cnt) 
            if cnt>=k:
                res+=1
            for y in graph[x]:
                if y!=fa:
                    cnt_ = cnt
                    if (x, y) in guesses:
                        cnt_-=1
                    if (y, x) in guesses:
                        cnt_+=1
                    reroot(y, x, cnt_)
        reroot(0, -1, cnt)
        return res
```

换根DP：

https://zhuanlan.zhihu.com/p/348349531

# [834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/)

换根DP：

https://leetcode.cn/problems/sum-of-distances-in-tree/solution/by-kingbuffalo-9sz1/

```python
class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        size_ = [1 for _ in range(n)]
        res = [0 for _ in range(n) ]
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        dp = [0 for _ in range(n)]
        def dfs(x, fa): 
            for y in graph[x]:
                if y!=fa:
                    dfs(y, x)
                    dp[x] += dp[y]+size_[y]
                    size_[x] += size_[y]
            # print(x, dp, size_)
        dfs(0, -1)
        # print("dp:", dp)
        # print("size_: ", size_)
    
        def reroot(x, fa, cnt):
            # cnt 表示以x为根时的距离
            res[x] = cnt 
            for y in graph[x]:
                if y!=fa:
                    cnt_= cnt - 2*size_[y] + size_[0]
                    reroot(y, x, cnt_)
        reroot(0, -1, dp[0])
        return res

        

```


# [2589. 完成所有任务的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/)

https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution/tan-xin-pythonjavacgo-by-endlesscheng-w3k3/

贪心+暴力


提示 1
按照右端点排序。

提示 2
对于tasks[i] 来说，它右侧的任务要么和它没有交集，要么包含它的区间后缀。

提示 3
遍历排序后的任务，先统计区间内的已有的电脑运行时间点，如果个数小于duration，则需要新增时间点。根据提示 2，尽量把新增的时间点安排在区间[start,end] 的后缀上，这样下一个区间就能统计到更多已有的时间点。


```python
class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x:x[1])
        run = [False for _ in range(tasks[-1][1]+1)]
        for start, end, d in tasks:
            d = d - sum(run[start:end+1])
            if d>0:
                for i in range(end, start-1, -1):
                    if run[i]:
                        continue
                    run[i] = True 
                    d-=1
                    if d<=0:
                        break 
        return sum(run)
```


# 背包九讲

## 1. 01背包

题目：N件物品，重量是C，价值是W，背包的容量是m，求解背包总价值最大

定义dp[i][j] 表示前i件商品选了部分商品恰好放入一个容量是j的背包的最大价值

对于dp[i][j]，有两种情况：1. 不装第i件商品，2. 装第i件商品

状态转移公式： dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v )

```python
dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
初始化：全0
for i in range(1, n+1):
    for j in range(w, m+1):
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)


等价于==>
def ZeroOnePack(dp, w, v, m):
    for j in range(m, w-1, -1): # 这里是倒着遍历，因为需要利用的是dp[i-1][j] dp[i-1][j-w]，对于i，需要先计算j，后计算j-w
        dp[j] = max(dp[j], dp[j-w]+v)

F = [0 for _ in range(m+1)] # 这里是为了和下面多重背包对齐
for i in range(1, n+1):
    ZeroOnePack(dp, w, v, m)
```

初始化：

1. 如果要求“恰好装满背包”：dp[0][0] = 0, 其他是-sys.maxsize，表示没有合法解
2. 没有要求恰好装满背包：dp全0

## 2. 完全背包

题目：n种物品，数量无限，重量是w，价值是v，背包总容量是m

定义dp[i][j] 表示前i件商品放入若干个若干种商品恰好放入一个容量是j的背包的最大价值

dp[i][j] ，对于第i种商品有多种可能：放入0个，放入1个，放入2个..放入m/w个

状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v, dp[i-1][j-2*w]+2 * v...)

优化1：

转换成2进制：把第i种商品拆分成 w * 2**k, v * 2 ** k的若干种物品，这是因为不管选几个，都可以写成2进制的表达方式

优化2：

dp[i][j]：不从放入的角度，而是从dp[i][j]拿掉最后一个放入的商品i考虑，有两种情况：1. 没有第i种商品，无法拿掉最后一个商品i，dp[i-1][j]  2. 有多个第i种商品，去掉最后1个后是dp[i][j-w]

等价于 dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v)

```python
dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
初始化：全0
for i in range(1, n+1):
    for j in range(w, m+1):
        dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v) # 这里和01背包不同


等价于==>
def CompletePack(dp, w, v, m):
    for j in range(w, m+1): # 这里和01背包不同，正着遍历，因为用到的是dp[i-1][j] dp[i][j-w]，对于i，需要先计算j-w，然后计算j
        dp[j] = max(dp[j], dp[j-w]+v)

dp = [0 for _ in range(m+1)]
for i in range(1, n+1):
    CompletePack(dp, w, v, m)
```

## 3. 多重背包

题目：n种物品，数量k，重量是w，价值是v，背包总容量是m

定义dp[i][j] 表示前i件商品放入若干个若干种商品恰好放入一个容量是j的背包的最大价值

dp[i][j] ，对于第i种商品有多种可能：放入0个，放入1个，放入2个..放入k个

状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v, dp[i-1][j-2*w]+2 * v...)

优化1：

转换成2进制：把第i种商品拆分成 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1), k-2 ** a+1的若干种物品，其中a表示 2 ** a<=k的最大整数，这是因为不管选几个，都可以写成2进制的表达方式，且数量不会超过k。比如对于k=13，可以分成 1, 2, 4, 6 种商品。或者可以简化成 

可以从 0...2 ** a -1 和 2 ** a...k 分段讨论

0....2 ** a-1 一定可以由 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1) 组成

k 可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1))

k-1可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1)) - 1

2 ** a 可以由 k-2 ** a+1 + SUM (1, 2, 2 ** 2, 2 ** 3,... 2**(a-1)) - (2 ** a-1)

减去的数字也一定可以由 1, 2, 2 ** 2, 2 ** 3,... 2**(a-1) 组成

```python
def MultiplePack(dp, k, w, v, m):
    if k * w >= m:
        CompletePack(dp, w, v, m )
        return 
    a = 1
    while a<k:
        ZeroOnePack(dp, a*w, a*v)
        k = k-a # 还剩下多少
        a = 2*a
    ZeroOnePack(dp, k*w, k*v)
  

```
