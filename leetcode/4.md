# ileetcode

## Contiguous Array

æ ‡ç­¾ï¼šè¿ç»­å­æ•°ç»„

æ€è·¯ä¸€ï¼šç´¯åŠ å’Œ+hash

æ±‚è¿ç»­å­æ•°ç»„çš„0ã€1ä¸ªæ•°ç›¸ç­‰ï¼Œå¯ä»¥è½¬æ¢ä¸º-1(é‡0å‡1ï¼Œé‡1åŠ 1)ã€1çš„ç´¯åŠ å’Œä¸º0çš„æœ€é•¿è¿ç»­å­æ•°ç»„ã€‚
ç´¯åŠ å’Œansï¼Œä»¥ {å’Œï¼šä½ç½®} çš„hashè¡¨å½¢å¼è®°å½•ã€‚å¯¹äºæ»¡è¶³æ¡ä»¶çš„è¿ç»­å­æ•°ç»„(i,...,j)ï¼Œä¸€å®šæœ‰ans[j]-ans[i]==0ï¼Œç­‰ä»·äº é•¿åº¦=j-hash[ ans[ j]]ã€‚ç‰¹æ®Šçš„ï¼Œåˆå§‹åŒ–{0:-1}ï¼ˆå¦‚æœä»0å¼€å§‹åˆ°æŸä¸ªä½ç½®jç¬¦åˆæ¡ä»¶ï¼Œé‚£ä¹ˆéœ€è¦æ»¡è¶³é•¿åº¦=j-hash[0]ï¼‰

```python
# æ€è·¯ä¸€ï¼šç´¯åŠ å’Œï¼Œé—®é¢˜æ±‚è¿ç»­å­æ•°ç»„çš„0ã€1ä¸ªæ•°ç›¸ç­‰ï¼Œå¯ä»¥è½¬æ¢ä¸º-1(é‡0å‡1ï¼Œé‡1åŠ 1)ã€1çš„ç´¯åŠ å’Œä¸º0çš„æœ€é•¿è¿ç»­å­æ•°ç»„ã€‚
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        m = {0:-1}
        ans, res = 0, 0
        for i, val in enumerate(nums):
            val = val*2-1
            ans = val+ans
            if ans in m:
                res = max(res, i-m[ans])
            else:
                m[ans] = i        
        return res

```

æ‰©å±•ï¼šæ•°ç»„ä¸­åªæœ‰ 0ï¼Œ1ï¼Œ2ï¼Œæ‰¾æœ€é•¿çš„è¿ç»­å­æ•°ç»„ï¼Œä½¿0ã€1ã€2å‡ºç°çš„ä¸ªæ•°ç›¸ç­‰ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ

## è¿ç»­å­æ•°ç»„å’Œæœ€å¤§

æ ‡ç­¾ï¼šè¿ç»­å­æ•°ç»„

æ€è·¯ï¼šåŠ¨æ€è§„åˆ’
f(i)ä»¥iä¸ºç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ
f(i) = max(arr[i]+f(i-1), arr[i])
res = max(f(i),...)

```python
# æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        res, ans = 0, 0
        for val in nums:
            ans = max(ans, 0)+val
            res = max(res, ans)
        return res

```

## è¿ç»­å­æ•°ç»„å¼‚æˆ–å’Œä¸º0çš„æœ€å¤šåˆ’åˆ†

æ ‡ç­¾ï¼šè¿ç»­å­æ•°ç»„
æ€è·¯ï¼šç´¯å¼‚æˆ–å’Œ+hash

map: 0~içš„å¼‚æˆ–:i
æˆ–è€…è¯´è®°å½• å¼‚æˆ–æ•°å­—çš„æœ€æ–°ä½ç½®
dp:
dp[k-1]+1, if k-içš„å¼‚æˆ–ä¸º0==>0-içš„å¼‚æˆ–å‡ºç°è¿‡
dp[i-1]ï¼Œ if k-içš„å¼‚æˆ–ä¸ä¸º0

æˆ–è€…è¯´mapè®°å½•å¼‚æˆ–çš„æ•°å­—ï¼Œå¯¹äºç¬¬iä¸ªä½ç½®çš„å¼‚æˆ–ï¼Œéœ€è¦æ‰¾åˆ°ä¸Šä¸€ä¸ªç›¸åŒæ•°å­—çš„ä½ç½®

```python
def demo1(n, arr):
    dict_or2i = {0:0}
    arr2 = [0 for _ in range(n)]
    Xor = 0
    for i in range(n):
        Xor = Xor^arr[i]
        if Xor in dict_or2i:
            arr2[i] = arr2[dict_or2i[Xor]]+1
        if i>0:
            arr2[i] = max(arr2[i-1], arr2[i])
        dict_or2i[Xor] = i
    # print(arr2)
    return arr2[-1]
```

## æ•°ç»„ä¸­çš„è¿ç»­å­æ•°ç»„å’Œä¸ºk

æ ‡ç­¾ï¼šè¿ç»­å­æ•°ç»„

æ€è·¯ï¼šç´¯åŠ å’Œ+hash

Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        sum_dict = {0:1}
        tmp = 0
        res = 0
        for i, val in enumerate(nums):
            tmp+=val
            if tmp-k in sum_dict:
                res+=sum_dict[tmp-k]
            sum_dict[tmp]=sum_dict.get(tmp, 0)+1
        return res
```

## éæ’åºæ•°ç»„ä¸­å’Œå°äºç­‰äºkçš„æœ€é•¿å­åºåˆ—

ï¼Ÿï¼Ÿï¼Ÿ

1. ç”¨ h[i]=max(sum, h[i-1]) è®°å½•0-içš„ç´¯åŠ å’Œçš„æœ€å¤§å€¼
2. h[i] è¡¨ç¤ºä»¥iä¸ºå¤´çš„å’Œæœ€å°çš„è¿ç»­å­åºåˆ—
   h[i]=min(h[i+1]+arr[i], arr[i])
   map[i]=map[i+1], i

## éªŒè¯æ‹¬å·å­—ç¬¦ä¸² 678

https://www.cnblogs.com/grandyang/p/7617017.html

### ()

æ€è·¯1ï¼šæ ˆ
æ€è·¯2ï¼šç”¨å˜é‡cntï¼Œå·¦æ‹¬å·åŠ 1ï¼Œå³æ‹¬å·å‡1ï¼Œå¦‚æœå‡ºç°è´Ÿæ•°ï¼Œè¿”å›falseï¼Œæœ€ç»ˆcntåº”è¯¥ä¸º0

### ()*

æ€è·¯1ï¼šå·¦æ‹¬å·æ ˆå’Œæ˜Ÿå·æ ˆï¼šå³æ‹¬å·ä¼˜å…ˆåŒ¹é…å·¦æ‹¬å·æ ˆï¼ŒåŒ¹é…å³æ‹¬å·ç»“æŸåï¼Œå·¦æ‹¬å·æ ˆå’Œæ˜Ÿå·æ ˆåŒ¹é…ï¼Œå¦‚æœæ˜Ÿå·æ ˆé¡¶å¤§äºå·¦æ‹¬å·æ ˆé¡¶(*ï¼Œå¯ä»¥åŒ¹é…ï¼Œåä¹‹ä¸èƒ½åŒ¹é… *()

```python
class Solution {
public:
    bool checkValidString(string s) {
        stack<int> left, star;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '*') star.push(i);
            else if (s[i] == '(') left.push(i);
            else {
                if (left.empty() && star.empty()) return false;
                if (!left.empty()) left.pop();
                else star.pop();
            }
        }
        while (!left.empty() && !star.empty()) {
            if (left.top() > star.top()) return false;
            left.pop(); star.pop();
        }
        return left.empty();
    }
};
```

æ€è·¯2ï¼šæ­£åéå†ï¼šæ­£éå†å°†æ˜Ÿå·å½“å·¦æ‹¬å·ï¼Œå·¦æ‹¬å·+1ï¼Œå³æ‹¬å·-1ï¼Œéå†è¿‡ç¨‹ä¸­resåº”è¯¥æ€»æ˜¯å¤§äºç­‰äº0ï¼Œæœ€åç»“æœresï¼Œå¦‚æœres=0ï¼Œè¿”å›trueï¼Œå¦‚æœres>0ï¼Œå·¦æ‹¬å·æˆ–è€…æ˜Ÿå·æ¯”è¾ƒå¤šï¼Œå¦‚æœres<0ï¼Œè¿”å›falseï¼Œé€†éå†å°†æ˜Ÿå·å½“å³æ‹¬å·ï¼Œå³æ‹¬å·+1ï¼Œå·¦æ‹¬å·-1ï¼Œå¦‚æœres=0ï¼Œè¿”å›trueï¼Œå¦‚æœres>0ï¼Œä¹Ÿè¿”å›trueï¼Œres<0ï¼Œè¿”å›falseã€‚

å¦‚æœæ­£éå†res>0ï¼Œåˆ™ (+*>)
å¦‚æœåéå†res>0ï¼Œåˆ™ (<)+*
æ‰€ä»¥ -* <(-)< *ï¼Œæ‰€ä»¥ |(-)|< *ï¼Œåªéœ€è¦æŠŠ|(-)|ä¸ª * å˜æˆç›¸åº”çš„æ‹¬å·å³å¯

```python
class Solution {
public:
    bool checkValidString(string s) {
        int left = 0, right = 0, n = s.size();
        for (int i = 0; i < n; ++i) {
            if (s[i] == '(' || s[i] == '*') ++left;
            else --left;
            if (left < 0) return false;
        }
        if (left == 0) return true;
        for (int i = n - 1; i >= 0; --i) {
            if (s[i] == ')' || s[i] == '*') ++right;
            else --right;
            if (right < 0) return false;
        }
        return true;
    }
};
```

æ€è·¯ä¸‰ï¼š

https://leetcode.com/problems/valid-parenthesis-string/discuss/107577/Short-Java-O(n)-time-O(1)-space-one-pass

The idea is to similar to validate a string only contains '(' and ')'. But extend it to tracking the lower and upper bound of valid '(' counts. My thinking process is as following.

scan from left to right, and record counts of unpaired â€˜(â€™ for all possible cases. For â€˜(â€™ and â€˜)â€™, it is straightforward, just increment and decrement all counts, respectively.
When the character is '*', there are three cases, â€˜(â€™, empty, or â€˜)â€™, we can think those three cases as three branches in the ongoing route.
Take â€œ(**())â€ as an example. There are 6 chars:
----At step 0: only one count = 1.
----At step 1: the route will be diverted into three branches.
so there are three counts: 1 - 1, 1, 1 + 1 which is 0, 1, 2, for â€˜)â€™, empty and â€˜(â€™ respectively.
----At step 2 each route is diverged into three routes again. so there will be 9 possible routes now.
-- For count = 0, it will be diverted into 0 â€“ 1, 0, 0 + 1, which is -1, 0, 1, but when the count is -1, that means there are more â€˜)â€™s than â€˜(â€™s, and we need to stop early at that route, since it is invalid. we end with 0, 1.
-- For count = 1, it will be diverted into 1 â€“ 1, 1, 1 + 1, which is 0, 1, 2
-- For count = 2, it will be diverted into 2 â€“ 1, 2, 2 + 1, which is 1, 2, 3
To summarize step 2, we end up with counts of 0,1,2,3
----At step 3, increment all counts --> 1,2,3,4
----At step 4, decrement all counts --> 0,1,2,3
----At step 5, decrement all counts --> -1, 0,1,2, the route with count -1 is invalid, so stop early at that route. Now we have 0,1,2.
In the very end, we find that there is a route that can reach count == 0. Which means all â€˜(â€™ and â€˜)â€™ are cancelled. So, the original String is valid.
Another finding is counts of unpaired â€˜(â€™ for all valid routes are consecutive integers. So we only need to keep a lower and upper bound of that consecutive integers to save space.
One case doesnâ€™t show up in the example is: if the upper bound is negative, that means all routes have more â€˜)â€™ than â€˜(â€™ --> all routes are invalid --> stop and return false.

Hope this explanation helps.

```python
    public boolean checkValidString(String s) {
        int low = 0;
        int high = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                low++;
                high++;
            } else if (s.charAt(i) == ')') {
                if (low > 0) {
                    low--;
                }
                high--;
            } else {
                if (low > 0) {
                    low--;
                }
                high++;
            }
            if (high < 0) {
                return false;
            }
        }
        return low == 0;
    }
```

## Leftmost Column with at Least a One

åˆ¤æ–­1çš„æœ€å·¦è¾¹åˆ—

Imagine there is a pointer p(x, y) starting from top right corner. p can only move left or down. If the value at p is 0, move down. If the value at p is 1, move left. Try to figure out the correctness and time complexity of this algorithm.

æˆ–è€…å¯ä»¥ç†è§£æˆï¼Œå¯¹äºä¸Šä¸€è¡Œçš„æœ€ä¼˜è§£ï¼Œå¯ä»¥å‡å°‘ä¸‹ä¸€è¡Œçš„åˆ¤æ–­

åŠ¨æ€è§„åˆ’

```python
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
#class BinaryMatrix(object):
#    def get(self, x: int, y: int) -> int:
#    def dimensions(self) -> list[]:

class Solution:
    def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
        n, m = binaryMatrix.dimensions()
        i, j = 0, m
        while i<n:
            if j==0:
                break
            elif binaryMatrix.get(i, j-1)==1:
                j = j-1
            else:
                i = i+1
        res = j
        if j==m:
            res = -1
        return res
```

## Bitwise AND of Numbers Range

```python
# æ€è·¯ä¸€
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        i = 0
        while m!=n:
            m, n = m>>1, n>>1
            i+=1
        res = m<<i
        return res

# æ€è·¯äºŒï¼š
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        while (m < n) n &= (n - 1);
        return n;
    }
};
```

## LRUç®—æ³•

```python
class Node:
    def __init__(self, key=-1, value=-1):
        self.key = key
        self.value = value
        self.pre = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.CurrentSize = 0
        self.capacity = capacity
        self.map = dict()
        self.first = Node()
        self.last = Node()
        self.first.next, self.last.pre = self.last, self.first

    def get(self, key: int) -> int:
        res = -1
        if key in self.map:
            res = self.map[key].value
            self.moveToFirst(key)
        return res

    def put(self, key: int, value: int) -> None:
        if key in self.map:
            self.map[key].value = value
            self.moveToFirst(key)
        else:
            node = Node(key, value)
            self.map[key] = node
            self.CurrentSize+=1
            if self.CurrentSize>self.capacity:
                self.deleteLast()
            self.insertToFirst(node)
        
    
    def moveToFirst(self, key):
        node = self.map[key]
        node.pre.next, node.next.pre = node.next, node.pre
        self.insertToFirst(node)
  
    def insertToFirst(self, node):
        self.first.next.pre, node.next = node, self.first.next
        self.first.next, node.pre = node, self.first
  
    def deleteLast(self,):
        del self.map[self.last.pre.key]
        self.last.pre.pre.next, self.last.pre = self.last, self.last.pre.pre
    


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

## 55 Jump Game

[2,3,1,1,4]
reach[i]: è¡¨ç¤ºä½ç½®0å‡ºå‘å¯ä»¥åˆ°è¾¾içš„å‰æä¸‹ï¼Œä½ç½®0å‡ºå‘å¯ä»¥åˆ°è¾¾çš„æœ€è¿œè·ç¦»
reach è¡¨ç¤ºä½ç½®0å‡ºå‘å¯ä»¥åˆ°è¾¾çš„æœ€è¿œè·ç¦»
i:0,-->1,2, reach:2, ä»0å‡ºå‘ï¼Œæœ€è¿œå¯ä»¥åˆ°ä½ç½®2
i:1,-->2,3,4, reach:4ï¼Œä»0å‡ºå‘ï¼Œæœ€è¿œå¯ä»¥åˆ°ä½ç½®4
i:2,-->3, reach:4
å®šä¹‰f(n)è¡¨ç¤ºä»0å‡ºå‘ï¼Œåˆ°è¾¾çš„æœ€è¿œä½ç½®ï¼Œ
f(n-1)ä¸f(n)çš„å…³ç³»ï¼šf(n) = max(f(n-1), n+arrs[n]),if n<=f(n-1)

```python
class Solution:

    def canJump(self, nums: List[int]) -> bool:
        reach = nums[0]
        for i, val in enumerate(nums):
            if i>reach:
                return False
            elif reach>=len(nums)-1:
                return True
            reach = max(reach, i+val)
        return True
```

## Maximal Square

tag: æœ€å¤§æ­£æ–¹å½¢

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if (not matrix) or (not matrix[0]):
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[int(matrix[i][j]) for j in range(n)] for i in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if i>0 and j>0 and dp[i][j]==1:
                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1
                res = max(res, dp[i][j])  
        return res*res
```

## First Unique Number

tagï¼šç¬¬ä¸€æ¬¡å‡ºç°ä¸€æ¬¡çš„æ•°

```python
class FirstUnique:

    def __init__(self, nums: List[int]):
        self.List = nums[:]
        self.Map = dict()
        for val in self.List:
            self.Map[val] = self.Map.get(val, 0)+1
        self.p = 0

    def showFirstUnique(self) -> int:
        while self.p<len(self.List) and self.Map[self.List[self.p]]>1:
            self.p+=1
        if self.p<len(self.List):
            return self.List[self.p]
        else:
            return -1

    def add(self, value: int) -> None:
        self.List.append(value)
        self.Map[value] = self.Map.get(value, 0)+1
```

## Binary Tree Maximum Path Sum

```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.res = -10**9
        self.maxPathSum2(root)
        return self.res
  
    def maxPathSum2(self, root):
        if not root:
            return 0
        left = self.maxPathSum2(root.left)
        right = self.maxPathSum2(root.right)
        cur = max(0, left)+max(0, right)+root.val
        self.res = max(self.res, cur)
        cur = max(left, right, 0) + root.val
        return cur
```

## Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidSequence(self, root: TreeNode, arr: List[int]) -> bool:
        self.arr = arr
        res = self.isValidSequence2(root, 0)
        return res
    
    def isValidSequence2(self, root, k):
        if k==len(self.arr) and (not root):
            return True
    
        if root and k<len(self.arr) and root.val==self.arr[k]:
            if k==len(self.arr)-1:
                return self.isValidSequence2(root.left, k+1) and self.isValidSequence2(root.right, k+1)
            else:
                return self.isValidSequence2(root.left, k+1) or self.isValidSequence2(root.right, k+1)
        else:
            return False
        return None

# è§£æ³•2

def isValidSequence(root, arr):
    n = len(arr)
    def dfs(i, node):
        if not node or i == n or arr[i] != node.val:
            return False
        if i == n - 1 and not (node.left or node.right):
            return True
        return dfs(i+1, node.left) or dfs(i+1, node.right)
    return dfs(0, root)
```

## é€†æ³¢å…°è¡¨ç¤ºæ³•(Reverse Polish Notation)

å‚è€ƒé“¾æ¥ï¼š

https://blog.csdn.net/shyjhyp11/article/details/71375153

### è®¡ç®—æ–¹æ³•ï¼š

å¦‚æœå½“å‰å­—ç¬¦ä¸ºå˜é‡æˆ–è€…ä¸ºæ•°å­—ï¼Œåˆ™å‹æ ˆï¼Œå¦‚æœæ˜¯è¿ç®—ç¬¦ï¼Œåˆ™å°†æ ˆé¡¶ä¸¤ä¸ªå…ƒç´ å¼¹å‡ºä½œç›¸åº”è¿ç®—ï¼Œç»“æœå†å…¥æ ˆï¼Œæœ€åå½“è¡¨è¾¾å¼æ‰«æå®Œåï¼Œæ ˆé‡Œçš„å°±æ˜¯ç»“æœã€‚

### ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢æˆæ³¢å…°è¡¨è¾¾å¼å’Œé€†æ³¢å…°è¡¨è¾¾å¼

ä¸€ã€ å°†ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢æˆåç¼€è¡¨è¾¾å¼ç®—æ³•ï¼š
ã€€ã€€1ã€ä»å·¦è‡³å³æ‰«æä¸€ä¸­ç¼€è¡¨è¾¾å¼ã€‚
ã€€ã€€2ã€è‹¥è¯»å–çš„æ˜¯æ“ä½œæ•°ï¼Œåˆ™åˆ¤æ–­è¯¥æ“ä½œæ•°çš„ç±»å‹ï¼Œå¹¶å°†è¯¥æ“ä½œæ•°å­˜å…¥æ“ä½œæ•°å †æ ˆ
ã€€ã€€3ã€è‹¥è¯»å–çš„æ˜¯è¿ç®—ç¬¦
ã€€ã€€ã€€ã€€(1) è¯¥è¿ç®—ç¬¦ä¸ºå·¦æ‹¬å·"("ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€(2) è¯¥è¿ç®—ç¬¦ä¸ºå³æ‹¬å·")"ï¼Œåˆ™è¾“å‡ºè¿ç®—ç¬¦å †æ ˆä¸­çš„è¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å·ä¸ºæ­¢ã€‚
ã€€ã€€ã€€ã€€(3) è¯¥è¿ç®—ç¬¦ä¸ºéæ‹¬å·è¿ç®—ç¬¦ï¼š
ã€€ã€€ã€€ã€€ã€€ã€€(a) è‹¥è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¸ºæ‹¬å·ï¼ˆåªå¯èƒ½æ˜¯å·¦æ‹¬å·ï¼‰ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€ã€€ã€€(b) è‹¥æ¯”è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§é«˜ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€ã€€ã€€(c) è‹¥æ¯”è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§ä½æˆ–ç›¸ç­‰ï¼Œåˆ™ä¸æ–­è¾“å‡ºæ ˆé¡¶è¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°æ ˆé¡¶æ²¡æœ‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å¤§äºæˆ–è€…ç­‰äºå½“å‰é¢„ç®—ç¬¦ï¼ˆå³æ ˆé¡¶å­˜åœ¨è¿ç®—ç¬¦çš„è¯ï¼Œä¼˜å…ˆçº§ä¸€å®šæ˜¯å°äºå½“å‰è¿ç®—ç¬¦ï¼‰ï¼Œæœ€åå°†å½“å‰è¿ç®—ç¬¦å‹å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€4ã€å½“è¡¨è¾¾å¼è¯»å–å®Œæˆåè¿ç®—ç¬¦å †æ ˆä¸­å°šæœ‰è¿ç®—ç¬¦æ—¶ï¼Œåˆ™ä¾åºå–å‡ºè¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°è¿ç®—ç¬¦å †æ ˆä¸ºç©ºã€‚

äºŒã€é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç®—æ³•ï¼š
ã€€ã€€1ã€ä»å·¦åˆ°å³ä¾æ¬¡æ‰«æè¯­æ³•å•å…ƒçš„é¡¹ç›®ã€‚
ã€€ã€€2ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯æ“ä½œæ•°ï¼Œåˆ™å°†å…¶å‹å…¥æ“ä½œæ•°å †æ ˆï¼Œå¹¶æ‰«æä¸‹ä¸€ä¸ªé¡¹ç›®ã€‚
ã€€ã€€3ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„é¡¶ä¸Šä¸¤ä¸ªæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€4ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„æœ€é¡¶ä¸Šæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€5ã€å°†è¿ç®—ç»“æœé‡æ–°å‹å…¥å †æ ˆã€‚
ã€€ã€€6ã€é‡å¤æ­¥éª¤2-5ï¼Œå †æ ˆä¸­å³ä¸ºç»“æœå€¼ã€‚

ä¸€ã€ å°†ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢æˆå‰ç¼€è¡¨è¾¾å¼ç®—æ³•ï¼š
ã€€ã€€1ã€é¦–å…ˆè®¾å®šä¸€ä¸ªæ“ä½œç¬¦æ ˆï¼Œä»å³åˆ°å·¦é¡ºåºæ‰«ææ•´ä¸ªä¸­ç¼€è¡¨è¾¾å¼ï¼Œå¦‚æœæ˜¯æ“ä½œæ•°ï¼Œåˆ™ç›´æ¥å½’å…¥å‰ç¼€è¡¨è¾¾å¼ï¼›
ã€€ã€€2ã€å¦‚æœæ˜¯æ“ä½œç¬¦ï¼Œåˆ™æ£€æµ‹å™¨æ˜¯å¦æ˜¯å³æ‹¬å·ï¼Œå¦‚æœæ˜¯å³æ‹¬å·ï¼Œåˆ™ç›´æ¥å°†å…¶å…¥æ ˆï¼›
ã€€ã€€3ã€å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œåˆ™å°†æ ˆä¸­çš„æ“ä½œç¬¦ä¾æ¬¡å¼¹æ ˆï¼Œå½’å…¥å‰ç¼€è¡¨è¾¾å¼ï¼Œç›´è‡³é‡åˆ°å³æ‹¬å·ï¼Œå°†å³æ‹¬å·å¼¹æ ˆï¼Œå¤„ç†ç»“æŸï¼›
ã€€ã€€4ã€å¦‚æœæ˜¯å…¶ä»–æ“ä½œç¬¦ï¼Œåˆ™æ£€æµ‹æ ˆé¡¶æ“ä½œç¬¦çš„ä¼˜å…ˆçº§ä¸å½“å‰æ“ä½œç¬¦çš„ä¼˜å…ˆçº§å…³ç³»ï¼Œ
ã€€ã€€5ã€å¦‚æœæ ˆé¡¶æ“ä½œç¬¦ä¼˜å…ˆçº§å¤§äºå½“å‰æ“ä½œç¬¦çš„ä¼˜å…ˆçº§ï¼Œåˆ™å¼¹æ ˆï¼Œå¹¶å½’å…¥å‰ç¼€è¡¨è¾¾å¼ï¼Œç›´è‡³æ ˆé¡¶æ“ä½œç¬¦ä¼˜å…ˆçº§å°äºç­‰äºå½“å‰æ“ä½œç¬¦ä¼˜å…ˆçº§ï¼Œè¿™æ—¶å°†å½“å‰æ“ä½œç¬¦å‹æ ˆã€‚
ã€€ã€€6ã€å½“æ‰«æå®Œæ¯•æ•´ä¸ªä¸­ç¼€è¡¨è¾¾å¼åï¼Œæ£€æµ‹æ“ä½œç¬¦æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ä¸ºç©ºï¼Œåˆ™ä¾æ¬¡å°†æ ˆä¸­æ“ä½œç¬¦å¼¹æ ˆï¼Œå½’å…¥å‰ç¼€è¡¨è¾¾å¼ã€‚æœ€åï¼Œå°†å‰ç¼€è¡¨è¾¾å¼ç¿»è½¬ï¼Œå¾—åˆ°ä¸­ç¼€è¡¨è¾¾å¼å¯¹åº”çš„å‰ç¼€è¡¨è¾¾å¼ã€‚

äºŒã€æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç®—æ³•ï¼š
ã€€ã€€1ã€ä»å³åˆ°å·¦ä¾æ¬¡æ‰«æè¯­æ³•å•å…ƒçš„é¡¹ç›®ã€‚
ã€€ã€€2ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯æ“ä½œæ•°ï¼Œåˆ™å°†å…¶å‹å…¥æ“ä½œæ•°å †æ ˆï¼Œå¹¶æ‰«æä¸‹ä¸€ä¸ªé¡¹ç›®ã€‚
ã€€ã€€3ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„é¡¶ä¸Šä¸¤ä¸ªæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€4ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„æœ€é¡¶ä¸Šæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€5ã€å°†è¿ç®—ç»“æœé‡æ–°å‹å…¥å †æ ˆã€‚
ã€€ã€€6ã€é‡å¤æ­¥éª¤2-5ï¼Œå †æ ˆä¸­å³ä¸ºç»“æœå€¼ã€‚

https://www.cnblogs.com/journal-of-xjx/p/5940030.html

## single-number-ii

ç°åœ¨æœ‰ä¸€ä¸ªæ•´æ•°ç±»å‹çš„æ•°ç»„ï¼Œæ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ï¼Œå…¶ä½™å…ƒç´ éƒ½å‡ºç°ä¸‰æ¬¡ã€‚ä½ éœ€è¦æ‰¾å‡ºåªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ 

```python
class Solution:
    # solution one
    # def singleNumber(self, nums):
    #     bit = [0] * 32
    #     for num in nums:
    #         for i in range(32):
    #             bit[i] += num >> i & 1
    #     res = 0
    #     for i, val in enumerate(bit):
    #         # if the single numble is negative,
    #         # this case should be considered separately 
    #         if i == 31 and val%3:
    #             res = -((1<<31)-res)
    #         else:
    #             res |= (val%3)*(1<<i)
    #     return res

    # solution two
    # def singleNumber(self, nums):
    #     a, b, z = 0, 0, 0
    #     for val in nums:
    #         a, b = a^(b&val), b^val
    #         c = a&b
    #         a, b = a&~c, b&~c
    #     return b

    def singleNumber(self, nums):
        K = 3
        # O(NlogK)
        # K, 2^(N-1)<K<=2^(N)
        z = list(map(int, list(bin(K))[2:]))# é•¿åº¦æ˜¯Nï¼Œ ç¢°åˆ°zäº§ç”Ÿè¿›ä½ï¼Œå³å½’é›¶
        N = len(z)
        a = [0 for _ in range(N)]
        c = [0 for _ in range(N)]
        for val in nums:
            # print(val)
            for i in range(N-1):
                a[i] = a[i]^(a[i+1]&val)
            a[-1] = a[-1]^val

            # print('a', a)

            d = -0b1
            for i in range(N):
                if z[i]:
                    d = d&a[i]
                else:
                    d = d&(~a[i])
            a = list(map(lambda x: x&~d, a))
        res = a[-1]

        return res

# å¡è¯ºå›¾
class Solution {
public:
    int singleNumber(int A[], int n) {
        if (n == 0) return 0;
        int a = 0;
        int b = 0;
        int c;
        int ta, tb;
        for (int i = 0; i < n; i++) {
            c = A[i];
            ta = a;
            tb = b;
            a = (~c & ta & ~tb) | (c & ~ta & tb);
            b = (~c & ~ta & tb) | (c & ~ta & ~tb);
        }
        return b;
    }
};
```

https://leetcode-cn.com/problems/single-number-ii/comments/

## 179. Largest Number

ab> ba-->a>>b (aâ€œå¤§äºâ€b)

ç¬¬ä¸€æ­¥ï¼šè¯æ˜ä¼ é€’æ€§ï¼š
ab> ba, bc> cb,-->ac>ca

è®¾$[ b]$è¡¨ç¤ºbçš„ä½æ•°ï¼Œæœ‰ï¼š
$a*10^{[ b]}+b>b *10^{[ a]}+a -->a *(10^{[b]}-1)>b *(10^{[a]}-1)-->a/(10^{[a]}-1)>b/(10^{[b]}-1)$
åŒç†æœ‰ï¼š
$b/(10^{[b]}-1)>c/(10^{[c]}-1)$
æ‰€ä»¥æœ‰ï¼š
$a/(10^{[a]}-1)>c/(10^{[c]}-1)-->ac>ca$

ç¬¬äºŒæ­¥ï¼šè¯æ˜è¿™ç§ç»„åˆæ˜¯æœ€å¤§

æ ¹æ®ç¬¬ä¸€æ­¥çš„ä¼ é€’æ€§ï¼Œæœ‰nä¸ªæ•°å­—çš„â€œå¤§å°â€æ’åˆ—æ˜¯å”¯ä¸€çš„

ä¸‹é¢ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜è¿™ç§å¤§å°æ’åˆ—çš„ç»„åˆæ˜¯æœ€å¤§çš„

å½“n=2æ—¶ï¼Œab>baï¼Œa>>bï¼Œabçš„ç»„åˆæ˜¯æœ€å¤§çš„
å‡è®¾å½“n-1ä¸ªæ•°å­—æ—¶ï¼Œè¿™ç§ç»„åˆä¹Ÿæ˜¯æœ€å¤§çš„ï¼Œ
å¤§å°æ’åˆ—ä¸º{a_1, a_2, ..., a_{n-1}}
ç»„åˆæ•°ä¸ºa_1 a_2 ... a_{n-1}
è¯æ˜nä¸ªæ•°å­—æ—¶ï¼Œè¿™ç§ç»„åˆæ˜¯æœ€å¤§çš„ï¼Œ
å¤§å°æ’åˆ—ä¸º{a_1, a_2, ..., a_{n}}
ç»„åˆæœ‰nç§æƒ…å†µï¼šåˆ†åˆ«ä»¥a_1å¼€å¤´ï¼Œa_2å¼€å¤´...a_nå¼€å¤´
æ ¹æ®n-1ä¸ªæ•°å­—çš„å‡è®¾ï¼Œæœ‰ï¼š
ä»¥a_1å¼€å¤´çš„ç»„åˆæ•°æœ€å¤§ä¸ºa_1 a_2 ... a_n
ä»¥a_2å¼€å¤´çš„ç»„åˆæ•°æœ€å¤§ä¸ºa_2 a_1 ... a_n
...
ä»¥a_nå¼€å¤´çš„ç»„åˆæ•°æœ€å¤§ä¸ºa_n a_1 ... a_{n-1}

æ¥ä¸‹æ¥è¯æ˜è¿™nä¸ªæ•°ä¸­ï¼Œa_1 a_2 ... a_næœ€å¤§
å› ä¸ºåœ¨å‰ä¸¤ä¸ªæ•°å­—{a_1, a_2}ä¸­ï¼Œæ ¹æ®å‡è®¾æœ‰a_1 a_2>a_2 a_1ï¼Œæ‰€ä»¥a_1 a_2 ... a_n>a_2 a_1 ... a_n
åœ¨å‰ä¸‰ä¸ªæ•°å­—{a_1, a_2, a_3}ä¸­ï¼Œæ ¹æ®å‡è®¾æœ‰ a_1 a_2 a_3 çš„æ’åˆ—æœ€å¤§ï¼Œæ‰€ä»¥ a_1 a_2 a_3 ... a_n > a_3 a_1 a_2 ... a_n
...
åœ¨å‰n-1ä¸ªæ•°å­—ä¸­ï¼Œæœ‰ a_1 a_2 a_3 ... a_n > a_{n-1} a_1 a_2 ... a_n
å¯¹äºa_n a_1 ... a_{n-1}ï¼Œå°†a_nå‘åæŒªï¼Œa_n a_1 ... a_{n-1}< a_1 a_n ... a_{n-1}< a_1 a_1 a_n ... a_{n-1}<...< a_1 a_2 ... a_nï¼Œå¾—è¯ã€‚è¯æ˜nä¸ªæ•°å­—æ—¶ï¼Œè¿™ç§ç»„åˆæ˜¯æœ€å¤§çš„ã€‚

```python
# è§£æ³•ä¸€
import functools

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums = list(map(str, nums))

        def compare(a, b):
            if a+b>b+a:
                return -1
            else:
                return 1
    
        nums = sorted(nums, key=functools.cmp_to_key(compare))
        res = "".join(nums)
        if res[0]=='0':
            res = '0'
        return res
  
# è§£æ³•äºŒ
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def val2(val):
            val2str = str(val)
            return val/(10**len(val2str)-1)
        nums2 = list(map(val2, nums))
        nums = sorted(zip(nums,nums2), key=lambda x:x[1], reverse=True )
        nums = [x[0] for x in nums]
        res = ''.join(map(str, nums))
        if res[0]=='0':
            res = '0'
        return res  
```

## 185. Department Top Three Salaries

é€‰å‡ºå‰ä¸‰ï¼ŒåŒ…å«é‡å¤æ•°æ®

```python
select e1.Name as 'Employee', e1.Salary
from Employee e1
where 3>
(
    select count(distinct e2.Salary)
    from Employee e2
    where e2.Salary>e1.Salary
)
;
# æ–¹æ³•1
select d.Name as Department, e1.Name as Employee, e1.Salary as Salary
from Department d, Employee e1
where d.Id=e1.DepartmentId
and 3>
(
    select count(distinct e2.salary)
    from Employee e2
    where e2.salary>e1.salary
    and e1.DepartmentId=e2.DepartmentId
)
;
# æ–¹æ³•2
SELECT
    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 > (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary > e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
```

100, 200, 300, 300, 400
å¾—åˆ°ï¼š3, 2, 1, 0

## 187. Repeated DNA Sequences

å›ºå®šé•¿åº¦Lçš„å­åºåˆ—é‡å¤é—®é¢˜ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯æ»‘åŠ¨çª—å£+hashsetã€‚å…·ä½“æœ‰ä¸‰ç§æ–¹æ³•

https://leetcode-cn.com/problems/repeated-dna-sequences/solution/zhong-fu-de-dnaxu-lie-by-leetcode/

ç¬¬ä¸€ç§ï¼šO(L)æ—¶é—´è·å–æ»‘åŠ¨çª—å£çš„å­åºåˆ—ï¼Œä¸æ¨è
æ—¶é—´å¤æ‚åº¦ï¼šO((N-L)L),ç©ºé—´å¤æ‚åº¦ï¼šO((N-L)L)

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)   
        seen, output = set(), set()

        # iterate over all sequences of length L
        for start in range(n - L + 1):
            tmp = s[start:start + L]
            if tmp in seen:
                output.add(tmp[:])
            seen.add(tmp)
        return output
```

ç¬¬äºŒç§ï¼šRabin-Karpï¼šä½¿ç”¨æ—‹è½¬å“ˆå¸Œå®ç°å¸¸æ•°æ—¶é—´çª—å£åˆ‡ç‰‡ï¼šæ ¸å¿ƒæ˜¯åœ¨å¸¸æ•°æ—¶é—´å†…è·å–æ»‘åŠ¨çª—å£çš„å“ˆå¸Œå€¼
æ—¶é—´å¤æ‚åº¦ï¼šO(N-L),ç©ºé—´å¤æ‚åº¦ï¼šO(N-L)

ä»¥ AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT ä¸ºä¾‹ï¼Œé¦–å…ˆï¼Œå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•´æ•°æ•°ç»„ï¼šA:0, C:1, G:2, T:3ï¼Œå¾— 00000111110000011111100000222333ï¼Œæ­¤æ—¶è¿™ä¸²åºåˆ—å¯ä»¥çœ‹æˆä»¥4ä¸ºåŸºæ•°çš„æ•°å­—
ç¬¬ä¸€ä¸ªåºåˆ—å¯ä»¥è®¡ç®—å‡ºä¸€ä¸ª10è¿›åˆ¶æ•°å­—ï¼š0000011111
$h_0 = \sum_{i=0}^{L-1}c_i*4^{L-1-i}$
ç¬¬äºŒä¸ªåˆ‡ç‰‡0000111110ç”±æ»‘åŠ¨çª—å£å³ç§»æ‰€å¾—ï¼š
$h_1 = h_0* 4-c_0*4^L+c_{L+1}$
å¯ä»¥å‘ç°çª—å£åˆ‡ç‰‡å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å®Œæˆ

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)
        if n <= L:
            return []
    
        a = 4
        aL = pow(a, L)

        to_int = {'A':0, 'C':1, 'G':2, 'T':3  }
        nums = [to_int[val] for val in s]
        h, seen, output = 0, set(), set()
        for i in range(L):
            h = h*a + nums[i]
        seen.add(h)
        for start in range(1, N-L+1):
            h = h*a-nums[start-1]*aL+nums[start+L-1]
            if h in seen:
                output.add(s[start:start+L])
            seen.add(h)
        return output
```

ç¬¬ä¸‰ç§ï¼šä½æ“ä½œï¼šä½¿ç”¨æ©ç å®ç°å¸¸æ•°æ—¶é—´çª—å£åˆ‡ç‰‡
æ—¶é—´å¤æ‚åº¦ï¼šO(N-L),ç©ºé—´å¤æ‚åº¦ï¼šO(N-L)
ä¸Rabin-Karpæ–¹æ³•ç±»ä¼¼ï¼Œåªæ˜¯å°†åŸºæ•°ä¸º4çš„åºåˆ—ç”¨äºŒè¿›åˆ¶è¡¨ç¤º
ä»¥ AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT ä¸ºä¾‹ï¼Œé¦–å…ˆï¼Œå°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•´æ•°æ•°ç»„ï¼šA: 0: 00, C: 1: 01, G: 2: 10, T: 3: 11
å¯¹äºç¬¬ä¸€ä¸ªåºåˆ—ï¼Œè®¡ç®—æ©ç (å·¦ç§»è¡¨ç¤ºä¹˜æ³•ï¼Œæˆ–è¡¨ç¤ºåŠ æ³•)ï¼š
bitmask = (bitmask<<2)|nums[i]
å¯¹äºç¬¬äºŒä¸ªåºåˆ—ï¼Œå¯ä»¥é€šè¿‡ç¬¬ä¸€ä¸ªåºåˆ—çš„æ©ç è®¡ç®—ï¼š
å·¦ç§»ä¸¤ä½ç©ºå‡ºæœ«å°¾ï¼Œå»æ‰é«˜ä½å¤šå‡ºæ¥çš„1ï¼ŒåŠ ä¸Šæ–°å‡ºç°çš„æ•°å­—
$bitmask_2 = (bitmask_1<<2) \& ( \sim (3<< L))|nums[i]$
å…¶ä¸­ bitmask & (1<< n)è¡¨ç¤ºå–ç¬¬nä½
bitmask & ~(1<< n) è¡¨ç¤ºè®¾ç½®ç¬¬nä½ä¸º0ï¼Œé«˜ä½å’Œä½ä½ä¸å˜ï¼Œå› ä¸ºbitmaské«˜ä½ä¸º0ï¼Œæ‰€ä»¥å¯ä»¥ç†è§£æˆå‡æ³•
åŠ æ³•ï¼šabå‡ä¸ºäºŒè¿›åˆ¶ï¼Œbä¸º2ä½æ•°(2è¿›åˆ¶)ï¼Œa * 4+b: a<<2|b
å‡æ³•ï¼šaé«˜ä½ä¸º0ï¼Œå‡å»açš„nä½ï¼š0110->0010ï¼Œa-b* 2^n:a&~(b<< n)

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)
        if n <= L:
            return []
    
        to_int = {'A':0, 'C':1, 'G':2, 'T':3  }
        nums = [to_int[val] for val in s]
        bitmask, seen, output = 0, set(), set()
        for i in range(L):
            bitmask = (bitmask<<2)|nums[i]
        seen.add(bitmask)
        for start in range(1, N-L+1):
            bitmask = bitmask<<2
            bitmask = bitmask|nums[start+L-1]
            bitmask = bitmask&~(3<<2*L)
            if h in seen:
                output.add(s[start:start+L])
            seen.add(bitmask)
        return output
```

## å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•

ä¸‰ç§æ–¹æ³•:Rabin-Karpã€KMPã€BM

ç¬¬ä¸€ç§ï¼šRabin-Karpï¼šæ»šåŠ¨å“ˆå¸Œ
O(n-m)
è®¡ç®—å¤§å°ä¸ºmçš„çª—å£å†…å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ï¼š
$H(S, j) = \sum_{i=0}^{m-1}\alpha^{m-(i+1)}*char(s_i)$
O(1)æ—¶é—´è®¡ç®—ä¸‹ä¸€ä¸ªçª—å£çš„å“ˆå¸Œå€¼
$H(S, j+1) = H(S, j)*\alpha-\alpha^m * char(s_j)+char(s_{j+m})$

ç¬¬äºŒç§ï¼šKMPç®—æ³•

nextï¼šè¡¨ç¤ºæœ€é•¿åŒ¹é…å‰ç¼€å­—ç¬¦ä¸²çš„é•¿åº¦
https://www.zhihu.com/question/21923021ï¼šæµ·çº³

PMTåˆ°next
O(m+n)

KMPç®—æ³•ï¼šè®¡ç®—ä»¥0å¼€å¤´çš„å‰ç¼€å’Œä»¥n-1ç»“å°¾çš„åç¼€ä¹‹é—´çš„åŒ¹é…ç¨‹åº¦

ä¾‹å¦‚abbï¼Œè®¡ç®—å‰ç¼€{a, ab}å’Œåç¼€{b, bb}ä¹‹é—´çš„å­—ç¬¦ä¸²åŒ¹é…

KMPç”Ÿæˆçš„nextæ•°ç»„ next[i]ï¼šè¡¨ç¤º[0...i-1]å‰ç¼€å’Œåç¼€çš„æœ€é•¿åŒ¹é…å­—ä¸²ï¼Œä¸åŒ…æ‹¬ [0...i-1]æœ¬èº«ï¼Œå³[0...next[i]-1]ä¸[i-next[i], ..., i-1] ç›¸åŒ
æ‰€ä»¥ next:é•¿åº¦æ˜¯len(p)+1ï¼Œ

```python
# ç”Ÿæˆnextæ•°ç»„ï¼Œä¸åŒ…æ‹¬æœ€åä¸€ä¸ªå­—ç¬¦
def getnext(p):
    n = len(p)
    next = [0]*(n+1)
    next[0] = -1
    i, j = 0, -1 # jä¸åŒ
    while i<n:
        if j==-1 or p[i]==p[j]:
            i, j = i+1, j+1
            next[i] = j
        else:
            j = next[j]
    return next

def KMP(t, p):
    i, j = 0, 0 # jä¸åŒ
    while i<len(t) and j<len(p):
        if j==-1 or t[i]==p[j]:
            i, j = i+1, j+1
        else:
            j = next[j]
    if j==len(p):
        return i-j
    else:
        return -1

```

ç¬¬ä¸‰ç§ BM ç®—æ³•

çœ‹ç€å¾ˆéº»çƒ¦ï¼Œä¸å†™äº†

## äºŒåˆ†æ³•æ¨¡æ¿

nums: F, F, F, T, T, T

```python
def bis(nums):
    l, r = 0, len(nums)-1
    res = -1
    while l<=r:
        mid = (l+r)//2
        if nums[mid]>target:
            res = mid
            r = mid-1
        else:
            l = mid+1
    return res
        

```

## æœ€é•¿é‡å¤å­ä¸²

Rabin-Karpï¼šè§ 187. Repeated DNA Sequencesï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯æ»šåŠ¨å“ˆå¸Œ

å¯¹ä¸åŒé•¿åº¦è¿›è¡ŒRKæ–¹æ³•åŒ¹é…é‡å¤å­ä¸²

```python
# äºŒåˆ†æ³•+Rabin-Karp+é˜²æ­¢æº¢å‡º
class solution:

    def longestDupSubstring(S):
        # å­—ç¬¦ä¸²ä¸­åªæœ‰a-z
        to_int = {k:k-'a' for k in S}
        nums = [to_int[k] for k in S]
        n = len(S)
        left, right = 0, n-1
        res_start, res_L = -1, 0
        while left<right:
            mid = (left+right)//2
            mid_start = RK(nums, mid)
            if RK(nums, mid)!=-1:
                left = mid+1
                res_start = mid_start
                res_L = mid
            else:
                right = mid-1
        if res_start:
            res = S[res_start:res_start+res_L]
        else:
            res = -1
        return res


    def RK(nums, L):
        n = len(nums)
        h, a, aL = 0, 26, 1
        seen = dict{}
        mod = pow(2, 32)
        for i in range(L):
            h = (h*a+nums[i])%mod
            aL = (aL*a)%mod
        seen[h]=0
        for start in range(1, n-L+1):
            h = (h-nums[start-1]*aL%mod)%mod
            h = (h*a+nums[start+L-1])%mod
            if h in seen and check(nums, seen[h], start, L):
                return start
        return -1

    def check(nums, start1, start2, L):
        # å–æ¨¡ä¼šé€ æˆä¸ä¸€æ ·çš„å­—ç¬¦æœ‰ç›¸åŒçš„å“ˆå¸Œå€¼
        for i in range(L):
            if nums[start1+i]!=nums[start2+i]:
                return False
        return True
```

## 192. Word Frequency

```bash
cat words.txt | xargs -n1 | sort | uniq -c | sort -rn | awk '{print $2,$1}'
cat words.txt|tr -s ' ' '\n'|sort |uniq -c|sort -r|awk '{print $2,$1}'
```

```bash
# https://www.cnblogs.com/wangqiguo/p/6464234.html
# xargs: å°†è¾“å‡ºä½œä¸ºå‚æ•°è¾“å…¥
~ $ ls | cat                                                                
test1.txt                                                                   
test2.txt                                                                   
~ $ ls | xargs cat                                                          
1 2 3 4                                                                     
2   
# xargs å°†è¾“å‡ºåˆ†è¡Œ
cat test1.txt | xargs
1
2
3
4

```

## 193 Valid Phone Numbers

```bash
grep -P '^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$' file.txt # -P æ‰èƒ½ä½¿ç”¨\dï¼Œå¦åˆ™åªèƒ½ä½¿ç”¨[0-9]
grep -E '(^([0-9]{3})\s|^[0-9]{3}-)[0-9]{3}-[0-9]{4}$'
sed -n -r '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p' file.txt
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt
```

## 194. Transpose File

```bash
# æ–¹æ³•ä¸€
awk '
{
    for(i=1;i<=NF;i++){
        if(NR==1){
            res[i]=$i
        }
        else{
            res[i]=res[i]" "$i
        }
    }
}END{
    for(j=1;j<=NF;j++){
        print(res[j])
    }
    
}' file.txt
# æ–¹æ³•äºŒ
colu=$(awk '{print NF}' file.txt | uniq)
for((i=1;i<=colu;i++))
do
  cut -d' ' -f$i file.txt|xargs
done
```

## 195. Tenth Line

```bash
awk 'NR==10' file.txt
tail -n+10 file.txt|head -1
sed -n "10p" file.txt
```

## 199. Binary Tree Right Side View

```python
# å¹¿åº¦ä¼˜å…ˆéå† BFS é˜Ÿåˆ— æ¯ä¸€å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
import queue
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        que, res = queue.Queue(), []
        que.put(root)
        while not que.empty():
            n = que.qsize()
            for i in range(n):
                cur = que.get()
                if cur.left:
                    que.put(cur.left)
                if cur.right:
                    que.put(cur.right)
            
            res.append(cur.val)
        return res

# æ·±åº¦ä¼˜å…ˆéå† DFS: æ ˆ æ¯ä¸ªæ·±åº¦çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹

import queue
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        stack, res = [(root, 0)], []
        while stack:
            cur, depth = stack.pop()
            if len(res)==depth:
                res.append(cur.val)
            if cur.left:
                stack.append((cur.left, depth+1))
            if cur.right:
                stack.append((cur.right, depth+1))
        return res
```

## 200. å²›å±¿æ•°é‡

```python
# dfs O(nm)
import collections
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        res = 0
        n, m = len(grid), len(grid[0])
        dx = [-1, 0, 1, 0]
        dy = [0, -1, 0, 1]
        def dfs(i, j):
            stack = [(i, j)]
            grid[i][j]="0"
            while stack:
                i, j = stack.pop()
                for x, y in zip(dx, dy):
                    ii, jj = i+x, j+y
                    if -1<ii<n and -1<jj<m and grid[ii][jj]=="1":
                        stack.append((ii, jj))
                        grid[ii][jj]="0"
            return
    
        def bfs(i, j):
            que = collections.deque()
            que.append((i, j))
            grid[i][j]="0"
            while que:
                i, j = que.popleft()
                for x, y in zip(dx, dy):
                    ii, jj = i+x, j+y
                    if -1<ii<n and -1<jj<m and grid[ii][jj]=="1":
                        que.append((ii, jj))
                        grid[ii][jj]="0"
            return 


        for i in range(n):
            for j in range(m):
                if grid[i][j]=="1":
                    bfs(i, j)
                    res = res+1
        return res

```

## å¹¶æŸ¥é›†

å‚è€ƒé“¾æ¥:
https://www.cnblogs.com/cyjb/p/UnionFindSets.html

å¹¶æŸ¥é›†æœ‰ä¸‰ä¸ªåŸºæœ¬æ“ä½œï¼š

1. makeSet(s):å»ºç«‹ä¸€ä¸ªæ–°çš„å¹¶æŸ¥é›†ï¼ŒåŒ…å«sä¸ªå•å…ƒç´ é›†åˆ
2. unionSet(x, y):å°†xå’Œyæ‰€åœ¨çš„é›†åˆåˆå¹¶
3. find(x):æ‰¾åˆ°å…ƒç´ xæ‰€åœ¨çš„é›†åˆçš„ä»£è¡¨

psï¼šæˆ‘ä»¥ä¸ºä¼šç”¨é“¾è¡¨/é™æ€é“¾è¡¨è¡¨ç¤ºæ ‘ï¼Œä½†å®é™…ä¸Šä½¿ç”¨æ•°ç»„å°±å¯ä»¥è¡¨ç¤ºæ ‘çš„å…³ç³»

```python
# åŸºäºrankä¼˜åŒ–å’Œè·¯å¾„å‹ç¼©ä¼˜åŒ–ï¼šO(lg* n)<< O(lg n)ï¼Œ æ¨è
class UnionFind:
    def __init__(self, n):
        # æŒ‰rankåˆå¹¶, parent åˆå§‹åŒ–ä¸ºè‡ªèº«
        self.parent = list(range(n))
        self.rank = [0]*n # ç§©æ¥è¡¨ç¤ºæ ‘é«˜åº¦çš„ä¸Šç•Œ # åŸºäºrankä¼˜åŒ–
  
    def find(self, x):
        # é€’å½’ è·¯å¾„å‹ç¼©ä¼˜åŒ–
        if self.parent[x]!=x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
  
    def find2(self, x):
        # éé€’å½’ç‰ˆ è·¯å¾„å‹ç¼©ä¼˜åŒ–
        p = x
        while p!=self.parent[p]:
            p = self.parent[p]
        while x!=p:
            x, self.parent[x] = self.parent[x], p
        return p
  
    def unionSet(self, x, y):
    
        x, y = self.find(x), self.find(y)
        if x==y:
            return
        if self.rank[x]==self.rank[y]:
            self.parent[x] = y
            self.rank[y] = self.rank[y]+1
        elif self.rank[x]>self.rank[y]:
            self.parent[y] = x
        else:
            self.parent[x] = y
        return 
```

```python
# åŸºäºå…ƒç´ ä¸ªæ•°ä¼˜åŒ–ï¼Œä¸æ¨è
class UnionFind2:
    def __init__(self, s):
        # æŒ‰æ ‘ä¸­å…ƒç´ ä¸ªæ•°åˆå¹¶ï¼Œåˆå§‹åŒ–ä¸º-1
        # å®šä¹‰ï¼Œå¦‚æœparentæ˜¯æ­£æ•°ï¼Œè¡¨ç¤ºå…¶çˆ¶èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œè¡¨ç¤ºå…¶ä¸ºæ ‘æ ¹ï¼Œä¸”å€¼çš„ç»å¯¹å€¼ç­‰äºæ ‘ä¸­çš„å…ƒç´ ä¸ªæ•°
        n = len(s)
        self.parent = [-1]*n
  
    def find(self, x):
        if self.parent[x] < 0:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
  
    def unionSet(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return 
        if self.parent[x] < self.parent[y]:
            self.parent[x] = self.parent[x]+self.parent[y]
            self.parent[y] = x
        else:
            self.parent[y] = self.parent[x]+self.parent[y]
            self.parent[x] = y

```

## å²›å±¿ç±»é—®é¢˜ï¼šDFSéå†æ¡†æ¶

https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/

```python
def dfs(x, y):
    if not inArea(x, y):
        return 
  
    if grid[x][y]!=1:
        return
  
    grid[x][y]=2
  
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    for ddx, ddy in zip(dx, dy):
        dfs(x+ddx, y+ddy)

def inArea(x, y):
    return -1<x<n and -1<y<m
```

### LeetCode 695. Max Area of Island

```python
def dfs(x, y):
    if not inArea(x, y):
        return 0
  
    if grid[x][y]!=1:
        return 0
  
    grid[x][y]=2
  
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    res = 1
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                area = dfs(i, j)
                res = max(res, area)
    return res
```

### LeetCode 827. Making A Large Island ï¼ˆHardï¼‰

```python
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
def dfs(x, y, index):
    if not inArea(x, y):
        return 0
  
    if grid[x][y]!=1:
        return 0
  
    grid[x][y]=index
  
    res = 1
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    area = {0:0}
    index = 2
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                area[index] = dfs(i, j, index)
                index += 1
  
    res = max(area.values())
    for i in rang(n):
        for j in range(m):
            if grid[i][j]==0:
                seen = {grid[i+ddx][j+ddy] for ddx, ddy in zip(dx, dy)}
                res = max(res, 1+sum(area[index] for index in seen))
  
    return res
```

### LeetCode 463. Island Perimeter

å²›å±¿çš„è¾¹æœ‰ä¸¤ç§ï¼šç¬¬ä¸€ç§æ˜¯è·¨å‡ºåŒºåŸŸå‡ºç°çš„å‘¨é•¿ï¼›ç¬¬äºŒç§æ˜¯è¿›å…¥æ°´åŒºåŸŸå‡ºç°çš„å‘¨é•¿

```python
def dfs(x, y):
    if not inArea(x, y):
        return 1
  
    if gridp[x][y]==0:
        return 1
  
    if grid[x][y]!=1:
        return 0
  
    grid[x][y]=2
  
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    res = 0
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                per = dfs(i, j)
                res = max(res, per)
    return res
```

### 200. å²›å±¿æ•°é‡

```python
def dfs(x, y):
    if not inArea(x, y):
        return 0
  
    if grid[x][y]!=1:
        return 0
  
    grid[x][y]=2
  
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    for ddx, ddy in zip(dx, dy):
        dfs(x+ddx, y+ddy)
    return 0

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                dfs(i, j)
                res += 1
    return res
```

## 201. æ•°å­—èŒƒå›´æŒ‰ä½ä¸

è§£æ³•1ï¼šæ•°å­—nå’Œmçš„å…¬å…±å‰ç¼€[m, n]

è¯æ˜ï¼šm = ...0..., n=...1...ï¼Œæ˜¾ç„¶æœ‰ï¼šå‰é¢çš„å…¬å…±å‰ç¼€æŒ‰ä½ä¸ä¸ä¼šå‘ç”Ÿæ”¹å˜ï¼Œåç¼€ä¸€å®šä¼šå‡ºç°1000ï¼ŒæŒ‰ä½ä¸ä¹‹åå…¨ä¸º0

```python
def main(m, n):
    i = 0
    while m!=n:
        m = m>>1
        n = n>>1
        i+=1
    return m<<i
```

è§£æ³•2ï¼šBrian Kernighan:x & (x-1) å»æ‰æœ€åä¸€ä¸ª1ï¼Œå¯ä»¥ç”¨äºè®¡ç®—æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°

```python
def main(m, n):
    while m<n:
        n = n&(n-1)
    return n
```

## 207. è¯¾ç¨‹è¡¨

å›¾ä¸­æœ‰æ²¡æœ‰ç¯ æ‹“æ‰‘æ’åº

è§£æ³•ä¸€ï¼šbfsï¼Œä»å…¥åº¦ä¸º0çš„èŠ‚ç‚¹å¼€å§‹

æ„å»ºå…¥åº¦åˆ—è¡¨å’Œé‚»æ¥è¡¨

```python
from collections import deque
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
    
        indegrees = [0]*numCourses
        adjacency = [[] for _ in range(numCourses)]

        for cur, pre in prerequisites:
            indegrees[cur] += 1
            adjacency[pre].append(cur)
    
        que = deque()
        for i, val in enumerate(indegrees):
            if not val:
                que.append(i)
        num_c = 0
        while que:
            # print(que)
            num_c+=1
            pre = que.popleft()
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]:
                    que.append(cur)
        return num_c == numCourses
```

è§£æ³•äºŒï¼šdfsï¼Œä»ä»»ä¸€èŠ‚ç‚¹éå†

æ„å»ºé‚»æ¥è¡¨å’Œæ ‡å¿—åˆ—è¡¨

flagsğŸ‘å·²ç»éå†è¿‡ï¼Œæ— é¡»å†æ¬¡éå†ï¼›0ï¼šè¿˜æ²¡æœ‰éå†ï¼›1ï¼šæ­£åœ¨éå†

ç¯ï¼šdfsæ—¶å‡ºç°æ­£åœ¨éå†çš„ç‚¹

```python
from collections import deque
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
    
        def dfs(val):
            if flags[val]==1:
                return False
            if flags[val]==-1:
                return True
            flags[val]=1
            for nex in adjacency[val]:
                if not dfs(nex):
                    return False
            flags[val]=-1
            return True

        adjacency = [[] for _ in range(numCourses)]
        flags = [0]*numCourses
        for cur, pre in prerequisites:
            adjacency[pre].append(cur)
    
        for val in range(numCourses):
            if not dfs(val):
                return False

        return True        
```

## 210. è¯¾ç¨‹è¡¨ II

dfs: åœ¨å›æœ”æ—¶å°†è¯¾ç¨‹åŠ å…¥æ ˆä¸­ï¼Œæ­¤æ—¶æ ˆé¡¶è¯¾ç¨‹å…ˆäºæ ˆåº•è¯¾ç¨‹å®Œæˆ

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        adajency = [[] for _ in range(numCourses)]
        flag = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adajency[pre].append(cur)
        res = []
        self.Circle = False
    
        def dfs(index):
            if flag[index]==-1:
                return 
            if flag[index]==1:
                self.Circle = True
                return 
        
            flag[index] = 1
            for val in adajency[index]:
                dfs(val)
            flag[index] = -1
            res.append(index)
    
        for val in range(numCourses):
            if (not self.Circle) and flag[val]==0:
                dfs(val)

        if self.Circle:
            return []
        else:
            return res[::-1]
```

bfs:

```python
from collections import deque
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        adajency = [[] for _ in range(numCourses)]
        indegree = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adajency[pre].append(cur)
            indegree[cur] += 1
        res = []
        que = deque()
        for val in range(numCourses):
            if indegree[val]==0:
                que.append(val)
        while que:
            index = que.popleft()
            for val in adajency[index]:
                indegree[val] -= 1
                if indegree[val]==0:
                    que.append(val)
            res.append(index)
        if len(res)!=numCourses:
            return list()
        else:
            return res
```

## 208. å®ç° Trie (å‰ç¼€æ ‘)

å‰ç¼€æ ‘ï¼šç»“ç‚¹æ²¡æœ‰å€¼ï¼Œè¾¹æœ‰å€¼ï¼ŒåŒæ—¶æ¯ä¸ªç»“ç‚¹éœ€è¦wordè¡¨ç¤ºæ˜¯å¦æ˜¯å•è¯

```python
# åªæ¶‰åŠ insert, search, startwithçš„å‰ç¼€æ ‘
from collections import defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.word = False

class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()



    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]

        cur.word = True

    def searchpre(self, word):
        cur = self.root
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        cur = self.searchpre(word)
    
        return cur and cur.word

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        return cur!=False
```

```python
# æ¶‰åŠ insert, search, startwith, deleteçš„å‰ç¼€æ ‘

from collections import defaultdict

class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.path = 0 # è¡¨ç¤ºç»è¿‡å½“å‰ç»“ç‚¹çš„å•è¯ä¸ªæ•°
        self.word = 0 # è¡¨ç¤ºå½“å‰ç»“ç‚¹ä¸ºå•è¯ç»“å°¾çš„ä¸ªæ•°

class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]
            cur.path += 1
        cur.word += 1

    def searchpre(self, word):
        cur = self.root
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        cur = self.searchpre(word)
    
        return cur and cur.word

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        return cur!=False
  
    def delete(self, word):
        # å‡è®¾å•è¯ä¸€å®šå‡ºç°åœ¨å‰ç¼€æ ‘ä¸­
        cur = self.root
        for w in word:
            tmp = cur.children[w]
            if cur.children[w].path==1:
                cur.children.pop(w)
            cur = tmp
            cur.path -= 1
        cur.word -= 1

```

## 211. æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡

å‰ç¼€æ ‘

```python
from collections import defaultdict
class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.word = False

class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TreeNode()


    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]
        cur.word = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """
        cur = self.root
        res = self.search2(word, 0, cur)
        return res

  
    def search2(self, word, index, cur):

        if index==len(word):
            return cur.word
        res = False
        if word[index]==".":
            for child in cur.children.values():
                res = res or self.search2(word, index+1, child)
            return res
    
        if word[index] in cur.children:
            return self.search2(word, index+1, cur.children[word[index]])
        return False


# è§£æ³•2ï¼š
import re
class WordDictionary:

    def __init__(self):
        self.words = '#'
  
    def addWord(self, word):
        self.words += word + '#'

    def search(self, word):
        return bool(re.search('#' + word + '#', self.words))
```

### 212. å•è¯æœç´¢ II

å‰ç¼€æ ‘

```python
from collections import defaultdict
class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.word = None
dx = [0,1,0,-1]
dy = [1,0,-1,0]
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        self.root = TreeNode()
        self.build(words)
        self.n, self.m = len(board), len(board[0])
        self.res = list()
        for i in range(self.n):
            for j in range(self.m):
                self.findWords2(board, i, j, self.root)
        return self.res

    def build(self, words):

        def insert(word):
            cur = self.root
            for w in word:
                cur = cur.children[w]
            cur.word = word
    
        for word in words:
            insert(word)
    
        return
  
    def findWords2(self, board, i, j, parent):
        if not self.inArea(i, j):
            return False   
           
        w = board[i][j]
        if w not in parent.children.keys():
            return False

        cur = parent.children[w]
        print(i, j, w)
        if cur.word:
            self.res.append(cur.word)
            cur.word = None

        board[i][j] = '#'
        for ddx, ddy in zip(dx, dy):
            self.findWords2(board, i+ddx, j+ddy, cur)
        board[i][j] = w
        # ä¼˜åŒ–ï¼šå¦‚æœåˆ°äº†å¶å­ç»“ç‚¹ï¼Œåˆ™è¯¥ç»“ç‚¹ä¸€å®šå·²ç»åŠ å…¥ç»“æœä¸­ï¼Œå¹¶ä¸”ä»¥åæ— é¡»å†æ¬¡è®¿é—®è¯¥ç»“ç‚¹ï¼Œå¯ä»¥åˆ é™¤å¶å­ç»“ç‚¹
        if not cur.children:
            parent.children.pop(w)
  
    def inArea(self, i, j):
        return -1<i<self.n and -1<j<self.m
```

## 213. æ‰“å®¶åŠ«èˆ II

dp[n] = max(dp[n-1], dp[n-2]+nums[n])

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        f = [[0, 0] for _ in range(n+1)]
        f[1][1] = nums[0]
        g = [[0, 0] for _ in range(n+1)]
        for i in range(2, n+1):
            f[i][0] = max(f[i-1][1], f[i-1][0])
            f[i][1] = f[i-1][0]+nums[i-1]
            g[i][0] = max(g[i-1][1], g[i-1][0])
            g[i][1] = g[i-1][0]+nums[i-1]
        if n == 1:
            res = max(f[-1][0], f[-1][1])
        else:
            res = max(f[-1][0], g[-1][1])
        return res
    
class Solution:
    def rob(self, nums: [int]) -> int:
        def my_rob(nums):
            cur, pre = 0, 0
            for num in nums:
                cur, pre = max(pre + num, cur), cur
            return cur
        return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0]

```

## 214. æœ€çŸ­å›æ–‡ä¸²

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œä½ å¯ä»¥é€šè¿‡åœ¨å­—ç¬¦ä¸²å‰é¢æ·»åŠ å­—ç¬¦å°†å…¶è½¬æ¢ä¸ºå›æ–‡ä¸²ã€‚æ‰¾åˆ°å¹¶è¿”å›å¯ä»¥ç”¨è¿™ç§æ–¹å¼è½¬æ¢çš„æœ€çŸ­å›æ–‡ä¸²ã€‚

ç¬¬ä¸€æ­¥ï¼šè¯æ˜ å¯ä»¥ä»å­—ç¬¦ä¸²å¼€å¤´æ‰¾åˆ°æœ€å¤§çš„å›æ–‡å­ä¸²ï¼Œç„¶ååè½¬å‰©ä½™çš„å­ä¸²å¹¶é™„åŠ åˆ°å¼€å¤´

åè¯æ³•ï¼šå¦‚æœä¸æ˜¯ï¼Œæœ‰æ›´çŸ­çš„å›æ–‡ä¸²æ‹¼æ¥ã€‚æ ¹æ®æ‹¼æ¥åçš„å›æ–‡ä¸²ï¼Œå¯ä»¥å¾—åˆ°æ›´é•¿çš„å­—ç¬¦ä¸²å¼€å¤´çš„æœ€å¤§çš„å›æ–‡å­ä¸²ï¼ŒçŸ›ç›¾ã€‚

ç¬¬äºŒæ­¥ï¼šKMPæ‰¾æœ€å¤§åè½¬å›æ–‡å­ä¸²ã€‚

å°†åŸå­—ç¬¦ä¸²s="abbad"åè½¬ rev="dabba"ï¼Œæ‰¾så’Œrevçš„ç›¸åŒå­ä¸² s[: n-i]=rev[ i:]
æˆ–è€…è¯´ï¼Œæˆ‘ä»¬éœ€è¦æ¯”è¾ƒå‰ç¼€{abbad, abba, abb, ab, a}å’Œåç¼€{dabba, abba, bba, ba, a}çš„æœ€å¤§åŒ¹é…ï¼Œæ˜¾ç„¶æ˜¯KMP

â€œ#â€é˜²æ­¢"aa"-"aaaa"çš„æƒ…å†µï¼Œä¿è¯å‰ç¼€ä¸€å®šå‡ºç°åœ¨å­—ç¬¦ä¸²sä¸­

```python
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        ss = s+"#"+s[::-1]
        def getnext(s):
            n = len(s)
            nex = [0]*(n+1)
            nex[0]=-1
            i, j =0, -1
            while i<n:
                if j==-1 or s[i]==s[j]:
                    i, j = i+1, j+1
                    nex[i]=j
                else:
                    j = nex[j]
            return nex[-1]
        pos = getnext(ss)
        # print(pos)
        res = s[-1:pos-1:-1]+s
        return res
```

## ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 

å°é¡¶å †  å¿«é€Ÿé€‰æ‹©

## 220 å­˜åœ¨é‡å¤å…ƒç´ III

åœ¨æ•´æ•°æ•°ç»„ nums ä¸­ï¼Œæ˜¯å¦å­˜åœ¨ä¸¤ä¸ªä¸‹æ ‡ i å’Œ jï¼Œä½¿å¾—Â nums [i] å’ŒÂ nums [j]Â çš„å·®çš„ç»å¯¹å€¼å°äºç­‰äº t ï¼Œä¸”æ»¡è¶³ i å’Œ j çš„å·®çš„ç»å¯¹å€¼ä¹Ÿå°äºç­‰äº Ä· ã€‚

ä»¥t+1ä¸ºwå»ºç«‹æ¡¶ï¼Œé‚£ä¹ˆé—®é¢˜å¯ä»¥è½¬æ¢ä¸º å¯¹äºxæ‰€åœ¨çš„æ¡¶indexï¼Œå¦‚æœå‘ç”Ÿä¸‰ç§æƒ…å½¢ä¹‹ä¸€ï¼Œåˆ™å­˜åœ¨ï¼š

1. indexå·²ç»æœ‰å€¼
2. index-1æœ‰å€¼ä¸”å·®å°äºç­‰äºt
3. index+1æœ‰å€¼ä¸”å·®å°äºç­‰äºt

æ˜¾ç„¶éç›¸é‚»æ¡¶çš„å·®å¤§äºt

æˆ–è€…è¯´æ¡¶æ’åºä½¿å¾—æ¡¶å†…å·®è·å°äºtï¼Œç›¸é‚»æ¡¶å·®è·å°äº[0, 2t]ï¼Œéš”ä¸€ä¸ªæ¡¶çš„å·®è·[t, 3t]ï¼Œéš”ä¸¤ä¸ªæ¡¶çš„å·®è·[2t, 4t]ï¼Œç¼©å‡äº†æ±‚å·®çš„èŒƒå›´ã€‚

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if not nums or t<0:
            return False
        delta = t+1
        min_val = min(nums)
        def getID(val):
            return (val-min_val)//delta
        hashmap = dict()
        for i, val in enumerate(nums):
            if i>k:
                index = getID(nums[i-k-1])
                hashmap.pop(index)        
            index = getID(val)
            if index in hashmap:
                # print(1, index, hashmap)
                return True
            if index-1 in hashmap and val-hashmap[index-1]<=t:
                # print(2, index, hashmap)
                return True
            if index+1 in hashmap and hashmap[index+1]-val<=t:
                # print(3, index, hashmap)
                return True
            hashmap[index]=val
            # print(hashmap)
        return False
```

## 222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

é€’å½’æ³•ï¼šåˆ†åˆ«æ±‚å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œå¦‚æœleftd==rightdï¼Œè¯´æ˜å·¦å­æ ‘æ˜¯æ»¡äºŒå‰æ ‘ï¼Œ2^leftdï¼Œå¦‚æœleftd!=rightdï¼Œè¯´æ˜å³å­æ ‘æ˜¯æ»¡äºŒå‰æ ‘ï¼Œ2^rightd

æ—¶é—´å¤æ‚åº¦ï¼šO(d)=O(lgn)

æ»¡äºŒå‰æ ‘çš„æ·±åº¦ä¸ºdï¼Œåˆ™ç»“ç‚¹ä¸ªæ•°ä¸º2^d-1

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(root):
            depth = 0
            while root:
                root = root.left
                depth += 1
            return depth
        
        leftdp = getDepth(root.left)
        rightdp = getDepth(root.right)
        if leftdp==rightdp:
            leftNodes = 1<<leftdp
            rightNodes = self.countNodes(root.right)
        else:
            leftNodes = self.countNodes(root.left)
            rightNodes = 1<<rightdp
        res = leftNodes+rightNodes
        return res

```

## 224. è®¡ç®—å™¨ + - * / ( )

### è§£æ³•ä¸€ï¼šå°†ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºåç¼€è¡¨è¾¾å¼ï¼Œç„¶ååˆ©ç”¨é€†æ³¢å…°æ•°è§£å†³ æ¨è

https://blog.csdn.net/sgbfblog/article/details/8001651

ä½¿ç”¨è¾…åŠ©æ ˆï¼Œå®šä¹‰ä¼˜å…ˆçº§ (:0, ):0, + -:1, * /:2ï¼Œä¿è¯è¾…åŠ©æ ˆä¸¥æ ¼å•è°ƒé€’å¢
æ¯é‡åˆ°ä¸€ä¸ªå·¦æ‹¬å·ï¼Œè¾…åŠ©æ ˆçš„åŸºæœ¬ä¼˜å…ˆçº§å°±+3ï¼Œ æ¯é‡åˆ°ä¸€ä¸ªå³æ‹¬å·ï¼Œè¾…åŠ©æ ˆçš„åŸºæœ¬ä¼˜å…ˆçº§å°±-3ï¼Œ
æ¯”å¦‚ + * ( + * ( + * ))ï¼ŒåŸºæœ¬ä¼˜å…ˆçº§åˆ†åˆ«æ˜¯ 0 0 3 3 3 6 6 6 6 3ï¼Œå®é™…ä¼˜å…ˆçº§=åŸºæœ¬ä¼˜å…ˆçº§+ç¬¦å·ä¼˜å…ˆçº§ï¼š1 2 3 4 5 6 7 8 6 3
è¿™æ˜¯å› ä¸ºé‡åˆ°+ - * /æ—¶ï¼Œè¾…åŠ©æ ˆåªéœ€è¦å¼¹å‡ºåˆ°+ - * /ä¸¥æ ¼å•è°ƒé€’å¢ä¸”å·¦æ‹¬å·ä¸ä¼šå¼¹å‡ºï¼Œä¸”é‡åˆ°å·¦æ‹¬å·æ—¶ç›´æ¥å‹å…¥è¾…åŠ©æ ˆã€‚æ‰€ä»¥é‡åˆ°å·¦æ‹¬å·æ—¶ï¼Œå·¦æ‹¬å·çš„ä¼˜å…ˆçº§å¤§äºå·²ç»å…¥æ ˆçš„ç¬¦å·ï¼Œä½†æ˜¯å°äºæœªå…¥æ ˆçš„ç¬¦å·+ - * /ï¼Œæ‰€ä»¥æå‡ºé‡åˆ°å·¦æ‹¬å·æ—¶æ ˆçš„åŸºæœ¬ä¼˜å…ˆçº§+3ï¼Œç„¶ååœ¨æ­¤åŸºç¡€ä¸Šè®¡ç®—æœªå…¥æ ˆçš„ç¬¦å·çš„ä¼˜å…ˆçº§ã€‚
å½“é‡åˆ°å³æ‹¬å·æ—¶ï¼Œè¾…åŠ©æ ˆéœ€è¦ä¸€ç›´å¼¹å‡ºï¼Œç›´åˆ°(ï¼Œå¹¶ä¸”å¼¹å‡ºä¹‹å( ä¹‹åè¾…åŠ©æ ˆçš„åŸºæœ¬ä¼˜å…ˆçº§éœ€è¦-3ï¼Œå¹¶ä¸”æ­¤æ—¶exp2çš„æœ«å°¾æ’å…¥äº†å·¦æ‹¬å·ï¼Œéœ€è¦å¼¹å‡ºã€‚

ä¸€ã€ å°†ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢æˆåç¼€è¡¨è¾¾å¼ç®—æ³•ï¼š
ã€€ã€€1ã€ä»å·¦è‡³å³æ‰«æä¸€ä¸­ç¼€è¡¨è¾¾å¼ã€‚
ã€€ã€€2ã€è‹¥è¯»å–çš„æ˜¯æ“ä½œæ•°ï¼Œåˆ™åˆ¤æ–­è¯¥æ“ä½œæ•°çš„ç±»å‹ï¼Œå¹¶å°†è¯¥æ“ä½œæ•°å­˜å…¥æ“ä½œæ•°å †æ ˆ
ã€€ã€€3ã€è‹¥è¯»å–çš„æ˜¯è¿ç®—ç¬¦
ã€€ã€€ã€€ã€€(1) è¯¥è¿ç®—ç¬¦ä¸ºå·¦æ‹¬å·"("ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€(2) è¯¥è¿ç®—ç¬¦ä¸ºå³æ‹¬å·")"ï¼Œåˆ™è¾“å‡ºè¿ç®—ç¬¦å †æ ˆä¸­çš„è¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å·ä¸ºæ­¢ã€‚
ã€€ã€€ã€€ã€€(3) è¯¥è¿ç®—ç¬¦ä¸ºéæ‹¬å·è¿ç®—ç¬¦ï¼š
ã€€ã€€ã€€ã€€ã€€ã€€(a) è‹¥è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¸ºæ‹¬å·ï¼ˆåªå¯èƒ½æ˜¯å·¦æ‹¬å·ï¼‰ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€ã€€ã€€(b) è‹¥æ¯”è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§é«˜ï¼Œåˆ™ç›´æ¥å­˜å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€ã€€ã€€ã€€ã€€(c) è‹¥æ¯”è¿ç®—ç¬¦å †æ ˆæ ˆé¡¶çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§ä½æˆ–ç›¸ç­‰ï¼Œåˆ™ä¸æ–­è¾“å‡ºæ ˆé¡¶è¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°æ ˆé¡¶æ²¡æœ‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å¤§äºæˆ–è€…ç­‰äºå½“å‰é¢„ç®—ç¬¦ï¼ˆå³æ ˆé¡¶å­˜åœ¨è¿ç®—ç¬¦çš„è¯ï¼Œä¼˜å…ˆçº§ä¸€å®šæ˜¯å°äºå½“å‰è¿ç®—ç¬¦ï¼‰ï¼Œæœ€åå°†å½“å‰è¿ç®—ç¬¦å‹å…¥è¿ç®—ç¬¦å †æ ˆã€‚
ã€€ã€€4ã€å½“è¡¨è¾¾å¼è¯»å–å®Œæˆåè¿ç®—ç¬¦å †æ ˆä¸­å°šæœ‰è¿ç®—ç¬¦æ—¶ï¼Œåˆ™ä¾åºå–å‡ºè¿ç®—ç¬¦åˆ°æ“ä½œæ•°å †æ ˆï¼Œç›´åˆ°è¿ç®—ç¬¦å †æ ˆä¸ºç©ºã€‚

äºŒã€é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç®—æ³•ï¼š
ã€€ã€€1ã€ä»å·¦åˆ°å³ä¾æ¬¡æ‰«æè¯­æ³•å•å…ƒçš„é¡¹ç›®ã€‚
ã€€ã€€2ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯æ“ä½œæ•°ï¼Œåˆ™å°†å…¶å‹å…¥æ“ä½œæ•°å †æ ˆï¼Œå¹¶æ‰«æä¸‹ä¸€ä¸ªé¡¹ç›®ã€‚
ã€€ã€€3ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„é¡¶ä¸Šä¸¤ä¸ªæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€4ã€å¦‚æœæ‰«æçš„é¡¹ç›®æ˜¯ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦ï¼Œåˆ™å¯¹æ ˆçš„æœ€é¡¶ä¸Šæ“ä½œæ•°æ‰§è¡Œè¯¥è¿ç®—ã€‚
ã€€ã€€5ã€å°†è¿ç®—ç»“æœé‡æ–°å‹å…¥å †æ ˆã€‚
ã€€ã€€6ã€é‡å¤æ­¥éª¤2-5ï¼Œå †æ ˆä¸­å³ä¸ºç»“æœå€¼ã€‚

é€†æ³¢å…°æ±‚è§£ï¼šå¦‚æœå½“å‰å­—ç¬¦ä¸ºå˜é‡æˆ–è€…ä¸ºæ•°å­—ï¼Œåˆ™å‹æ ˆï¼Œå¦‚æœæ˜¯è¿ç®—ç¬¦ï¼Œåˆ™å°†æ ˆé¡¶ä¸¤ä¸ªå…ƒç´ å¼¹å‡ºä½œç›¸åº”è¿ç®—ï¼Œç»“æœå†å…¥æ ˆï¼Œæœ€åå½“è¡¨è¾¾å¼æ‰«æå®Œåï¼Œæ ˆé‡Œçš„å°±æ˜¯ç»“æœã€‚

```python
def ToSuffixExpression(exp1):
    exp2 = list()
    stack = list()
    pri = {"+":1, "-":1, "*":2, "/":2, "(":0, ")":0}
    base = 0
    delta_base = 3
    for val in exp1:
        print("val", val)
        if val.isdigit():
            exp2.append(val)
        else:
            if val == "(":
                base+=delta_base
            pri_val = base+pri[val]
            while stack and pri_val<=stack[-1][1]:
                exp2.append(stack.pop()[0])
            stack.append((val, pri_val))
            if val in [")"]:
                exp2.pop()
                stack.pop()
                base-=delta_base
        print("exp2", exp2)
        print("stack", stack)
    while stack:
        exp2.append(stack.pop()[0])
    print(exp2)
    return exp2
```

### è§£æ³•äºŒï¼šåŒæ ˆ æ¨è é€šç”¨

stack_dig ä¿å­˜æ•°å­—ï¼Œ stack_op ä¿å­˜æ“ä½œç¬¦
å·¦æ‹¬å·ä¼˜å…ˆçº§+3ï¼Œå³æ‹¬å·ä¼˜å…ˆçº§-3
stack_op æ“ä½œç¬¦ä¼˜å…ˆçº§ä¸¥æ ¼å•è°ƒé€’å¢

```python
class Solution:
    def calculate(self, s: str) -> int:
        s = "(" + s + ")"
        n = len(s)
        stack_dig = []
        stack_op = []
        pri = {"(":0, ")":0, "+":1, "-":1, "*":2, "/":2}
        base, base_pri = 0, 3
        dig_cur, dig_flag = 0, False
        for val in s:
            if val.isdigit():
                dig_cur = dig_cur*10+int(val)
                dig_flag = True
            elif val!=" ":
                if dig_flag:
                    stack_dig.append(dig_cur)
                    dig_cur, dig_flag = 0, False
                if val=="(":
                    base = base+base_pri
                pri_val = base+pri[val]
                while stack_op and pri_val<=stack_op[-1][1]:
                    self.eval_expr(stack_dig, stack_op)
                stack_op.append((val, pri_val))
                if val==")":
                    stack_op.pop()
                    base = base-base_pri 
                # print("dig:", stack_dig, "op:", stack_op)
        return stack_dig[-1]
  
    def eval_expr(self, stack_dig, stack_op):
        op = stack_op.pop()[0]
        if op=="(":
            return
        num2 = stack_dig.pop()
        num1 = stack_dig.pop()

        if op=="+":
            res = num1+num2
        elif op=="-":
            res = num1-num2
        stack_dig.append(res)
        return 
```

### è§£æ³•ä¸‰ï¼šæ‹¬å·ç”¨é€’å½’ æ¨è

å·¦å³æ‹¬å·è¿›é€’å½’ï¼ŒåŠ å‡å…¥æ ˆï¼Œä¹˜é™¤è®¡ç®—

```python
from collections import deque
def calculate(s):
    s = deque(s)
    def helper(s):

        stack = []
        sign = "+"
        num = 0
        while len(s)>0:
            c = s.popleft()
            if c.isdigit():
                num = 10*num+int(c)
            if c=="(":
                num = helper(s)
            if c in ["+", "-", "*", "/"] or len(s)==0:
                if sign == "+":
                    stack.append(num)
                if sign == "-":
                    stack.append(-num)
                if sign == "*":
                    pre = stack.pop()
                    stack.append(pre*num)
                if sign == "/":
                    pre = stack.pop()
                    stack.append(pre//num)
                num, sign = 0, c
            if c==")":
                break
        return sum(stack)
    return helper(s)
```

## ç»™å®šä¸€ä¸ªå¤§å°ä¸º n çš„æ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­æ‰€æœ‰å‡ºç°è¶…è¿‡ âŒŠ n/m âŒ‹ æ¬¡çš„å…ƒç´ ã€‚

æ‘©å°”æŠ•ç¥¨æ³•

è¯æ˜ï¼šè€ƒè™‘m=3ã€‚å‡è®¾hashmapå‰©ä¸‹2ä¸ªå€™é€‰æ•°å­—ï¼Œcand1ï¼šk1, cand2ï¼šk2, å…¶ä½™æ•°å­—æ»¡è¶³ æ¯ä¸‰ä¸ªä¸åŒçš„æ•°å­—æˆä¸€å¯¹ã€‚å¯¹äºä¸åŒäºcand1ï¼Œcand2çš„æ•°å­—xï¼Œåˆ™xçš„æ¬¡æ•°æœ€å¤šä¸º(n-k1-k2)//3<= n //3ã€‚å‡è®¾hashmapå‰©ä¸‹1ä¸ªå€™é€‰æ•°å­—ï¼Œcand1ï¼šk1ï¼Œå…¶ä½™æ•°å­—æ»¡è¶³ æ¯ä¸‰ä¸ªä¸åŒçš„æ•°å­—æˆä¸€å¯¹ã€‚å¯¹äºä¸åŒäºcand1çš„æ•°å­—xï¼Œåˆ™xçš„æ¬¡æ•°æœ€å¤šä¸º(n-k1)//3<= n //3ã€‚

```python
from collections import defaultdict
class Solution:
    def majorityElement(self, nums: List[int], m) -> List[int]:
        hashmap = defaultdict(int)
        n = len(nums)
        for val in nums:
            print(hashmap)
            if val in hashmap:
                hashmap[val] = hashmap[val]+1
            elif len(hashmap)<m:
                hashmap[val] = 1
            else:
                for k, v in hashmap.copy().items():
                    hashmap[k] -= 1
                    if hashmap[k] == 0:
                        hashmap.pop(k)
        hashmap2 = defaultdict(int)
        for val in nums:
            if val in hashmap:
                hashmap2[val] += 1
        res = []
        for k, v in hashmap2.items():
            if v>n//m:
                res.append(k)
        print(hashmap, hashmap2)
        return res
```

## 233. æ•°å­— 1 çš„ä¸ªæ•°

å°†æ•°å­—nåˆ†ä¸ºï¼Œabcï¼Œæ¯”å¦‚234ï¼Œa=2ï¼Œ b=3ï¼Œc=4

å½“b=0æ—¶ï¼Œ204, bä½ä¸Š1çš„ä¸ªæ•°ï¼š010-019ï¼Œ110-119, =a*10
b=1æ—¶ï¼Œ214ï¼Œbä½ä¸Š1çš„ä¸ªæ•°ï¼š010-019ï¼Œ110-119, 210-214 =a*10+c+1
b=2-9æ—¶ï¼Œ234ï¼Œbä½ä¸Š1çš„ä¸ªæ•°ï¼š010-019ï¼Œ110-119, 210-219ï¼Œ=a*10+10

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        res = 0
        base = 1
        while base<=n:
            a, b, c = (n//base)//10, (n//base)%10, n%base
            if b==0:
                res+=a*base
            elif b==1:
                res+=a*base+c+1
            else:
                res+=(a+1)*base
            base = base*10
        return res
```

## 236 äºŒå‰æ ‘çš„ä¸¤ä¸ªç»“ç‚¹çš„æœ€ä½å…¬å…±ç¥–å…ˆ

https://zhuanlan.zhihu.com/p/43681377

æœ€ä½å…¬å…±ç¥–å…ˆLCAï¼šå¦‚æœæœ‰ä¸¤ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆæ±‚æœ€ä½å…¬å…±ç¥–å…ˆï¼Œå¦‚æœåªå‡ºç°äº†ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆæ±‚è¯¥ç»“ç‚¹

å®šä¹‰f(root):è¿”å›ä»¥rootä¸ºæ ¹ç»“ç‚¹çš„æ ‘çš„æœ€ä½å…¬å…±ç¥–å…ˆLCA

f(root) = (root.val==p or root.val==q) or (f_left and f_right)

å¦‚æœroot.val==pæˆ–è€…qï¼Œåˆ™rootä¸ºLCA
å¦‚æœf_leftæˆ–è€…f_rightéƒ½ä¸æ˜¯LCAï¼Œåˆ™rootä¸æ˜¯LCA
å¦‚æœf_leftæˆ–è€…f_rightåªæœ‰ä¸€ä¸ªæ˜¯LCAï¼Œåˆ™f(root)=f_left or f_right
å¦‚æœf_leftå’Œf_right éƒ½æ˜¯LCAï¼Œåˆ™rootä¹Ÿæ˜¯LCAï¼Œ

```python
def demo1(root, a1, a2):
    if not root:
        return None
    if root.val==a.val or root.val==b.val:
        return root
    left_lca = demo1(root.left, a1, a2)
    right_lca = demo1(root.right, a1, a2)
    if left_lca and right_lca:
        return root
    return left_lca or right_lca
```

## 239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼

è§£æ³•ä¸€ï¼šå•è°ƒé€’å‡åŒå‘é˜Ÿåˆ—

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        que = deque()
        res = []
        for i, val in enumerate(nums):
            while que and i-que[0]>=k:
                que.popleft()
            while que and val>nums[que[-1]]:
                que.pop()
            que.append(i)
            res.append(nums[que[0]])
        return res[k-1:]
```

è§£æ³•äºŒï¼š åŠ¨æ€è§„åˆ’

https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/

ä»¥k=3ï¼Œnums=[1,2,3,4,5,6,7]ä¸ºä¾‹ï¼Œå°†numsæŒ‰ç…§kä¸ªä¸€ç»„åˆ†åˆ«åˆ’åˆ†ä¸º [1,2,3][4,5,6][7]
åŒæ—¶æ±‚left[i]:æ¯å—å¼€å§‹åˆ°içš„æœ€å¤§å€¼ï¼Œright[j]ï¼šæ¯å—ç»“å°¾åˆ°içš„æœ€å¤§å€¼
å¯¹äºåœ¨åŒä¸€ä¸ªå—[ 1 2 3 ]çš„å…ƒç´ i=0, j=2ï¼Œæ»‘åŠ¨çª—å£æœ€å¤§å€¼ä¸º left[j]=max(right[i], left[j])
å¯¹äºåœ¨ç›¸é‚»å—å—0å—1 [2,3,4]çš„å…ƒç´ i=1ï¼Œj=3ï¼Œæ»‘åŠ¨çª—å£æœ€å¤§å€¼ä¸º max(right[i], left[j]): å—0ç»“å°¾åˆ°içš„æœ€å¤§å€¼ï¼Œå—1å¼€å§‹åˆ°jçš„æœ€å¤§å€¼

è¿™ä¸ªå’Œ æ•°ç»„æ’åºä¹‹åç›¸é‚»æ•°çš„æœ€å¤§å·®å€¼ã€å­˜åœ¨é‡å¤å…ƒç´ III(è·ç¦»å°äºç­‰äºkçš„ç›¸é‚»æ•°å­—çš„æœ€å¤§å·®å°äºç­‰äºt)æœ‰å¼‚æ›²åŒå·¥ä¹‹å¤„ã€‚
æš‚æ—¶æ²¡æœ‰æ›´å¥½çš„è§£é‡Š

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        left = [0 for _ in range(n)]
        left[0] = nums[0]
        right = [0 for _ in range(n)]
        right[-1] = nums[-1]
        for i in range(n):
            if i%k==0:
                left[i] = nums[i]
            else:
                left[i] = max(left[i-1], nums[i])
            j = n-1-i
            if (j+1)%k==0 or j+1==n:
                right[j] = nums[j]
            else:
                right[j] = max(right[j+1], nums[j])
        res = []
        for j in range(k-1, n):
            i = j-(k-1)
            res.append(max(right[i], left[j]))
        return res
```

## 241. ä¸ºè¿ç®—è¡¨è¾¾å¼è®¾è®¡ä¼˜å…ˆçº§

https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/c-fen-zhi-dong-tai-gui-hua-by-xing-chen-da-hai-36/

é¦–å…ˆå°†å­—ç¬¦ä¸²åˆ†è§£ä¸ºæ•°å­—numså’Œæ“ä½œç¬¦ops
dp[i][j]è¡¨ç¤ºä»ç¬¬iä¸ªæ•°å­—åˆ°ç¬¬jä¸ªæ•°å­—çš„æ‰€æœ‰æƒ…å†µ
ï¼ˆ1ï¼‰i==j
ç­‰äºæ•°å­—æœ¬èº«çš„å€¼
ï¼ˆ2ï¼‰i!=j(jè‚¯å®šæ˜¯å¤§äºiçš„)
å°†i-jåˆ†æˆä¸¤ä¸ªå¼å­æ¥çœ‹ï¼Œ[i,i]op[i+1,j],[i,i+1]op[i+2,j]...[i,j-1]op[j,j]
dp[i][j] = dp[i][m]ops[m]dp[m+1][j], m=i,...,j-1ï¼Œå…¶ä¸­dp[i][j]æ˜¯åˆ—è¡¨ï¼Œä¸æ˜¯æ•°å­—

```python
class Solution:
    def diffWaysToCompute(self, input: str):
        ops = []
        nums = []
        num = 0
        for val in input:
            if self.isOP(val):
                ops.append(val)
                nums.append(num)
                num = 0
            else:
                num = num*10+int(val)
        nums.append(num)
        n = len(nums)
    
        dp = [[list() for _ in range(n)] for _ in range(n)]
        for i in range(n):
            dp[i][i] = [nums[i]]
        # print("first", dp)

        for k in range(1, n):
            for i in range(0, n-k):
                j = k+i
                self.calculate_dp(i, j, dp, ops)
                # print("se", dp)
        return dp[0][-1]

    def calculate_dp(self, i, j, dp, ops):
        for m in range(i, j):
            for left in dp[i][m]:
                for right in dp[m+1][j]:
                    dp[i][j].append(self.calculate(left, ops[m],right))

                
    def calculate(self, num1, op, num2):
        if op=="+":
            return num1+num2
        elif op=="-":
            return num1-num2
        elif op=="*":
            return num1*num2

    def isOP(self, val):
        return val in ["+", "-", "*"]
```

## ä¸­å¿ƒå¯¹ç§°æ•°

### 246 ä¸­å¿ƒå¯¹ç§°æ•°I

ä¸­å¿ƒå¯¹ç§°æ•°æ˜¯æŒ‡ä¸€ä¸ªæ•°å­—åœ¨æ—‹è½¬äº†180 åº¦ä¹‹åçœ‹èµ·æ¥ä¾æ—§ç›¸åŒçš„æ•°å­—

æ¯”å¦‚96ï¼Œ88ï¼Œ

```python
def demo1(nums:int):
    nums = str(nums)
    map = {0:0, 1:1, 2:-, 3:-, 4:-, 5:-, 6:9, 7:-, 8:8, 9:6}
    n = len(nums)
    for i, val in enumerate(nums):
        if map[val]=="-" or map[val]!==nums[n-1-i]:
            return False
    return True    
```

### 247 ä¸­å¿ƒå¯¹ç§°æ•°II

æ‰¾åˆ°æ‰€æœ‰é•¿åº¦ä¸º n çš„ä¸­å¿ƒå¯¹ç§°æ•°ã€‚

æ€è·¯ä¸€ï¼š
å¯¹äº n æ˜¯å¥‡æ•°çš„è§£æ¥è¯´ï¼Œ
åªè¦åœ¨ n - 1çš„è§£çš„æ¯ä¸ªæ•°ä¸­é—´ åŠ ä¸Š 0 æˆ– 1 æˆ– 8 å°±å¯ä»¥å¾—åˆ° n çš„è§£ã€‚
å¯¹äº n æ˜¯å¶æ•°çš„è§£æ¥è¯´ï¼Œ
åªè¦åœ¨ n - 2 çš„è§£çš„æ¯ä¸ªæ•°ä¸­é—´åŠ ä¸Š 00 ï¼Œ 11ï¼Œ 88ï¼Œ 69ï¼Œ 96å°±å¯ä»¥å¾—åˆ°n çš„è§£ã€‚

```python
def demo2(n: int):
    res = [[], ["0", "1", "8"], ["11", "88", "96", "69"]]
    if n<=2:
        return res[n]
    pair = [[], ["0", "1", "8"], ["00", "11", "88", "96", "69"]]
    for i in range(3, n+1):
        j = 2-i%2
        for val1 in res[i-j]:
            for val2 in pair[j]:
                res.append(val1[:i//2]+val2+val1[i//2:])
    return res[-1]
```

æ€è·¯äºŒï¼š
f(n) = f(n-2)+["00", "11", "88", "96", "69"] åœ¨ä¸¤ç«¯åˆ†åˆ«åŠ ä¸Š["00", "11", "88", "96", "69"],ä¸”å¯¹äºnï¼Œä¸¤ç«¯ä¸èƒ½åŠ 00ï¼Œ

n=0: ""
n=1: "0", "1", "8"
n=2: "00", "11", "88", "96", "69"

```python
def demo2(n: int):

    def helper(m:int):
        if m==0:
            return [""]
        if m==1:
            return ["0", "1", "8"]
        pre = helper(m-2)
        res = []
        for val in pre:
            if m!=n:
                res.append("0"+val+"0")
            for first, final in ["11", "88", "96", "69"]
                res.append(first+val+final)
        return res
    res = helper(n)
    return res        
```

### 248 ä¸­å¿ƒå¯¹ç§°æ•°III

æ±‚[low, high]ä¹‹é—´çš„ä¸­å¿ƒå¯¹ç§°æ•°çš„ä¸ªæ•°

æ€è·¯ä¸€ï¼š

å…ˆè°ƒä¸€ä¸‹247. ä¸­å¿ƒå¯¹ç§°æ•° IIçš„ç­”æ¡ˆï¼Œå¾—åˆ°ä» é•¿åº¦åœ¨ã€0ï¼Œlen(high)ã€‘ ä¹‹é—´çš„æ‰€æœ‰ä¸­å¿ƒå¯¹ç§°æ•°ï¼Œ å¹¶æŒ‰é•¿åº¦åˆ†å¥½ç±»ã€‚
ç„¶åé—®é¢˜å°±å˜æˆäº†ï¼Œåœ¨é•¿åº¦ä¸º len(low)çš„æ‰€æœ‰ä¸­å¿ƒå¯¹ç§°æ•°é‡Œï¼Œæ¯” low å¤§çš„æœ‰å‡ ä¸ªï¼Ÿåœ¨é•¿åº¦ä¸º len(high)çš„æ‰€æœ‰ä¸­å¿ƒå¯¹ç§°æ•°é‡Œï¼Œæ¯” high å°çš„æœ‰å‡ ä¸ªï¼Ÿè¿™ä¿©é—®é¢˜ç”¨äºŒåˆ†æŸ¥æ‰¾å°±å¯ä»¥è§£å†³ï¼Œç„¶åå†æ ¹æ® len(low) å’Œ len(highï¼‰é•¿åº¦çš„å…³ç³»è¿”å›è¾“å‡ºå³å¯ã€‚

```python

class Solution(object):
    def strobogrammaticInRange(self, low, high):
        """
        :type low: str
        :type high: str
        :rtype: int
        """
        if int(low) > int(high):
            return 0
        self.findStrobogrammatic(len(high)) 
    
        #æ‰¾åœ¨low_recé‡Œæœ‰å¤šå°‘ä¸ªæ•° >= lowï¼Œç»“æœæ”¾åœ¨low_cnté‡Œ
        #è¿™é‡Œç›¸å½“äºåœ¨æ‰¾å·¦ä¾§è¾¹ç•Œ
        low_rec = self.record[len(low)]
        low_cnt = len(low_rec) - bisect.bisect_left(low_rec, low)
    
        #æ‰¾åœ¨hige_recé‡Œæœ‰å¤šå°‘ä¸ªæ•°<= high, ç»“æœæ”¾åœ¨high_cnté‡Œ
        #è¿™é‡Œç›¸å½“äºåœ¨æ‰¾å³ä¾§è¾¹ç•Œ
        high_rec = self.record[len(high)]
        high_cnt = bisect.bisect_right(high_rec, high)
 
        if len(low) + 1 == len(high): #å¦‚æœç›¸é‚»çš„é•¿åº¦ï¼Œåˆ™ç›´æ¥ç›¸åŠ 
            return low_cnt + high_cnt
        elif len(low) == len(high): #å¦‚æœé•¿åº¦ç›¸åŒï¼Œé‚£ä¹ˆå‡å»é‡å¤è®¡ç®—çš„éƒ¨åˆ†
            return low_cnt + high_cnt - len(high_rec)
        else: #å¦‚æœç›¸éš”è¶…è¿‡1ï¼Œåˆ™ç›¸åŠ ä¹‹åå†åŠ ä¸Šæ‰€æœ‰ä¸­é—´ç»“æœçš„é•¿åº¦ä¹‹å’Œ
            tmp = 0
            for l in range(len(low) + 1, len(high)):
                tmp += len(self.record[l])
            return tmp + low_cnt + high_cnt
 
    def findStrobogrammatic(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        self.record = dict()
        self.record[0] = ["0"]
        self.record[1] = ["0", "1", "8"]
        self.record[2] = ["11", "69", "88", "96"]
        pair = ["00", "11", "88", "69", "96"]
        if n <= 2:
            return self.record[n]
        cnt = 3
        while cnt <= n:
            tmp = []
            if (cnt - 1) % 2 == 0: #å¦‚æœå‰ä¸€ä¸ªæ˜¯å¶æ•°é•¿åº¦ï¼Œé‚£ä¹ˆç›´æ¥åœ¨ä¸­é—´åŠ é•¿åº¦ä¸º1çš„å°±å¯ä»¥
                for item in self.record[cnt - 1]:
                    for num in self.record[1]:
                        tmp.append(item[:len(item)// 2] + num + item[len(item) // 2:])
            else:                  #å¦‚æœå‰ä¸€ä¸ªæ˜¯å¥‡æ•°é•¿åº¦ï¼Œé‚£ä¹ˆå°±åœ¨ä¸­é—´åŠ é•¿åº¦ä¸º2çš„å°±å¯ä»¥ ï¼Œæ³¨æ„è¦é¢å¤–åŠ â€œ00â€
                for item in self.record[cnt - 2]:
                    for num in pair:
                        tmp.append(item[:len(item)// 2] + num + item[len(item) // 2:])
            self.record[cnt] = sorted(tmp, key = lambda x: int(x))
            cnt += 1
```

æ€è·¯äºŒï¼š

ä» n=0 å’Œ n=1 çš„ä¸­å¿ƒå¯¹ç§°æ•°å¼€å§‹ï¼Œåœ¨æ¯ä¸ªæ•°ä¸¤ç«¯åŠ ä¸Š00ï¼Œ11ï¼Œ88ï¼Œ69ï¼Œ96ã€‚å¾—åˆ°çš„æ•°numä¸€å®šä¹Ÿæ˜¯ä¸­å¿ƒå¯¹ç§°æ•°ï¼Œæ‰€ä»¥åªéœ€è¦åˆ¤æ–­numæ˜¯å¦åœ¨[low, high]å†…å³å¯

```java

class Solution {
public:
    string low, high;
    int cnt;
 
    int strobogrammaticInRange(string low, string high) {
        this->low = low;
        this->high = high;
        cnt = 0;
        solve("");
        solve("0");
        solve("1");
        solve("8");
        return cnt;
    }
 
    void solve(string num) {
        if((num.size() > high.size()) ||                 // é€’å½’è¾¹ç•Œï¼šè‹¥numçš„é•¿åº¦ > highçš„é•¿åº¦
           (num.size()==high.size() && num > high))      // æˆ–é•¿åº¦ç›¸ç­‰,ä½†numæ¯”highå¤§ (stringå¯ç”¨>ç›´æ¥æ¯”è¾ƒ)
            return;
 
        // è‹¥numåœ¨[low,high]å†…, å°±è®¡æ•°
        if(!(num.size()>1 && num[0]=='0') &&             // numå¼€å¤´ä¸æ˜¯0
           ((num.size() > low.size()) ||
            (num.size()==low.size() && num>=low))        // ä¸”num>=low (stringå¯ç”¨>ç›´æ¥æ¯”è¾ƒ)
        )
            ++cnt;
 
        solve("0" + num + "0");
        solve("1" + num + "1");
        solve("8" + num + "8");
        solve("6" + num + "9");
        solve("9" + num + "6");
    }

```

## 243 æœ€çŸ­çš„å•è¯è·ç¦»II

Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = â€œcodingâ€, word2 = â€œpracticeâ€
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
å¤šæ¬¡è°ƒç”¨word1å’Œword2

```java
class WordDistance {
public:
    WordDistance(vector<string>& words) {
        for (int i = 0; i < words.size(); ++i) {
            m[words[i]].push_back(i);
        }
    }

    int shortest(string word1, string word2) {
        int i = 0, j = 0, res = INT_MAX;
        while (i < m[word1].size() && j < m[word2].size()) {
            res = min(res, abs(m[word1][i] - m[word2][j]));
            m[word1][i] < m[word2][j] ? ++i : ++j;
        }
        return res;
    }
  
private:
    unordered_map<string, vector<int> > m;
};
```

## 244 æœ€çŸ­çš„å•è¯è·ç¦»III

Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = â€œcodingâ€, word2 = â€œpracticeâ€
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
word1å’Œword2å¯èƒ½ç›¸åŒ

ç”¨idxè®°å½•ä¸Šä¸€æ¬¡çš„æƒ…å†µï¼Œiè¡¨ç¤ºå½“å‰æƒ…å†µ
å½“word1==word2æ—¶ï¼Œidxå’Œiåˆ†åˆ«è¡¨ç¤ºç›¸é‚»ä¸¤æ¬¡é‡åˆ°å•è¯word1çš„ä½ç½®ï¼Œè®¡ç®—res
å½“word1!=word2æ—¶ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼šword[idx]==word[i],æ›´æ–°idxå³å¯ï¼›word[idx]!=word[i]ï¼Œè®¡ç®—res

```java
class Solution {
public:
    int shortestWordDistance(vector<string>& words, string word1, string word2) {
        int idx = -1, res = INT_MAX;
        for (int i = 0; i < words.size(); ++i) {
            if (words[i] == word1 || words[i] == word2) {
                if (idx != -1 && (word1 == word2 || words[i] != words[idx])) {
                    res = min(res, i - idx);
                }
                idx = i;
            }
        }
        return res;
    }
};
```

## 253 ä¼šè®®å®¤II

ç»™å®šä¸€ä¸ªä¼šè®®æ—¶é—´å®‰æ’çš„æ•°ç»„ï¼Œæ¯ä¸ªä¼šè®®æ—¶é—´éƒ½ä¼šåŒ…æ‹¬å¼€å§‹å’Œç»“æŸçš„æ—¶é—´ [[s1,e1],[s2,e2],...] (si < ei)ï¼Œä¸ºé¿å…ä¼šè®®å†²çªï¼ŒåŒæ—¶è¦è€ƒè™‘å……åˆ†åˆ©ç”¨ä¼šè®®å®¤èµ„æºï¼Œè¯·ä½ è®¡ç®—è‡³å°‘éœ€è¦å¤šå°‘é—´ä¼šè®®å®¤ï¼Œæ‰èƒ½æ»¡è¶³è¿™äº›ä¼šè®®å®‰æ’ã€‚

https://www.cnblogs.com/grandyang/p/5244720.html

è§£æ³•ä¸€ï¼š

ä½¿ç”¨ TreeMap æ¥åšçš„ï¼Œéå†æ—¶é—´åŒºé—´ï¼Œå¯¹äºèµ·å§‹æ—¶é—´ï¼Œæ˜ å°„å€¼è‡ªå¢1ï¼Œå¯¹äºç»“æŸæ—¶é—´ï¼Œæ˜ å°„å€¼è‡ªå‡1ï¼Œç„¶åå®šä¹‰ç»“æœå˜é‡ resï¼Œå’Œæˆ¿é—´æ•° roomsï¼Œéå† TreeMapï¼Œæ—¶é—´ä»å°åˆ°å¤§ï¼Œæˆ¿é—´æ•°æ¯æ¬¡åŠ ä¸Šæ˜ å°„å€¼ï¼Œ

```java
class Solution {
public:
    int minMeetingRooms(vector<vector<int>>& intervals) {
        map<int, int> m;
        for (auto a : intervals) {
            ++m[a[0]];
            --m[a[1]];
        }
        int rooms = 0, res = 0;
        for (auto it : m) {
            res = max(res, rooms += it.second);
        }
        return res;
    }
};
```

è§£æ³•äºŒï¼š

ç¬¬äºŒç§æ–¹æ³•æ˜¯ç”¨ä¸¤ä¸ªä¸€ç»´æ•°ç»„æ¥åšï¼Œåˆ†åˆ«ä¿å­˜èµ·å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼Œç„¶åå„è‡ªæ’ä¸ªåºï¼Œå®šä¹‰ç»“æœå˜é‡ res å’Œç»“æŸæ—¶é—´æŒ‡é’ˆ endposï¼Œç„¶åå¼€å§‹éå†ï¼Œå¦‚æœå½“å‰èµ·å§‹æ—¶é—´å°äºç»“æŸæ—¶é—´æŒ‡é’ˆçš„æ—¶é—´ï¼Œåˆ™ç»“æœè‡ªå¢1ï¼Œåä¹‹ç»“æŸæ—¶é—´æŒ‡é’ˆè‡ªå¢1ï¼Œè¿™æ ·å¯ä»¥æ‰¾å‡ºé‡å çš„æ—¶é—´æ®µï¼Œä»è€Œå®‰æ’æ–°çš„ä¼šè®®å®¤ï¼Œ

```java

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals == null || intervals.length == 0) return 0; 
        int[] start = new int[intervals.length];
        int[] end = new int[intervals.length];
        for(int i=0;i<intervals.length;i++){
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
    
        int rooms=0, activeMeeting = 0;
        int i=0,j=0;
        while(i<intervals.length && j<intervals.length){
            if(start[i]<end[j]){
                activeMeeting++;
                i++;
            }else{
                activeMeeting--;
                j++;
         }
            rooms = Math.max(rooms,activeMeeting);
        }
        return rooms;
    
    }
```

è§£æ³•ä¸‰ï¼š

æœ€å°å †minHeapï¼Œå…ˆæŒ‰startæ’åºï¼Œç„¶åç»´æŠ¤ä¸€ä¸ªminHeapï¼Œå †é¡¶å…ƒç´ æ˜¯ä¼šè®®ç»“æŸæ—¶é—´æœ€æ—©çš„åŒºé—´ï¼Œä¹Ÿå°±æ˜¯endæœ€å°ã€‚æ¯æ¬¡æ¯”è¾ƒtopå…ƒç´ çš„endæ—¶é—´å’Œå½“å‰å…ƒç´ çš„startæ—¶é—´ï¼Œå¦‚æœend < startï¼Œè¯´æ˜è¯¥roomå¯ä»¥ç»“æŸæ¥ä¸‹æ¥è¢«å½“å‰ä¼šè®®åŒºé—´ä½¿ç”¨ã€‚æœ€åè¿”å›å †çš„å¤§å°å°±æ˜¯æ‰€éœ€çš„æˆ¿é—´æ•°ã€‚

```python
public class Solution {
   public int minMeetingRooms(Interval[] intervals) {   
     int n=intervals.length;   
     Arrays.sort(intervals, new Comparator<Interval>(){ 
         public int compare(Interval a, Interval b) {   
           return a.start-b.start;   
         } 
     });   
     PriorityQueue<Integer> pq=new PriorityQueue<>();   
     for (int i=0; i<n; i++) {   
       if (i>0 && intervals[i].start>=pq.peek()) pq.poll();   
       pq.add(intervals[i].end);   
     }   
     return pq.size();   
   }   
 } 
```

## 255 éªŒè¯å‰åºéå†åºåˆ—äºŒå‰æœç´¢æ ‘ï¼ˆäºŒå‰æ ‘ï¼‰

ç»´æŒä¸€ä¸ªæœ‰ä¸‹ç•Œçš„å•è°ƒé€’å‡æ ˆ(å•è°ƒæ ˆ)ï¼šå½“å…ƒç´ å¤§äºæ ˆé¡¶æ—¶ï¼Œè¡¨ç¤ºè¯¥å…ƒç´ æ˜¯å­æ ‘çš„å³èŠ‚ç‚¹ï¼Œå¼¹å‡ºå­æ ‘çš„æ ¹å’Œå·¦èŠ‚ç‚¹ï¼Œæ›´æ–°ä¸‹ç•Œï¼Œå‹å…¥å³èŠ‚ç‚¹ã€‚
å½“å¼¹å‡ºå­æ ‘çš„æ ¹å’Œå·¦èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥ç†è§£æˆå­æ ‘çš„å³èŠ‚ç‚¹ä»£æ›¿å­æ ‘
??? è¿˜æ˜¯å¾ˆéš¾ç†è§£

```python
class Solution {
public:
    bool verifyPreorder(vector<int>& preorder) {
        if (!preorder.size()) return true;
        stack<int> st;
        st.push(preorder[0]);
        int lst = INT_MIN;
        for (int i=1;i<preorder.size();i++)
        {
            if (preorder[i] < lst) return false;
            while(!st.empty() && preorder[i] > st.top()) 
            {
                lst = max(lst, st.top());
                st.pop();
            }
            st.push(preorder[i]);
        }
        return true;
    }
};
```

## å¤§æ¥¼è½®å»“é—®é¢˜

è§£æ³•ä¸€ï¼šçº¢é»‘æ ‘ multiset

å‚è€ƒé“¾æ¥ï¼šhttps://www.jianshu.com/p/36dcb18525a1

æ€è·¯ï¼š
cur_H: è¡¨ç¤ºæœªå®Œæˆå¤§æ¥¼è½®å»“ä¸­æ‰€æœ‰çš„å·¦å¢™é«˜åº¦ï¼Œæœ‰åº
pre: è¡¨ç¤ºæœªå®Œæˆå¤§æ¥¼è½®å»“çš„èµ·ç‚¹
(l, r, h)-->(l,-h), (r,h)
æ ¸å¿ƒæ€æƒ³ï¼šæ¯æ¬¡ç¡®å®šä¸€å°æ®µå¯ä»¥å®Œæˆçš„å¤§æ¥¼è½®å»“
ç¬¬ä¸€ï¼šå·¦å¢™å…¥ cur_Hï¼Œå³å¢™å‡º cur_H
ç¬¬äºŒï¼šå½“cur_Hçš„é«˜åº¦å‘ç”Ÿå˜åŒ–æ—¶ï¼Œç”»å‡ºä¸€ä¸ªè½®å»“

å¯¹äºç›¸åŒä½ç½®çš„å·¦å¢™ï¼Œå…ˆå…¥é«˜å¢™-10ï¼Œåå…¥çŸ®å¢™-5
å¯¹äºç›¸åŒä½ç½®çš„å³å¢™ï¼Œå…ˆå‡ºçŸ®å¢™5ï¼Œåå‡ºé«˜å¢™10

è¿™é‡Œä½œè€…ä½¿ç”¨äº†**çº¢é»‘æ ‘**æ¥å®ç°æ¯”è¾ƒå¿«çš„ æŸ¥æ‰¾(å–æœ€å¤§)ï¼Œæ’å…¥ï¼Œåˆ é™¤ æ“ä½œO(log n)ã€‚

```c++
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        multiset<pair<int, int>> all;
        vector<vector<int>> res;
    
        for (auto& e : buildings) {
            all.insert(make_pair(e[0], -e[2])); // critical point, left corner
            all.insert(make_pair(e[1], e[2])); // critical point, right corner
        }
    
        multiset<int> heights({0}); // ä¿å­˜å½“å‰ä½ç½®æ‰€æœ‰é«˜åº¦ã€‚
        int prev=0; // ä¿å­˜ä¸Šä¸€ä¸ªä½ç½®çš„é«˜åº¦
        for (auto& p : all) {
            if (p.second < 0) heights.insert(-p.second); // å·¦ç«¯ç‚¹ï¼Œé«˜åº¦å…¥å †
            else heights.erase(heights.find(p.second)); // å³ç«¯ç‚¹ï¼Œç§»é™¤é«˜åº¦
        
            // å½“å‰å…³é”®ç‚¹ï¼Œæœ€å¤§é«˜åº¦
            auto maxHeight = *heights.rbegin();
        
            // å½“å‰æœ€å¤§é«˜åº¦å¦‚æœä¸åŒäºä¸Šä¸€ä¸ªé«˜åº¦ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªè½¬æŠ˜ç‚¹
            if (prev!=maxHeight) {
                // æ›´æ–°prevå’Œç»“æœ
                res.push_back({l.first, maxHeight}); 
                prev = maxHeight; 
            }
        }
    
        return res;
    }
};

```

è§£æ³•äºŒï¼šå°é¡¶å †

heapï¼šå°é¡¶å †(h, r)ï¼Œè¡¨ç¤ºæ‰€æœ‰æœªå®Œæˆçš„å¤§æ¥¼é«˜åº¦åŠå¯¹åº”ç»ˆæ­¢åæ ‡ï¼Œå’Œéƒ¨åˆ†å·²ç»å®Œæˆçš„å¤§æ¥¼é«˜åº¦åŠå¯¹åº”ç»ˆæ­¢åæ ‡ï¼Œå¹¶ä¸”ä¿è¯å°é¡¶å †çš„å †é¡¶çš„å¤§æ¥¼é«˜åº¦ä¸€å®šæ˜¯æœªå®Œæˆçš„

(l, r, h)-->å·¦(l, -h, r), å³(r, 0, -1)

å› ä¸ºå³ç«¯ç‚¹ä¹Ÿå¯èƒ½é€ æˆå¤§æ¥¼è½®å»“ï¼Œæ‰€ä»¥éœ€è¦ä¿ç•™å³ç«¯ç‚¹
å…¥å †ï¼šå·¦ç«¯ç‚¹
å‡ºå †ï¼šå·¦å³ç«¯ç‚¹å¯¼è‡´çš„æ— æ•ˆè½®å»“
è®°å½•ï¼šå½“å°é¡¶å †å †é¡¶é«˜åº¦å‘ç”Ÿå˜åŒ–æ—¶

```python
import heapq
import sys
class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        points = []
        for l, r, h in buildings:
            points.append((l, -h, r))
            points.append((r, 0, -1))
        points.sort()
        heap = [(0, sys.maxsize)]
        res = []
        prev = 0
        for l, h, r in points:
            while l>=heap[0][1]:
                heapq.heappop(heap)
            if h<0:
                heapq.heappush(heap, (h, r))
            if prev!=heap[0][0]:
                prev = heap[0][0]
                res.append([l, -prev])
        return res
```

## 259. è¾ƒå°çš„ä¸‰æ•°ä¹‹å’Œ

æ’åº+åŒæŒ‡é’ˆ(left, right)

```python
class Solution(object):
    def threeSumSmaller(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        N = len(nums)
        res = 0
        nums.sort()
        for i, num in enumerate(nums):
            x = target - num
            left, right = i+1, N-1
            while(left < right):
                tmp = nums[left]+nums[right]
                if  tmp >= x:
                    right -= 1
                else:
                    res += right-left
                    left += 1
        return res
```

## 260. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— III

```python
class Solution:
    def singleNumber(self, nums: int) -> List[int]:
        # difference between two numbers (x and y) which were seen only once
        bitmask = 0
        for num in nums:
            bitmask ^= num
    
        # rightmost 1-bit diff between x and y
        diff = bitmask & (-bitmask)
    
        x = 0
        for num in nums:
            # bitmask which will contain only x
            if num & diff:
                x ^= num
    
        return [x, bitmask^x]
```

## 261 ä»¥å›¾åˆ¤æ ‘

å¹¶æŸ¥é›†: åªæœ‰ä¸€ä¸ªæ ¹ï¼Œæ²¡æœ‰ç¯

```python
class UnionFindSet(object):
    def __init__(self, n):
        self.count = n
        self.roots = [i for i in range(n)]
    
    def find(self, node):
        while self.roots[node] != node:
            node = self.roots[node]
        return node
  
    def union(self, p, q):
        p_parent = self.find(p)
        q_parent = self.find(q)
        self.roots[p_parent] = q_parent
        self.count -= 1
    
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        #å¼€å¹¶æŸ¥é›†ï¼Œå¦‚æœä¸€æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹åœ¨æ”¾è¿›å›¾ä¹‹å‰å°±æœ‰ç›¸åŒçš„æ ¹ç»“ç‚¹ï¼Œåˆ™è¯´æ˜è¿™æ¡è¾¹æ”¾è¿›å»ä¹‹åä¼šå½¢æˆä¸€ä¸ªç¯
        ufs = UnionFindSet(n)
        for start, end in edges:
            if ufs.find(start) == ufs.find(end):
                return False
            ufs.union(start, end)
        # print ufs.count
        return ufs.count == 1
```

## 265 ç²‰åˆ·æˆ¿å­II

å¯¹äºæ¯ä¸€ä¸ªæˆ¿å­ï¼Œä¿å­˜æœ€å°èŠ±è´¹MINå’Œæ¬¡æœ€å°èŠ±è´¹2_MINã€‚å¯¹äºä¸‹ä¸€ä¸ªæˆ¿å­ï¼Œæ¶‚æŸç§æ²¹æ¼†æ—¶ä¸èƒ½ä½¿ç”¨MINï¼Œå³æ²¹æ¼†å·ç­‰äºMINæ‰€å¯¹åº”çš„æ²¹æ¼†å·æ—¶ï¼Œæ­¤æ—¶åªèƒ½ä½¿ç”¨2_MINã€‚é™¤æ­¤ä¹‹å¤–ï¼Œéƒ½ä½¿ç”¨MINã€‚æ—¶é—´å¤æ‚åº¦ O(nk)

```java
class Solution {
public:
    int minCostII(vector<vector<int>>& costs) {
        if(costs.size()==0 or costs[0].size()==0){
            return 0;
        }
        int pre_min_index=-1,pre_min_cost=0,pre_2min_cost=0;
        for(int i=0;i<costs.size();++i){
            int cur_min_index,cur_min_cost=INT_MAX,cur_2min_cost=INT_MAX;
            for(int j=0;j<costs[0].size();++j){
                if(j!=pre_min_index){
                    costs[i][j]+=pre_min_cost;
                }
                else{
                    costs[i][j]+=pre_2min_cost;
                }
                if(costs[i][j]<cur_min_cost){
                    cur_2min_cost=cur_min_cost;
                    cur_min_cost=costs[i][j];
                    cur_min_index=j;
                }
                else if(costs[i][j]<cur_2min_cost){
                    cur_2min_cost=costs[i][j];
                }
            }
            pre_min_index=cur_min_index;
            pre_min_cost=cur_min_cost;
            pre_2min_cost=cur_2min_cost;
            // cout<<pre_min_index<<" "<<pre_min_cost<<" "<<pre_2min_cost<<endl;
        }
        return pre_min_cost;
    }
};

```

## 269 Alien Dictionary ç«æ˜Ÿè¯å…¸

æ€è·¯ï¼š

å¤§è‡´æ€è·¯å°±æ˜¯æ ¹æ®å­—æ¯å‡ºç°çš„é¡ºåºå…ˆæ„é€ å‡ºå›¾æ¥ï¼Œ
ç„¶åè¿›è¡Œä¸€ä¸‹æ‹“æ‰‘æ’åºå°±å¯ä»¥äº†

æ„é€ å›¾çš„è¿‡ç¨‹å°±æ˜¯éå†å­—ç¬¦ä¸²ï¼Œ
æ‰¾åˆ°ç¬¬iä¸ªå’Œç¬¬i+1ä¸ªå­—ç¬¦ä¸²ç¬¬ä¸€å¯¹ä¸åŒçš„å­—æ¯ï¼Œç„¶åå»ºç«‹ä¸€å¯¹å…³ç³»ã€‚

å»ºç«‹å®Œå›¾æ’ä¸€ä¸ªæ‹“æ‰‘åºå°±okäº†ã€‚

```python
from collections import deque
def alienOrder(words:list[int]):
    in_degree, parents, cnt = initGraph(words)
    res = topology_sort(in_degree, parents, cnt)
    return res

def initGraph(words):
    in_degree = [-1 for _ in range(26)]
    parents = [[] for _ in range(26)]
    cnt = 0
    for c in words[0]:
        index = ord(c)-ord('a')
        if in_degree[index]==0:
            in_degree[index]=1
            cnt+=1
    
    for i in range(1, len(words)):
        for c in words[i]:
            index = ord(c)-ord('a')
            if in_degree[index]==0:
                in_degree[index]=1
                cnt+=1
        for j in range(len(words[i-1])):
            if words[i-1][j]==words[i][j]:
                continue
            parents[ord(words[i-1][j])-ord('a')].append(ord(words[i][j])-ord('a'))
            in_degree[ord(words[i][j])-ord('a')]+=1
            break
  
    return in_degree, parents, cnt

def topology_sort(in_degree, parents, cnt):
    que = deque()
    for val in in_degree:
        if val==0:
            que.append(val)
    res = list()
    while que:
        cur = que.popleft()
        res.append(chr(cur+ord('a')))
        for val in parents[cur]:
            in_degree[val]-=1
            if in_degree[val]==0:
                que.append(val)
    if len(res)==cnt:
        return res
    else:
        return list()
```

## 271. å­—ç¬¦ä¸²çš„ç¼–ç ä¸è§£ç 

ç¼–ç ï¼šå­—ç¬¦ä¸²é•¿åº¦+ç‰¹æ®Šå­—ç¬¦+å­—ç¬¦ä¸² æˆ–è€… å­—ç¬¦ä¸²é•¿åº¦(å›ºå®šå å››ä¸ªå­—èŠ‚)+å­—ç¬¦ä¸²

```python
class Codec:
    def len_to_str(self, x):
        """
        Encodes length of string to bytes string
        """
        x = len(x)
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(3, -1, -1)]
        bytes_str = ''.join(bytes)
        return bytes_str
  
    def encode(self, strs):
        """Encodes a list of strings to a single string.
        :type strs: List[str]
        :rtype: str
        """
        # encode here is a workaround to fix BE CodecDriver error
        return ''.join(self.len_to_str(x) + x for x in strs).encode('utf-8')
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
  
    def decode(self, s):
        """Decodes a single string to a list of strings.
        :type s: str
        :rtype: List[str]
        """
        i, n = 0, len(s)
        s = s.decode("utf-8")
        output = []
        while i < n:
            length = self.str_to_int(s[i: i + 4])
            i += 4
            output.append(s[i: i + length])
            i += length
        return output
```

## 272 äºŒå‰æœç´¢æ ‘ä¸­æœ€æ¥è¿‘çš„å€¼ II

æ€è·¯ä¸€ï¼šä¸­åºéå†+äºŒåˆ†æœç´¢æœ€æ¥è¿‘å€¼+å·¦å³æŒ‡é’ˆ O(N)

```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
 
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        if root is None or k == 0:
            return []
         
        nums = self.get_inorder(root)
        left = self.find_lower_index(nums, target)
        right = left + 1
        results = []
        for _ in range(k):
            if (right >= len(nums)) or (left >=0 and target - nums[left] < nums[right] - target):
                results.append(nums[left])
                left -= 1
            else:
                results.append(nums[right])
                right += 1
        return results
     
    def get_inorder(self, root):
        result = []
        stack = []
        node = root
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                result.append(node.val)
                node = node.right
        return result
     
     
    def find_lower_index(self, nums, target):
        """
        find the largest number < target, return the index
        """
        start, end = 0, len(nums) - 1
        res = -1
        while start <= end:
            mid = (start + end) // 2
            if nums[mid] < target:
                res = mid
                start = mid+1
            else:
                end = mid-1
         
        return res
```

æ€è·¯äºŒï¼šä¸­åºéå†+çª—å£ä¸ºkçš„é˜Ÿåˆ—+æå‰æˆªæ­¢ O(n)
https://zhuanlan.zhihu.com/p/125724782
æ ¹æ®æ€è·¯ä¸€ï¼Œæœ€åçš„ç»“æœä¸€å®šæ˜¯ä»¥targetä¸ºä¸­å¿ƒçš„è¿ç»­kä¸ªæ•°å­—
çª—å£ä¸ºkçš„é˜Ÿåˆ—ï¼šä»ä¸­åºéå†å¼€å§‹ï¼Œç»´æŒçª—å£ä¸ºkçš„é˜Ÿåˆ—ï¼Œå¦‚æœå½“å‰å€¼-targetå¤§äºé˜Ÿé¦–-targetï¼Œå¼¹å‡ºé˜Ÿé¦–ï¼ŒåŠ å…¥å½“å‰å€¼ï¼Œåä¹‹ï¼Œè¯´æ˜rootåé¢çš„å€¼éƒ½å¤ªå¤§ï¼Œæå‰æˆªæ­¢

```python
from collections import deque
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        self.que = deque()
        self.k = k
        self.target = target

    def inorder(self, root, ):
        if not root:
            return False
        if self.inorder(root.left):
            return True 
        if len(self.que)<self.k:
            self.que.append(root.val)
            return False
        if abs(self.target - self.que[0]) > (root.val-self.target):
            self.que.popleft()
            self.que.append(root.val)
        else:
            return True
        if self.inorder(root.right):
            return True
        return False
```

æ€è·¯ä¸‰ï¼šä¸­åºéå†+äºŒåˆ†æŸ¥æ‰¾æœ€æ¥è¿‘å€¼+O(H)æŸ¥æ‰¾å‰é©±å’Œåç»§

é¦–å…ˆæŸ¥æ‰¾æœ€æ¥è¿‘å€¼ï¼Œç„¶åæŸ¥æ‰¾kä¸ªå‰é©±å’Œåç»§ï¼Œç„¶ååˆå¹¶ï¼Œç”¨å“ˆå¸Œè¡¨fatherä¿å­˜çˆ¶ç»“ç‚¹ O(H)

å‰é©±ï¼š
å¦‚æœcuræœ‰å·¦å­æ ‘ï¼Œåˆ™å·¦å­æ•°çš„æœ€å³ç»“ç‚¹å°±æ˜¯å‰é©±ç»“ç‚¹
å¦‚æœcuræ²¡æœ‰å·¦å­æ•°ï¼Œåˆ™ä»ä¸‹å¾€ä¸Šæ‰¾ç¥–çˆ¶ç»“ç‚¹ï¼šæ»¡è¶³ç¥–çˆ¶ç»“ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³å­æ ‘ï¼Œåˆ™ç¥–çˆ¶ç»“ç‚¹çš„çˆ¶ç»“ç‚¹æ˜¯å‰é©±ç»“ç‚¹

åç»§ï¼š
å¦‚æœcuræœ‰å³å­æ ‘ï¼Œåˆ™å³å­æ ‘çš„æœ€å·¦ç»“ç‚¹å°±æ˜¯åç»§ç»“ç‚¹
å¦‚æœcuræ²¡æœ‰å³å­æ ‘ï¼Œåˆ™ä»ä¸‹å¾€ä¸Šæ‰¾ç¥–çˆ¶ç»“ç‚¹ï¼šæ»¡è¶³ç¥–çˆ¶ç»“ç‚¹æ˜¯å…¶çˆ¶ç»“ç‚¹çš„å·¦å­æ ‘ï¼Œåˆ™ç¥–çˆ¶ç»“ç‚¹çš„çˆ¶ç»“ç‚¹æ˜¯åç»§ç»“ç‚¹

çˆ¶ç»“ç‚¹fatherä¸éœ€è¦åˆ»æ„ä¿å­˜ï¼Œåªéœ€è¦åœ¨è®¿é—®ç»“ç‚¹æ—¶ä¿å­˜å³å¯

```python
import sys
from collections import defaultdict
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        self.target = target
        self.k = k
        self.father = {root:None}
        self.closestNode = [None, sys.maxsize]
        self.search2(root)
        res = [self.closestNode[0].val]
        pre, pro = self.getPrecursor(self.closestNode[0]), self.getSuccessor(self.closestNode[0])
        for i in range(k-1):
            if (not pro) or (pre and abs(pre.val-target)<abs(pro.val-target)):
                res.append(pre.val)
                pre = self.getPrecursor(pre)
            else:
                res.append(pro.val)
                pro = self.getSuccessor(pro)
        return res


    def search2(self, root):
        if not root:
            return
        if abs(self.root.val-self.target)<self.closestNode[1]:
            self.closestNode = [root, abs(self.root.val-self.target)]
        if root.val==self.target:
            return
        if root.left and root.val>self.target:
            self.father[root.left]=root
            self.search2(root.left)
        if root.right and root.val<self.target:
            self.father[root.right]=root
            self.search2(root.right)
  
    def getPrecursor(self, root):
        if root.left:
            self.father[root.left]=root
            res = root.left
            while res.right:
                self.father[res.right]=res
                res = res.right
            return res
        while self.father[root] and self.father[root].right.val!=root.val:
            root = self.father[root]
        return self.father[root]
  
    def getSuccessor(self, root):
        if root.right:
            self.father[root.right]=root
            root = root.right
            while root.left:
                self.father[root.left]=root
                root = root.left
        while self.father[root] and self.father[root].left.val!=root.val:
            root = self.father[root]
        return self.father[root]
```

## 273. æ•´æ•°è½¬æ¢è‹±æ–‡è¡¨ç¤º

æ¯ä¸‰ä½åˆ’åˆ†ä¸ºä¸€ç»„ï¼›å¯¹äºä¸‰ä½æ•°ï¼Œåˆ’åˆ†ä¸ºç™¾ä½+ä¸¤ä½ï¼›å¯¹äºä¸¤ä½æ•°ï¼šåˆ†ä¸º0-9ï¼Œ 10-19ï¼Œ 20-99.
å¯¹äºthousandï¼Œmillionï¼Œ billionï¼Œåˆ†åˆ«å¯¹åº”ä½ç½®è¡¥å……å³å¯ï¼Œ
åœ¨æœ€åç»“æœä¸­å°†0å¯¹åº”çš„ç©ºå­—ç¬¦ä¸²å»æ‰ï¼Œæ¯”å¦‚1000ä¸­ï¼Œåä¸‰ä½çš„000ä¸è¡¨ç¤º

```python
class Solution:
    def numberToWords(self, num: int) -> str:
        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \
               'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()
        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()

        def helper(num):
            if num < 20:
                return to19[num - 1:num]
            if num < 100:
                return [tens[num // 10 - 2]] + helper(num % 10)
            if num < 1000:
                return [to19[num // 100 - 1]] + ["Hundred"] + helper(num % 100)
            for p, w in enumerate(["Thousand", "Million", "Billion"], 1):
                if num < 1000 ** (p + 1):
                    return helper(num // 1000 ** p) + [w] + helper(num % 1000 ** p)

        return " ".join(helper(num)) or "Zero"
```

## 274. H æŒ‡æ•°

HæŒ‡æ•°ï¼šå¤§äºç­‰äºhçš„è®ºæ–‡æ•°é‡å¤§äºç­‰äºhï¼Œæˆ–è€…è¯´ï¼Œ

æ–¹æ³•ä¸€ï¼šæ’åºï¼šå°†è®ºæ–‡é™åºæ’åºï¼Œcita[i]>=i+1ï¼Œæ‰¾åˆ°æœ€å¤§çš„i+1ï¼Œ O(nlgn)

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations= sorted(citations, reverse=True)
        i = 0
        while (i < len(citations) and citations[i] > i) :
            i+=1
        return i
```

å¼•ç”¨i+1ä»å°åˆ°å¤§1~nï¼Œcitations[i] >= i+1ä¿è¯äº†å¯¹äºå¼•ç”¨i+1ï¼Œè‡³å°‘æœ‰0~içš„è®ºæ–‡å¤§äºç­‰äºå¼•ç”¨i+1
[6,5,4,1,0]-->[True, True, True, False, False, False]ï¼Œæ‰¾æœ€åä¸€ä¸ªTï¼Œè¿”å›i+1

æ–¹æ³•äºŒï¼šè®¡æ•°æ’åº

å› ä¸ºå³ä¾¿è®ºæ–‡çš„å¼•ç”¨æ¬¡æ•°è¶…è¿‡nï¼ŒhæŒ‡æ•°ä¹Ÿä¸å¯èƒ½è¶…è¿‡nï¼Œæ‰€ä»¥å°†å¼•ç”¨æ¬¡æ•°è¶…è¿‡nçš„è®ºæ–‡è§†ä¸ºå¼•ç”¨æ¬¡æ•°ä¸ºnä¸å½±å“æœ€åç»“æœ

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        h = [0 for _ in range(n+1)]
        for val in citations:
            h[min(n, val)] += 1
        tmp = 0
        for k in range(n, -1, -1):
            tmp +=  h[k]
            if tmp>=k:
                break
        return k
```

å¯¹hä»å¤§åˆ°å°éå†n~0ï¼ŒåŒæ—¶è®°å½•å¤§äºç­‰äºhçš„è®ºæ–‡æ€»æ•°é‡sumï¼Œç›´åˆ°sum>=k
[0,1,4,5,6]-->è®¡æ•°æ’åºå¾—[1,1,0,0,1,2]-->[5,4,3,3,3,2]-->[T,T,T,T(res),F,F]ï¼Œæ‰¾æœ€åä¸€ä¸ªT

## 275 HæŒ‡æ•° II

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        if not citations:
            return 0
        n = len(citations)
        left, right = 0, n-1
        res = 0
        while left<=right:
            mid = (left+right)//2
            if citations[mid]>=n-mid:
                res = n-mid
                right = mid-1
            else:
                left = mid+1
        return res
```

citations[mid]>=n-midï¼šå¯¹äºå¼•ç”¨æ¬¡æ•°å¤§äºç­‰äºn-içš„æ–‡ç« æ•°é‡å¤§äºç­‰äºn-i

0,1,4,5,6-->n-i:5,4,3,2,1-->F,F,T,T,T æ‰¾åˆ°ç¬¬ä¸€ä¸ªT

## 277 æœå¯»åäºº

https://www.dazhuanlan.com/2019/12/13/5df2f91dacafd/

https://www.cnblogs.com/grandyang/p/5310649.html

åäººæœ‰ä¸¤ä¸ªæ¡ä»¶ï¼šç¬¬ä¸€ï¼šæ‰€æœ‰äººéƒ½è®¤è¯†ä»–ï¼Œç¬¬äºŒï¼šä»–ä¸è®¤è¯†æ‰€æœ‰äººï¼›å¹¶ä¸”å¾ˆæ˜æ˜¾ï¼Œåäººåªèƒ½æœ‰ä¸€ä¸ªã€‚
å¯¹äºknow(a, b):å¦‚æœä¸ºTrueï¼Œåˆ™aä¸€å®šä¸æ˜¯åäººï¼›å¦‚æœä¸ºFalseï¼Œåˆ™bä¸€å®šä¸æ˜¯åäºº
æ‰€ä»¥æ¯æ¬¡è°ƒç”¨knowï¼Œéƒ½å¯ä»¥æ’é™¤ä¸€ä¸ªäººï¼ŒåŒæ—¶å‰©ä¸‹ä¸€ä¸ªå€™é€‰äººã€‚å†åˆ©ç”¨å€™é€‰äººå’Œä¸‹ä¸€ä¸ªäººåšæ¯”è¾ƒï¼Œåˆå¯ä»¥æ’é™¤ä¸€ä¸ªäººï¼Œå‰©ä¸‹ä¸€ä¸ªå€™é€‰äººï¼Œä¸€å…±éœ€è¦n-1æ¬¡ï¼Œæ’é™¤æ‰n-1ä¸ªäººï¼Œå†å¯¹å‰©ä¸‹çš„å€™é€‰äººåšå…¨é¢çš„æ£€æŸ¥ã€‚

```python
def findCelebrity(n):
    res = 0
    for i in range(n):
        if know(res, i):
            res = i
    for i in range(res):
        if know(res, i) or (not know(i, res)):
            return -1
    for i range(res+1, n):
        if not know(i, res):
            return -1
    return res
```

## 160 ç›¸äº¤é“¾è¡¨

p1æŒ‡å‘headAï¼Œp2æŒ‡å‘headBï¼Œå½“p1/p2æŒ‡å‘é“¾è¡¨headA/headBçš„æœ«å°¾æ—¶ï¼ŒæŒ‡å‘headB/headAï¼Œå‘å‰èµ°ï¼Œç›´åˆ°ç›¸é‡æˆ–è€…è¾¾åˆ°æœ«å°¾ã€‚
ç›¸äº¤æ—¶ï¼Œèƒ½ç›¸é‡ï¼Œp1==p2ï¼šp1èµ°è¿‡äº†Açš„å•ç‹¬éƒ¨åˆ†+å…¬å…±éƒ¨åˆ†+Bçš„å•ç‹¬éƒ¨åˆ†ï¼Œp2èµ°è¿‡äº†Bçš„å•ç‹¬éƒ¨åˆ†+å…¬å…±éƒ¨åˆ†+Açš„å•ç‹¬éƒ¨åˆ†ï¼Œæ‰€ä»¥åœ¨ç›¸äº¤èƒ½ç›¸é‡
ä¸ç›¸äº¤æ—¶ï¼Œèƒ½åœ¨æœ«å°¾ç›¸é‡ï¼ŒNone==None

```python
def getIntersectionNode(headA, headB):
    p1, p2 = headA, headB
    while p1!=p2:
        if not p1:
            p1 = headB
        else:
            p1 = p1.next
        if not p2:
            p2 = headA
        else:
            p2 = p2.next
    if p1:
        return p1.val
    else:
        return None
```

## 279 å®Œå…¨å¹³æ–¹æ•°

è§£æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

å»ºç«‹n+1çš„æ•°ç»„dpï¼Œè¡¨ç¤ºå®Œå…¨å¹³æ–¹æ•°çš„æœ€å°‘ç»„åˆä¸ªæ•°ï¼Œå¦‚æœnæ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œåˆ™dp[n]=1ï¼Œå¦åˆ™ï¼Œdp[n]=min(dp[j*j]+dp[i-j*j]),jå±äº[1, nå¼€å¹³æ–¹]
O(n^(3/2))

```python
def numSquares(n):
    if n<=0:
        return 0
    if int(n**0.5)**2==n:
        return 1
    dp = [0 for _ in range(n+1)]
    for i in range(int(n**0.5)):
        dp[i*i]=1
    for i in range(1, n):
        if dp[i]:
            continue
        count = n
        for j in range(1, int(i**0.5)):
            count = min(count, dp[j*j]+dp[i-j*j])
        dp[i] = count
    return dp[-1]
```

è§£æ³•äºŒï¼šæ•°å­¦å…¬å¼

Lagrange å››å¹³æ–¹å®šç†ï¼š ä»»ä½•ä¸€ä¸ªæ­£æ•´æ•°éƒ½å¯ä»¥è¡¨ç¤ºæˆä¸è¶…è¿‡å››ä¸ªæ•´æ•°çš„å¹³æ–¹ä¹‹å’Œã€‚
æ»¡è¶³å››æ•°å¹³æ–¹å’Œå®šç†çš„æ•°nï¼ˆè¿™é‡Œè¦æ»¡è¶³ç”±å››ä¸ªæ•°æ„æˆï¼Œå°äºå››ä¸ªä¸è¡Œï¼‰ï¼Œå¿…å®šæ»¡è¶³ n=4a(8b+7)
å¹¶ä¸”n/4çš„å¹³æ–¹å’Œä¸ªæ•°ä¸nç›¸ç­‰ï¼Œæ¯”å¦‚ 20=2^2+4^2, 5=1^2+2^2

```python
class Solution:

    def isSquare(self, n: int) -> bool:
        sq = int(math.sqrt(n))
        return sq*sq == n

    def numSquares(self, n: int) -> int:
        # Lagrange's four-square theorem
        if self.isSquare(n):
            return 1
        while n % 4  == 0:
            n >>= 2
        if n%8 == 7:
            return 4
        sq = int(math.sqrt(n)) + 1
        for i in range(1,sq):
            if self.isSquare(n - i*i):
                return 2
        return 3
```

## 280. Wiggle Sort æ‘†åŠ¨æ’åº

https://www.cnblogs.com/grandyang/p/5177285.html

nums[0] <= nums[1] >= nums[2] <= nums[3]....
[3,5,1,6,2,4]

è§£æ³•ä¸€ï¼š
æ•°ç»„æ’åºï¼Œç„¶åè°ƒæ¢1ï¼Œ2çš„æ•°å­—ï¼Œ3ï¼Œ4çš„æ•°å­—ï¼Œä»¥æ­¤ç±»æ¨

è§£æ³•äºŒï¼š
O(n):å¯¹äºå¥‡æ•°ä½ç½®ï¼Œnums[i]>=nums[i-1]ï¼Œå¯¹äºå¶æ•°ä½ç½®ï¼Œæœ‰nums[i]<=nums[i-1]
å› æ­¤å¯¹æ¯ä¸ªæ•°å­—ï¼Œå¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œå’Œå‰é¢ä½ç½®è°ƒæ¢å³å¯
ä»¥å¥‡æ•°ä½ç½®ä¸ºä¾‹ï¼Œå¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œi-2>=i-1>iï¼Œè°ƒæ¢ä¹‹åä¸ºi-2>i < i-1ï¼Œæ»¡è¶³æ¡ä»¶

```python
def wiggleSort(nums):
    if len(nums)<=1:
        return nums
  
    for i in range(1, len(nums)):
        if (i%2==1 and nums[i-1]>nums[i]) or (i%2==0 and nums[i-1]<nums[i]):
            nums[i-1], nums[i] = nums[i], nums[i-1]
```

## 281 é”¯é½¿è¿­ä»£å™¨

https://github.com/grandyang/leetcode/issues/281

å»ºç«‹é˜Ÿåˆ—queueï¼Œå°†kä¸ªåˆ—è¡¨çš„å¤´æ”¾å…¥(index, vj, nj)ï¼ˆç¬¬vjä¸ªé˜Ÿåˆ—çš„ç¬¬indexå…ƒç´ ï¼‰ï¼Œæ¯æ¬¡å–å‡ºé˜Ÿé¦–ï¼Œå¹¶å°†å¯¹åº”åˆ—è¡¨çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ”¾å…¥é˜Ÿå°¾

```python
from collections import deque
class ZigzagIterator(object):
 
    def __init__(self, v1, v2):
        """
        Initialize your data structure here.
        :type v1: List[int]
        :type v2: List[int]
        """
        self.que = deque()
        self.que.extend([(0, 0), (0, 1)])
        self.v = [v1, v2]
    def next(self):
        index, j = self.que.popleft()
        res = self.v[j][index]
        if index+1<len(self.v[j]):
            self.que.append((index+1, j))
        return res

    def hasNext(self):
        return len(self.que)
```

## 282. ç»™è¡¨è¾¾å¼æ·»åŠ è¿ç®—ç¬¦

æœ€ç®€å•çš„æƒ…å†µï¼Œå¯¹äº + -ï¼Œå¹¶ä¸”åªèƒ½ä¸€ä½æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥è¿ç»­åœ°è¿›è¡Œè®¡ç®—ï¼Œæ¯”å¦‚5+2-8ï¼Œä»å·¦åˆ°å³è®¡ç®—å¾—åˆ° 5+2=7ï¼Œ7-8=-1

æ¯”è¾ƒå¤æ‚çš„æƒ…å†µï¼Œ+ - * ï¼Œåªèƒ½ä¸€ä½æ•°å­—ï¼Œå¯¹äº2+3* 4 * 5ï¼Œ2+3=5ï¼Œ2+3* 4 = 5-3+3* 4=14ï¼Œ2+3* 4* 5 = 14-12+12* 5= 62ï¼Œæ‰€ä»¥éœ€è¦preè®°å½•å¦‚æœå½“å‰æ•°å­—å‰é¢ç”¨ä¹˜æ³•ï¼Œvalue = value-pre+pre* cur, pre = pre* cur

æ›´å¤æ‚çš„æƒ…å†µï¼Œè€ƒè™‘+ - * ï¼Œå¯ä»¥å¤šä½æ•°å­—ï¼Œå°†å¤šä½æ•°å­—ä¹Ÿè®°ä¸ºä¸€ç§å³ç§»è¿ç®—ï¼Œå³ cur = cur* 10+nums[index ]

æ­¤æ—¶ï¼Œéœ€è¦å››ä¸ªå˜é‡ pre, cur, indexå’Œvalueï¼Œvalueè¡¨ç¤ºå½“å‰è¡¨è¾¾å¼çš„å€¼ï¼Œ

æœ€åï¼Œéœ€è¦è€ƒè™‘ç¬¬ä¸€ä¸ªæ•°å­—åªèƒ½æ˜¯åŠ æ³•ï¼Œæ¯ä¸ªå¤šä½æ•°å­—ä¸èƒ½æ˜¯0å¼€å¤´ã€‚

```python

def dfs(index, pre, cur, value):
    # å¤šä½æ•°å­—
    cur = cur*10+nums[index]
    # ç§»ä½è¿ç®—
    dfs(index+1, pre, cur, value)
    # åŠ æ³•è¿ç®—
    dfs(index+1, cur, 0, value+cur)
    # å‡æ³•è¿ç®—
    dfs(index+1, -cur, 0, value-cur)
    # ä¹˜æ³•è¿ç®—
    dfs(index+1, pre*cur, 0, value-pre+pre* cur)




class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        self.num = num
        self.target = target
        self.res = list()
        self.path = list()
        self.dfs(0, 0, 0, 0)
        return self.res

    def dfs(self, index, pre, cur, value):
        if index==len(self.num) and value==self.target and cur==0:
            self.res.append(''.join(self.path[1:]))
            return
        if index==len(self.num):
            return
    
        cur = cur*10+int(self.num[index])
        if cur>0:
            self.dfs(index+1, pre, cur, value)
        self.path.extend(['+', str(cur)])
        self.dfs(index+1, cur, 0, value+cur)
        if len(self.path)>2:
            self.path[-2] = '-'
            self.dfs(index+1, -cur, 0, value-cur)
            self.path[-2] = '*'
            self.dfs(index+1, pre*cur, 0, value-pre+pre*cur)
        self.path.pop()
        self.path.pop()
        return
```

## 284. é¡¶ç«¯è¿­ä»£å™¨

peekä¹‹åç”¨curè®°å½•å–å‡ºæ¥çš„å…ƒç´ ï¼Œç„¶å

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.cur = None

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        if not self.cur:
            self.cur = self.iterator.next()
        return self.cur
    

    def next(self):
        """
        :rtype: int
        """
        if self.cur:
            res = self.cur
            self.cur = None
            return res
        else:
            res = self.iterator.next()
            return res
    

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.cur!=None or self.iterator.hasNext()
    

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

## 285 äºŒå‰æœç´¢æ ‘ä¸­çš„é¡ºåºåç»§

åç»§ï¼šæœ‰å³å­æ ‘ï¼Œå³å­æ ‘çš„æœ€å·¦ç»“ç‚¹ï¼›æ²¡æœ‰å³å­æ ‘ï¼Œæ‰¾ç¥–çˆ¶ç»“ç‚¹ï¼ˆç¥–çˆ¶ç»“ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼‰çš„çˆ¶èŠ‚ç‚¹ã€‚ç”¨æ ˆè®°å½•çˆ¶èŠ‚ç‚¹

```python
def inorderSuccessor(self, root, p):
    self.stack = [None]
    ret = self.get(root, p)


def get(self, root, p):
    self.stack.append(root)
    if root.val==p.val:
        return root
    if root.val>p.val:
        return self.get(root.left, p)
    if root.val<p.val:
        return self.get(root.right, p)


def getSuccessor(self, p):
    if p.right:
        root = p.right
        while root.left:
            root = root.left
        return root
    else:
        while self.stack[-2] and self.stack[-2].left!=self.stack[-1]:
            self.stack.pop()
        return self.stack[-2]
```

## 286 å¢™ä¸é—¨

-1 è¡¨ç¤ºå¢™æˆ–æ˜¯éšœç¢ç‰©, 0æ˜¯é—¨ï¼ŒINFæ˜¯æˆ¿é—´

BFSï¼šä»é—¨å¼€å§‹æ‰©æ•£

```python
def wallsAndGates(self, rooms):
    n, m = len(rooms), len(rooms[0])
    for i in range(n):
        for j in range(m):
            if rooms[i][j]==0:
                bfs(i, j, 0)


def bfs(i, j, value):
    if not inRooms(i, j):
        return
    if rooms[i][j]==-1:
        return
    if rooms[i][j]<value:
        return
    rooms[i][j]=value
    bfs(i+1, j, value+1)
    bfs(i-1, j, value+1)
    bfs(i, j+1, value+1)
    bfs(i, j-1, value+1)
    return

def inRooms(i, j):
    return -1<i<n and -1<j<m
```

## 287. å¯»æ‰¾é‡å¤æ•°

https://leetcode-cn.com/problems/find-the-duplicate-number/comments/

nums = [1,3,4,2,2]

æ–¹æ³•ä¸€ï¼šäºŒåˆ†æ³•

O(nlogn)
å®šä¹‰cntè¡¨ç¤ºnumsæ•°ç»„ä¸­å°äºç­‰äºiçš„æ•°çš„ä¸ªæ•°(1<=i<=n)ï¼Œå‡è®¾é‡å¤çš„æ•°å­—æ˜¯targetï¼Œé‚£ä¹ˆ[1, target-1]ä¸­çš„æ•°å­—æ»¡è¶³cnt[i]<=iï¼Œ[target, n]ä¸­çš„æ•°å­—æ»¡è¶³cnt[i]>iï¼Œå¹¶ä¸”cntå…·æœ‰å•è°ƒæ€§ã€‚ä¸‹é¢è¯æ˜è¯¥æ€§è´¨ï¼š
å¯¹äºnumsåªå‡ºç°é‡å¤çš„æ•°å­—ï¼Œæ²¡æœ‰ç¼ºå¤±çš„æ•°å­—ï¼Œæ€§è´¨æ˜æ˜¾æˆç«‹ï¼Œ[1, target-1]:cnt[i]=iï¼Œ[target, n]:cnt[i]=i+1
å¯¹äºnumså‡ºç°é‡å¤çš„æ•°å­—targetä»¥åŠç¼ºå¤±æ•°å­—jï¼Œå¯ä»¥ç†è§£æˆæ•°å­—targetä»£æ›¿jï¼Œå¦‚æœj< targetï¼Œé‚£ä¹ˆ[j, target]:cnt[i]å‡å‡1ï¼Œå…¶ä»–ä¸å˜ï¼Œå¦‚æœj>=target, [target, j-1]:cntå‡åŠ 1ï¼Œå…¶ä»–ä¸å˜ï¼Œä¹Ÿæ»¡è¶³æ€§è´¨ã€‚
nums = [1,3,4,2,2]
cnt =  [1,3,4,5]

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)-1
        left, right = 1, n
        cnt = 0
        res = -1
        while left<=right:
            cnt = 0
            mid = (left+right)//2
            for val in nums:
                if val<=mid:
                    cnt+=1
            if cnt<=mid:
                left = mid+1
            else:
                res = mid
                right = mid-1
        return res
```

æ–¹æ³•äºŒï¼šäºŒè¿›åˆ¶æ³•

å°†æ•°å­—æŒ‰ç…§äºŒè¿›åˆ¶å±•å¼€ï¼Œå¯¹äºç¬¬iä½ï¼Œè®°numsæ•°ç»„ä¸­ç¬¬iä½çš„æ•°ä¸€å…±æœ‰xä¸ªï¼Œæ•°å­—[1, n]ç¬¬iä½çš„æ•°ä¸€å…±æœ‰yä¸ªï¼Œå¦‚æœé‡å¤çš„æ•°å­—æœ‰è¯¥ä½ï¼Œé‚£ä¹ˆx>yã€‚ä¸‹é¢è¯æ˜è¿™ä¸ªæ€§è´¨ã€‚
å¦‚æœåªæœ‰é‡å¤çš„æ•°å­—ï¼Œé‚£ä¹ˆé‡å¤æ•°å­—å¯¹åº”ç¬¬iä½çš„x=y+1ï¼Œéå¯¹åº”ä½æ»¡è¶³x=y
å¦‚æœæœ‰é‡å¤çš„æ•°å­—targetå’Œç¼ºå¤±çš„æ•°å­—jï¼Œå¯ä»¥ç†è§£æˆtargetæ›¿ä»£äº†è¿™äº›æ•°å­—ï¼Œåˆ†æƒ…å†µè®¨è®ºï¼štargetå’Œjçš„ç¬¬iä½åŒä¸º1ï¼Œé‚£ä¹ˆx=y+1ï¼›targetç¬¬iä½ä¸º1ï¼Œjçš„ç¬¬iä½ä¸º0ï¼Œé‚£ä¹ˆx=y+2ï¼›targetå’Œjçš„ç¬¬iä½åŒä¸º0ï¼Œx=yï¼›targetç¬¬iä½ä¸º0ï¼Œjçš„ç¬¬iä½ä¸º1ï¼Œé‚£ä¹ˆx=y-1ï¼Œæ‰€ä»¥é‡å¤æ•°å­—targetå¯¹åº”çš„ä½æ»¡è¶³x>yï¼Œéå¯¹åº”ä½x<=y

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        bitmax = 0
        n = len(nums)-1
        while n>>bitmax:
            bitmax+=1
        res = 0
        for bit in range(bitmax):
            x, y = 0, 0
            for i in range(n+1):
                x += 1&nums[i]>>bit
                y += 1&i>>bit
            if x>y:
                res = res | 1<<bit
        return res
```

æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆ

å®šä¹‰f(i)=nums[i ]å³i-->nums[i ]ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ä»0å¼€å§‹ï¼Œä¸€å®šå¯ä»¥å¾—åˆ°ä¸€æ¡æœ‰å…¥å£çš„ç¯(2-3-4-3ä¸ºæœ‰å…¥å£çš„ç¯ä¸”å…¥å£ä¸º3ï¼Œ2-3-2ä¸ºæ— å…¥å£çš„ç¯)ï¼Œå¹¶ä¸”ç¯çš„å…¥å£ä¸ºé‡å¤å…ƒç´ ã€‚

æ•°ç»„ä¸­çš„é‡å¤å…ƒç´ çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼šnums[i ]==nums[j ], ä¸”i!=j.

ç¬¬ä¸€æ­¥ï¼šè¯æ˜ä»0å¼€å§‹ï¼Œä¸€å®šå¯ä»¥å¾—åˆ°ä¸€æ¡æœ‰å…¥å£çš„ç¯ã€‚
$0->x_0->f(x_0)->f^2(x_0)->...->f^n(x_0) == 0->x_0->x_1->...->x_n$ï¼Œå› ä¸ºåªæœ‰1~nçš„nä¸ªæ•°å­—ï¼Œæ‰€ä»¥{x_0,....,x_n}ä¸€å®šå­˜åœ¨é‡å¤çš„å…ƒç´ ï¼Œä¸å¦¨å‡è®¾x_i==x_j(i!=j)ä¸ºç¬¬ä¸€ä¸ªé‡å¤çš„å…ƒç´ ï¼Œæ˜¾ç„¶x_iä¸å¯èƒ½ç­‰äº0ï¼Œæœ‰$0->x_0->x_1->...->x_i->...->x_{j-1}-->x_i$

ç¬¬äºŒæ­¥ï¼šè¯æ˜ç¯çš„å…¥å£ä¸ºæ‰€æ±‚çš„é‡å¤å…ƒç´ 
å¯¹äºç¯çš„å…¥å£x_iï¼Œæœ‰nums[x_{i-1 ]=x_i, nums[x_{j-1 }]=x_iï¼Œæ˜¾ç„¶i!=jä¸”x_{i-1}!=x_{j-1}ï¼Œé‚£ä¹ˆx_iå³ä¸ºæ‰€æ±‚çš„é‡å¤å…ƒç´ ã€‚

ç¬¬ä¸‰æ­¥ï¼šè¯æ˜åªæœ‰ä»0å¼€å§‹ï¼Œæ‰èƒ½å¾—åˆ°ä¸€æ¡æœ‰å…¥å£çš„ç¯ã€‚
åè¯æ³•ï¼šå¯¹äºå…¶ä»–æ•°å­—ï¼Œéƒ½å¯ä»¥ä»¤nums[i]=iï¼Œå¾—åˆ°æ— å…¥å£çš„ç¯
0ä¹‹æ‰€ä»¥ç‰¹æ®Šæ˜¯å› ä¸ºæ•°å­—æ˜¯1~nï¼Œåä¹‹ï¼Œå¦‚æœæ•°å­—æ˜¯0~n-1ï¼Œé‚£ä¹ˆå°±åº”è¯¥ä»nå¼€å§‹ï¼Œå¾—åˆ°æœ‰å…¥å£çš„ç¯ã€‚

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow!=fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        slow = 0
        while slow!=fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

## 288	å•è¯çš„å”¯ä¸€ç¼©å†™

```python
from collections import defaultdict
class Solution():
    def __init__(self, dictionary):
        self.word = defaultdict(list)
        for word in dictionary:
            s = self.get_key(word)
            self.word[s].append(word)
  

    def get_key(self, word):
        res = word[0]+str(len(word))+word[-1]
        return res
  
    def isUnique(self, word):
        s = self.get_key(word)
        return not self.word[s] or (word in self.word[s] and len(self.word[s])==1)
```

## 289. ç”Ÿå‘½æ¸¸æˆ

æ–¹æ³•ï¼šåŒbitä½
è¦æ±‚åªèƒ½åŸåœ°æ”¹å˜æ•°ç»„å…ƒç´ ï¼ŒO(1)çš„ç©ºé—´å¤æ‚åº¦
æ‰€ä»¥ä½¿ç”¨åŒbitä½è¡¨ç¤ºæ•°ç»„çš„åŸå€¼å’Œæ›´æ–°åçš„å€¼

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        n, m = len(board), len(board[0])
        def get_neighbors(i, j):
            dx = [-1, 0, 1, -1, 1, -1, 0, 1]
            dy = [-1, -1, -1, 0, 0, 1, 1, 1]
            res = 0
            for k in range(8):
                x = i+dx[k]
                y = j+dy[k]
                if (-1<x<n) and (-1<y<m) and (board[x][y]&1==1):
                    res+=1
            return res
        for i in range(n):
            for j in range(m):
                live_neighbors = get_neighbors(i, j)
                if board[i][j]==1 and (2<=live_neighbors<=3):
                    board[i][j] = board[i][j]|2
                elif board[i][j]==0 and (live_neighbors==3):
                    board[i][j] = board[i][j]|2
        for i in range(n):
            for j in range(m):
                board[i][j] = board[i][j]>>1
```

## 290. å•è¯è§„å¾‹

False: åŒä¸€ä¸ªå­—æ¯å¯¹åº”çš„å•è¯ä¸ä¸€æ ·æˆ–è€…åŒä¸€ä¸ªå•è¯å¯¹åº”çš„å­—æ¯ä¸ä¸€æ ·

æ–¹æ³•ä¸€ï¼šå»ºç«‹patternåˆ°strçš„æ˜ å°„å’Œstråˆ°patternçš„æ˜ å°„, map1, map2

æ–¹æ³•äºŒï¼šå»ºç«‹patternåˆ°123çš„æ˜ å°„å’Œstråˆ°123çš„æ˜ å°„ï¼Œåˆ¤æ–­æ˜ å°„åçš„å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰/æˆ–è€…ä¸€è¾¹æ˜ å°„ä¸€è¾¹åˆ¤æ–­æ˜¯å¦ç›¸ç­‰

abba-->1221
dog cat cat dog-->1221

```python
class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        strs = str.split()
        map1 = dict()
        map2 = dict()
        if len(strs)!=len(pattern):  
            return False
        n = len(strs)
        for i in range(n):
            if map1.get(pattern[i], -1)!=map2.get(strs[i], -1):
                return False
            map1[pattern[i]] = i
            map2[strs[i]] = i

        return True
```

## 291. å•è¯è§„å¾‹II

https://www.cnblogs.com/lightwindy/p/9736251.html

```python
class Solution():
    def wordPatternMatch(self, pattern, words):
        p2w = dict()
        w2p = dict()
        return self.wordPatternMatch2(pattern, words, 0, 0, p2w, w2p)

    def wordPatternMatch2(self, pattern, words, i, j, p2w, w2p):
        if i==len(pattern) and j==len(words):
            return True
        if i==len(pattern) or j==len(words):
            return False
        p = pattern[i]
        if p in p2w:
            w = p2w[p]
            if w!=words[j:j+len(w)]:
                return False
            return self.wordPatternMatch2(pattern, words, i+1, j+len(w), p2w, w2p)
        else:
            for k in range(j, len(words)):
                w = words[j:k+1]
                if w in w2p:
                    continue
                p2w[p], w2p[w] = w, p
                if self.wordPatternMatch2(pattern, words, i+1, k+1, p2w, w2p):
                    return True
                p2w.pop(p)
                w2p.pop(w)
        return False
```

## 294	ç¿»è½¬æ¸¸æˆ II

æ–¹æ³•ä¸€ï¼šå°è¯•æ‰€æœ‰çš„å¯èƒ½
æ—¶é—´å¤æ‚åº¦ï¼šO(n^{n/2})

```python
def run(string s):
    # å…ˆæ‰‹å­˜åœ¨èµ¢çš„ç­–ç•¥ï¼Œè¿”å›Trueï¼Œå¦åˆ™è¿”å›False
    n = len(s)
    for i in range(n-1):
        if s[i:i+2]=="+" and (not run(s[:i]+"--"+s[i+2:])):
            return True
    return False
```

æ–¹æ³•äºŒï¼šNimæ¸¸æˆ

https://zhuanlan.zhihu.com/p/52931007

ç»„åˆæ¸¸æˆICGï¼š

1. ä¸¤ä¸ªç©å®¶å…¬å¹³åœ°æ„æˆ
2. æ¸¸æˆæœ‰ä¸€ä¸ªçŠ¶æ€é›†åˆï¼Œè¡¨ç¤ºæ¸¸æˆè¿‡ç¨‹ä¸­çš„æ‰€æœ‰å¯èƒ½çŠ¶æ€ï¼Œé€šå¸¸æ˜¯æœ‰ç©·çš„
3. æ¸¸æˆçš„è§„åˆ™æè¿°äº†åœ¨æŸä¸ªçŠ¶æ€ä¸‹ç©å®¶ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€çš„åˆæ³•ç§»åŠ¨ï¼Œå¦‚æœè¯¥è§„åˆ™å¯¹ä¸¤ä¸ªç©å®¶æ˜¯ç›¸åŒçš„ï¼Œå°±æ˜¯impartialï¼Œå¦åˆ™å°±æ˜¯partizançš„
4. ç©å®¶äº¤æ›¿ç§»åŠ¨
5. å½“ç©å®¶ç§»åŠ¨åˆ°æŸä¸€ä¸ªçŠ¶æ€ï¼Œä¸‹ä¸€ä¸ªç©å®¶æ²¡æœ‰å¯è¡Œåœ°ç§»åŠ¨æ—¶ï¼Œæ¸¸æˆç»“æŸ
6. åœ¨é€šå¸¸çš„è§„åˆ™ä¸‹ï¼Œæœ€åä¸€ä¸ªç©å®¶è·èƒœ
7. æ±‚å…ˆæ‰‹å¿…èƒœç­–ç•¥

å¯¹äºä¸€ä¸ªæ¸¸æˆçŠ¶æ€ï¼Œå®šä¹‰

1. P-positionï¼šåœ¨è¯¥çŠ¶æ€ä¸‹ï¼Œä¸Šä¸€ä¸ªç©å®¶èƒ½å¤Ÿè·èƒœï¼Œæˆ–è€…è¯´å½“å‰ç©å®¶å¿…è´¥ï¼Œå³å…ˆæ‰‹å¿…è´¥
2. N-positionï¼šåœ¨è¯¥çŠ¶æ€ä¸‹ï¼Œä¸‹ä¸€ä¸ªç©å®¶èƒ½å¤Ÿè·èƒœï¼Œæˆ–è€…è¯´å½“å‰ç©å®¶å¿…èƒœï¼Œå³å…ˆæ‰‹å¿…èƒœ

å¯¹äºæ¸¸æˆçŠ¶æ€Pï¼ŒNï¼Œæœ‰ä»¥ä¸‹ä¸‰æ¡æ€§è´¨ï¼š

1. ç»ˆæ­¢çŠ¶æ€(ä¸Šä¸€ä¸ªç©å®¶ç§»åŠ¨ä¹‹åçš„çŠ¶æ€ï¼Œä¸‹ä¸€ä¸ªç©å®¶æ²¡æœ‰å¯è¡Œçš„ç§»åŠ¨ï¼Œå®£å¸ƒå¤±è´¥ç»ˆæ­¢)æ˜¯å…ˆæ‰‹å¿…è´¥ P-position
2. å¯¹äºæ¯ä¸€ä¸ª P-position, ä»»æ„ä¸€ä¸ªåˆæ³•çš„ç§»åŠ¨åçš„çŠ¶æ€æ˜¯ N-positionï¼Œå³å‡è®¾ç§»åŠ¨åæœ‰ä¸‰ç§çŠ¶æ€ï¼Œåˆ™ P-->(N, N, N)
3. å¯¹äºæ¯ä¸€ä¸ª N-positionï¼Œå­˜åœ¨ä¸€ä¸ªåˆæ³•çš„ç§»åŠ¨åçš„çŠ¶æ€æ˜¯ P-positionï¼Œå³å‡è®¾ç§»åŠ¨åæœ‰ä¸‰ç§çŠ¶æ€ï¼Œåˆ™ N-->(N, P, N)

Nimæ¸¸æˆï¼š

1. å‡è®¾æœ‰må †ç¢ç‰‡ï¼Œåˆ†åˆ«æ˜¯ x1, x2, ... xm
2. ä¸¤ä¸ªç©å®¶è½®æµå–ç¢ç‰‡ï¼Œæ¯æ¬¡å¿…é¡»ä»å…¶ä¸­çš„ä¸€å †è‡³å°‘å–ä¸€ä¸ªç¢ç‰‡ï¼Œè‡³å¤šä¸è¶…è¿‡é€‰æ‹©çš„å †
3. æœ€åä¸€ä¸ªå–ç¢ç‰‡çš„ç©å®¶è·èƒœ

Nim-Sumï¼š

(x1, x2, ... xm)æ˜¯ä¸€ä¸ªP-poså½“ä¸”ä»…å½“x1^ x2^ ...^ xm=0

æ›´ä¸€èˆ¬åœ°ï¼Œæˆ‘ä»¬å¼•å…¥ Graph Games.

Graph Gamesï¼šå°†æ¸¸æˆè½¬æ¢ä¸ºä¸€ä¸ªæœ‰å‘å›¾G(X, F)ï¼Œå…¶ä¸­ X è¡¨ç¤ºæ¸¸æˆä¸­æ‰€æœ‰çŠ¶æ€çš„é›†åˆï¼ŒFè¡¨ç¤ºçŠ¶æ€ä¹‹é—´çš„ç§»åŠ¨å…³ç³»ã€‚å¦‚æœå¯¹äºèŠ‚ç‚¹xï¼ŒF(x)æ˜¯ç©ºé›†ï¼Œé‚£ä¹ˆxå°±æ˜¯ä¸€ä¸ªç»ˆæ­¢èŠ‚ç‚¹

SG-å‡½æ•°ï¼šå®šä¹‰å›¾G(X, F)çš„SG-å‡½æ•°ä¸º$g(x)=min{n>=0: n!=g(y) for,y\in F(x)}=mex{g(y): y\in F(x)}$ï¼Œå³åœ¨éè´Ÿæ•´æ•°é›†åˆä¸­çš„ç¬¬ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚æ³¨æ„ g(x) æ˜¯é€’å½’å®šä¹‰çš„ï¼Œå¯¹ç»ˆæ­¢èŠ‚ç‚¹xï¼Œg(x)=0.

SG-å‡½æ•° g(x) æœ‰å¦‚ä¸‹æ€§è´¨ï¼š

1. xæ˜¯ç»ˆæ­¢èŠ‚ç‚¹ï¼Œåˆ™g(x)=0
2. g(x)=0ï¼Œé‚£ä¹ˆxçš„æ¯ä¸ªåç»­èŠ‚ç‚¹y, g(y)!=0,
3. g(x)!=0,é‚£ä¹ˆå­˜åœ¨xçš„ä¸€ä¸ªåç»§èŠ‚ç‚¹yï¼Œg(y)=0

> g(x)=0ï¼Œå¯¹åº”çš„çŠ¶æ€xæ˜¯P-pos(å…ˆæ‰‹å¿…è´¥)
> g(x)!=0ï¼Œå¯¹åº”çš„çŠ¶æ€æ˜¯N-pos(å…ˆæ‰‹å¿…èƒœ)

Sums of Combinatorial Gamesï¼šå³å‡ ä¸ªç»„åˆæ¸¸æˆåˆå¹¶ä¸€ä¸ªå¤§æ¸¸æˆ

1. ç©å®¶çš„ç§»åŠ¨å˜æˆï¼šé€‰æ‹©å…¶ä¸­ä¸€ä¸ªæœªç»ˆæ­¢çš„æ¸¸æˆï¼Œè¿›è¡Œä¸€æ¬¡åˆæ³•çš„ç§»åŠ¨
2. ç»ˆæ­¢çŠ¶æ€ä¸ºï¼šæ‰€æœ‰æ¸¸æˆéƒ½ç»ˆæ­¢äº†

The Sprague-Grundy Theoremï¼š å¯¹Sums of Combinatorial Gamesï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥æ±‚å‡ºçŠ¶æ€x=(x1, x2,...xn)çš„SG-å‡½æ•°

1. g(x) = g(x1)^ g(x2)^ ...^ g(xn)

ä¸¾ä¾‹è¯´æ˜æ€ä¹ˆä½¿ç”¨SGå‡½æ•°ã€‚

ä¾‹å­1ï¼šå–çŸ³å­é—®é¢˜ï¼Œæœ‰1å †nä¸ªçš„çŸ³å­ï¼Œæ¯æ¬¡åªèƒ½å–1ï¼Œ3ï¼Œ4ä¸ªçŸ³å­ï¼Œå…ˆå–å®Œè€…èƒœåˆ©ï¼Œé‚£ä¹ˆå„ä¸ªæ•°çš„SGå€¼æ˜¯å¤šå°‘ã€‚

x=0, sg[0]=0
x=1, å¯ä»¥å–èµ°ä¸€ä¸ªçŸ³å­ï¼Œsg[1] = mex{sg[0]}=mex{0}=1
x=2, å¯ä»¥å–èµ°ä¸€ä¸ªçŸ³å­ï¼Œsg[2] = mex{sg[1]}=mex{1}=0
x=3ï¼Œå¯ä»¥å–èµ°{1ï¼Œ3}ä¸ªçŸ³å­ï¼Œsg[3]=mex{sg[2], sg[0]}=mex{0, 0}=1
x=4ï¼Œå¯ä»¥å–èµ°{1,3,4}ä¸ªçŸ³å­ï¼Œsg[4]=mex{sg[3], sg[1], sg[0]}=mex{1,1,0}=2

ä»¥æ­¤ç±»æ¨:
x::::0, 1, 2, 3, 4, 5, 6,
sg:: 0, 1, 0, 1, 2, 3, 2,
P/N: P, N, P, N, N, N, N
Pæ˜¯å…ˆæ‰‹å¿…è´¥ï¼Œ Næ˜¯å…ˆæ‰‹å¿…èƒœ

ä¾‹å­2ï¼šå‡è®¾æœ‰nå †ç¢ç‰‡ï¼Œåˆ†åˆ«æ˜¯ x1, x2, ... xnï¼Œä¸¤ä¸ªç©å®¶è½®æµå–ç¢ç‰‡ï¼Œæ¯æ¬¡å¿…é¡»ä»å…¶ä¸­çš„ä¸€å †è‡³å°‘å–ä¸€ä¸ªç¢ç‰‡ï¼Œè‡³å¤šä¸è¶…è¿‡é€‰æ‹©çš„å †ï¼Œæœ€åä¸€ä¸ªå–ç¢ç‰‡çš„ç©å®¶è·èƒœ

æˆ‘ä»¬å¯ä»¥çœ‹æˆæ˜¯å¤šä¸ªç»„åˆæ¸¸æˆçš„åˆå¹¶ï¼Œå¯¹äºå…¶ä¸­ä¸€ä¸ªç»„åˆæ¸¸æˆï¼Œå³ä¸€å †ç¢ç‰‡xï¼Œæœ‰
x=0, g[0]=0
x=1, g[1]=mex{g[0]}=mex{0}=1
x=2, g[2]=mex{g[0], g[1]}=mex{0, 1}=2
...
x, g[x]=mex{g[0], g[1], ..., g[x-1]}=x
æ‰€ä»¥å¯¹äºä¸€ä¸ªç»„åˆæ¸¸æˆæœ‰g[x]=x
æ‰€ä»¥å¯¹äºå¤šä¸ªç»„åˆæ¸¸æˆæœ‰g[x]=g[x1]^ ... ^ g[xn]=x1^ ... xn

ä¾‹å­3ï¼šç¿»è½¬æ¸¸æˆ II ï¼šè¾“å…¥xä¸­å¯èƒ½å¸¦æœ‰-ï¼Œä»¤x=(x1, x2, ..., xn)ï¼Œå…¶ä¸­xiè¡¨ç¤ºè¿ç»­çš„+ï¼Œä¸”xiå’Œx(i+1)ä¸­é—´åªæœ‰è´Ÿå·ï¼Œæ˜¯nä¸ªç»„åˆæ¸¸æˆ(è¾“å…¥åªæœ‰è¿ç»­çš„+)çš„åˆå¹¶ï¼Œæ‰€ä»¥g(x)=g(x1)^ ... g(xn)

å¯¹äºå•ä¸ªç»„åˆæ¸¸æˆï¼Œæœ‰ï¼š
x=0, g[0]=0
x=1, g[1]=0
x=2, g[2]=mex{g[0]}=mex{0}=1
x=3, g[3]=mex{g[1]}=mex{0}=1
x=4, g[4]=mex{g[1]^ g[1], g[0]^ g[2]}=mex{0^ 0, 0^ 1}=2
...
x, g[x]=mex{g[0]^ g[x-2], g[1]^ g[x-3], ... g[x-2]^ g[0]}

```python
# https://zhuanlan.zhihu.com/p/30721019
def canWin(s):
    s = list(filter(None, s.split("-")))
    s = [len(val) for val in s]
    n = max(s)
    g = [0 for _ in range(n+1)]
    for i in range(2, n+1):
        mex = [False for _ in range(n+1)] # ç”¨äºè®°å½•mexé›†åˆ
        for j in range(0, i-1):
            mex[g[j]^g[i-j-2]]=True
        for j in range(i):
            if not mex[j]:
                g[i]=j
                break
    res = 0
    for val in s:
        res = res^g[val]
    return res!=0
```

## æ•°ç»„ä¸­æœªå‡ºç°çš„æœ€å°æ­£æ•´æ•°

https://www.cnblogs.com/stemon/p/4633854.html

```python
# å¼€è¾Ÿæ–°çš„æ•°ç»„
def demo(nums):
    new_nums = [0 for _ in range(len(nums))]
    for val in nums:
        new_nums[val-1]=val
    res = len(nums)
    for i, val in enumerate(new_nums):
        if val==0:
            res = i+1
            break
    return res

# åŸåœ°ä¿®æ”¹
def demo(nums):
    n = len(nums)
    i = 0
    while i<n:
        val = nums[i]
        if 0< val< n+1 and i+1!=val and nums[val-1]!=val:
            nums[i], nums[val-1] = nums[val-1], nums[i]
        else:
            i = i+1
    res = len(nums)
    for i, val in enumerate(nums):
        if val!=i+1:
            res = i+1
            break
    return res
```

## 295. æ•°æ®æµçš„ä¸­ä½æ•°

æ–¹æ³•ä¸€ï¼šå¤§é¡¶å †å’Œå°é¡¶å † O(lgn)

```python
import heapq
class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.count = 0
        self.max_h = []
        self.min_h = []

    def addNum(self, num: int) -> None:
        self.count+=1
        if self.count%2:
            heapq.heappush(self.min_h, num)
            num = heapq.heappop(self.min_h)
            heapq.heappush(self.max_h, (-num, num))
        else:
            heapq.heappush(self.max_h, (-num, num))
            _, num = heapq.heappop(self.max_h)
            heapq.heappush(self.min_h, num)
        return 

    def findMedian(self) -> float:
        if self.count%2:
            return self.max_h[0][1]
        else:
            return (self.max_h[0][1]+self.min_h[0])/2
```

æ–¹æ³•äºŒï¼šå¹³è¡¡äºŒå‰æœç´¢æ ‘ O(lg n)

https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/

å¹³è¡¡äºŒå‰æœç´¢æ ‘çš„æ’å…¥å’Œåˆ é™¤çš„å¤æ‚åº¦æ˜¯ O(lg n)ï¼Œä¸”æ˜¯æœ‰åºçš„ã€‚

```python
class MedianFinder {
    multiset<int> data;
    multiset<int>::iterator mid;

public:
    MedianFinder()
        : mid(data.end())
    {
    }

    void addNum(int num)
    {
        const int n = data.size();
        data.insert(num);

        if (!n)                                 // first element inserted
            mid = data.begin();
        else if (num < *mid)                    // median is decreased
            mid = (n & 1 ? mid : prev(mid));
        else                                    // median is increased
            mid = (n & 1 ? next(mid) : mid);
    }

    double findMedian()
    {
        const int n = data.size();
        return (*mid + *next(mid, n % 2 - 1)) * 0.5;
    }
};
```

## 296 æœ€ä½³çš„ç¢°å¤´åœ°ç‚¹

åœ¨ä¸€ç»´æƒ…å†µä¸‹ï¼Œæœ€ä½³ç¢°å¤´åœ°ç‚¹æ˜¯ä¸­ä½æ•°mid

å¦‚æœæ˜¯å¥‡æ•°ä¸ªäººï¼Œé‚£ä¹ˆæœ€ä½³åœ°ç‚¹å¾€å·¦æŒªä¸€ç‚¹ï¼Œmidå·¦è¾¹çš„äººçš„è·ç¦»å‡ä¸€ï¼Œæœ¬èº«åŠå³è¾¹çš„äººè·ç¦»åŠ ä¸€ï¼Œæ€»ä½“è·ç¦»åŠ ä¸€
å¦‚æœæ˜¯å¶æ•°ä¸ªäººï¼Œé‚£ä¹ˆæœ€ä½³åœ°ç‚¹å…¶å®æ˜¯n//2~n//2+1ä¸­çš„ä»»æ„ä¸€ä¸ªåœ°ç‚¹éƒ½è¡Œï¼Œå¦‚æœæœ€ä½³åœ°ç‚¹å¾€n//2å·¦è¾¹æŒªä¸€ç‚¹ï¼Œå·¦è¾¹äººè·ç¦»å‡1ï¼Œå³è¾¹è·ç¦»åŠ 1ï¼Œæ€»ä½“è·ç¦»åŠ 2ï¼Œåä¹‹äº¦ç„¶ã€‚

```python
class Solution {
public:
	int minTotalDistance(vector<vector<int>>& grid) {
		vector<int> vx;
		vector<int> vy;
		for (int x = 0; x < grid.size(); x++) {
			for (int y = 0; y < grid[x].size(); y++) {
				if (grid[x][y] > 0) {
					vx.push_back(x);
					vy.push_back(y);
				}
			}
		}
		sort(vy.begin(), vy.end());
		int mx = vx[vx.size() / 2];
		int my = vy[vy.size() / 2];

		int ans = 0;
		for (int x : vx) ans += abs(x - mx);
		for (int y : vy) ans += abs(y - my);
		return ans;
	}
};

```

## 297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–

å…ˆåºéå†

```java
public class Codec {
    public String rserialize(TreeNode root, String str) {
        if (root == null) {
            str += "None,";
        } else {
            str += str.valueOf(root.val) + ",";
            str = rserialize(root.left, str);
            str = rserialize(root.right, str);
        }
        return str;
    }
  
    public String serialize(TreeNode root) {
        return rserialize(root, "");
    }
  
    public TreeNode rdeserialize(List<String> l) {
        if (l.get(0).equals("None")) {
            l.remove(0);
            return null;
        }
  
        TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));
        l.remove(0);
        root.left = rdeserialize(l);
        root.right = rdeserialize(l);
  
        return root;
    }
  
    public TreeNode deserialize(String data) {
        String[] data_array = data.split(",");
        List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));
        return rdeserialize(data_list);
    }
}

```

## 300 æœ€é•¿ä¸Šå‡éè¿ç»­å­åºåˆ—

å•è°ƒæ ˆh[j] è®°å½•é•¿åº¦æ˜¯j+1çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ•°å­— h[j]: é€’å¢åºåˆ—, h[j] åˆå§‹åŒ–ä¸ºæ— ç©·å¤§
pos: h[pos-1]< arr[i] <= h[pos] å³ç¬¬ä¸€ä¸ªå¤§äºç­‰äºarr[i]çš„ä½ç½®
dp[i]: arr[i] å¯¹åº”çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦

```python
def upper_bound(h, k):
    if not h:
        return 0
    l, r = 0, len(h)-1
    res = len(h)
    # print(h, k)
    while l<=r:
        mid = (l+r)//2
        # print(mid)
        if h[mid]>k:
            res = mid
            r = mid-1
        elif h[mid]==k:
            return mid
        else:
            l = mid+1
    return res

def get_list(dp, arr, max_len):
    res = [0]*max_len
    for i in range(len(arr)-1, -1, -1):
        if max_len==0:
            break
        if dp[i]==max_len-1:
            res[max_len-1]=arr[i]
            max_len-=1
    return res
import bisect
def demo1(n, arr):
    h = list()
    dp = [0]*len(arr)
    for i in range(n):
        # pos = upper_bound(h, arr[i])
        pos = bisect.bisect_left(h, arr[i])
        if pos>=len(h):
            h.append(arr[i])
        else:
            h[pos] = arr[i]
        dp[i] = pos
    res = get_list(dp, arr, len(h))
    return res

if __name__=='__main__':
    n = int(input())
    arr = list(map(int, input().split()))
    res = demo1(n, arr)
    res_str = ' '.join(list(map(str, res)))
    print(res_str)
```

å³å¯¹äºå…ƒç´  arr[i]ï¼Œæ‰¾åˆ°åˆé€‚çš„ä½ç½® posï¼Œæ»¡è¶³ h[pos]>=arr[i]ï¼Œåšæ›¿æ¢æˆ–è€…å¢åŠ ï¼Œæ­¤æ—¶ï¼Œhæ˜¯å•è°ƒçš„ä¸”æ»¡è¶³é•¿åº¦æ˜¯j+1çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ•°å­—æ˜¯h[j]ï¼Œdpè¡¨ç¤ºå…ƒç´  arr[i] å¯¹åº”çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ€é•¿é•¿åº¦

ä¾‹å¦‚ï¼š2 1 5 3 6 4 8 9 7
h[j]:
2
1
1 5
1 3
1 3 6
1 3 4
1 3 4 8
1 3 4 8 9
1 3 4 7 9
é•¿åº¦ä¸º1çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ˜¯1
é•¿åº¦ä¸º2çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ˜¯3
é•¿åº¦ä¸º3çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ˜¯4
é•¿åº¦ä¸º4çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ˜¯7
é•¿åº¦ä¸º5çš„æœ€é•¿é€’å¢å­åºåˆ—çš„æœ«å°¾æ˜¯9

è¿™é‡Œæ²¡æœ‰ç›´æ¥å¼¹å‡ºè€Œæ˜¯é‡‡å–æ›¿æ¢çš„åŸå› æ˜¯ å½“arr[i]å¤§äºæœ€åä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæœ€é•¿é•¿åº¦åº”è¯¥å¢åŠ ï¼Œå¦‚æœå¼¹å‡ºçš„è¯ï¼Œå°±æ²¡æ³•ä½“ç°å¢åŠ çš„æ€§è´¨

å¯¹äº 2 3 1 4
h:
2
2 3
1 3
1 3 4
è¿™é‡Œçš„3ä¼šå¯¹4äº§ç”Ÿå½±å“ï¼Œåº”è¯¥ä¿ç•™

å…¶ä»–è§£æ³•ï¼š

1. æ’åºï¼Œæ±‚å…¬å…±å­åºåˆ— O(n_2)
2. h[j] = max(h[i])+1, arr[i]<=arr[j] O(n_2)

## 301. åˆ é™¤æ— æ•ˆçš„æ‹¬å·

BFSï¼šæ¯æ¬¡å°è¯•åˆ é™¤ä¸€ä¸ªæ‹¬å·ï¼Œå› ä¸ºæœ€é•¿çš„åˆæ³•æ‹¬å·çš„é•¿åº¦éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ—¶é—´ O(n^m) nè¡¨ç¤ºè¾“å…¥é•¿åº¦ï¼Œmè¡¨ç¤ºæ— æ•ˆæ‹¬å·æ•°é‡ï¼Œç©ºé—´n^m

```python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        def is_valid(string):
            cnt = 0
            for s in string:
                if s=="(":
                    cnt+=1
                elif s==")":
                    cnt-=1
                if cnt<0:
                    return False
            return cnt==0
        que = {s}
        while que:
            que = list(filter(is_valid, que))
            print(que)
            if que:
                return que
            que = set([ val[:i]+val[i+1:] for val in que for i in range(len(val)) if val[i] in "()"])
        return [""]
```

## 302 åŒ…å«å…¨éƒ¨é»‘è‰²åƒç´ çš„æœ€å°çŸ©å½¢

An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.

For example, given the following image:

[
  "0010",
  "0110",
  "0100"
]
and x = 0, y = 2,

Return 6.

é»‘è‰²åƒç´ ä¸€å®šç›¸é‚»

æ–¹æ³•ä¸€ï¼šæš´åŠ›æœç´¢
æ‰¾åˆ°æœ€å·¦ã€æœ€å³ã€æœ€ä¸Šã€æœ€ä¸‹è¾¹ç•Œ

```java
class Solution {
public:
    int minArea(vector<vector<char>>& image, int x, int y) {
        int left = y, right = y, up = x, down = x;
        for (int i = 0; i < image.size(); ++i) {
            for (int j = 0; j < image[i].size(); ++j) {
                if (image[i][j] == '1') {
                    left = min(left, j);
                    right = max(right, j);
                    up = min(up, i);
                    down = max(down, i);
                }
            }
        }
        return (right - left + 1) * (down - up + 1);
    }
};
```

æ–¹æ³•äºŒï¼šäºŒåˆ†æœç´¢
æœ€å·¦è¾¹ç•Œä¸€å®šåœ¨yçš„å·¦è¾¹ï¼ŒäºŒåˆ†æœç´¢yçš„å·¦è¾¹ï¼Œå¦‚æœå·¦è¾¹æŸä¸€åˆ—æœ‰1ï¼Œé‚£ä¹ˆè¯¥åˆ—å°±å¯èƒ½æ˜¯å·¦è¾¹ç•Œ

æˆ‘ä»¬å†æ¥çœ‹ä¸€ç§ä¼˜åŒ–äº†æ—¶é—´å¤æ‚åº¦çš„è§£æ³•ï¼Œè¿™æ˜¯ä¸€ç§äºŒåˆ†æœç´¢æ³•ï¼Œä»¥ç»™å®šçš„ä¸€ä¸ªé»‘åƒç´ (x, y)ä¸ºä¸­å¿ƒï¼Œåˆ†åˆ«ç”¨äºŒåˆ†æ³•å¿«é€Ÿæ‰¾åˆ°æ•´ä¸ªé»‘è‰²åŒºåŸŸçš„ä¸Šä¸‹å·¦å³çš„ä¸´ç•Œç‚¹ï¼Œç„¶åç›´æ¥ç®—å‡ºé¢ç§¯ã€‚é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸Šè¾¹ç•Œæ€ä¹ˆæ‰¾ï¼Œæ—¢ç„¶æ˜¯ä»¥(x, y)ä¸ºä¸­å¿ƒï¼Œè€Œä¸”ä¸Šè¾¹ç•Œåˆæ˜¯æŸä¸ªè¡Œæ•°ï¼Œé‚£ä¹ˆå…¶èŒƒå›´è‚¯å®šåœ¨[0, x]ä¹‹é—´ï¼Œèƒ½æˆä¸ºä¸Šè¾¹ç•Œçš„æ¡ä»¶æ˜¯è¯¥è¡Œä¸­è‡³å°‘æœ‰ä¸€ä¸ªç‚¹æ˜¯1ï¼Œé‚£ä¹ˆå…¶åˆ—æ•°çš„èŒƒå›´å°±åœ¨[0, n]ä¹‹é—´ï¼Œæˆ‘ä»¬åœ¨è¿›è¡ŒäºŒåˆ†æœç´¢çš„æ—¶å€™ï¼Œå…ˆæ ¹æ®i, jç®—å‡ºä¸­é—´è¡Œmidï¼Œç„¶ååˆ—æ•°ä»0å¼€å§‹éå†ï¼Œç›´åˆ°æ‰¾åˆ°ä¸º1çš„ç‚¹ï¼Œæˆ–è€…è¶Šç•Œä½ç½®ï¼Œç„¶åæˆ‘ä»¬åˆ¤æ–­åˆ—æ•°æ˜¯å¦è¶Šç•Œï¼Œè¶Šç•Œçš„è¯ï¼Œè¯´æ˜å½“å‰è¡Œæ²¡æœ‰1ï¼Œæ­¤æ—¶æ›´æ–°iä¸ºmid+1ï¼Œå¦‚æœæ‰¾åˆ°äº†1ï¼Œé‚£ä¹ˆæ›´æ–°jä¸ºmidã€‚æ‰¾ä¸‹è¾¹ç•Œä¹Ÿæ˜¯åŒæ ·çš„é“ç†ï¼Œä½†æ˜¯è·Ÿä¸Šè¾¹ç•Œç¨å¾®åˆäº›ä¸åŒçš„åœ°æ–¹æ˜¯ï¼Œå¦‚æœå½“å‰è¡Œæ‰¾åˆ°äº†1ï¼Œæˆ‘ä»¬åº”è¯¥å†å¾€ä¸‹æ‰¾ï¼Œé‚£ä¹ˆiåº”è¯¥æ›´æ–°ä¸ºmid+1ï¼›å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°±åº”è¯¥å¾€ä¸Šæ‰¾ï¼Œé è¿‘(x, y)ç‚¹ï¼›æ‰€ä»¥ä¸¤ç§æƒ…å†µåªæ˜¯åœ¨äºŒåˆ†æ³•æ›´æ–°èŒƒå›´çš„åœ°æ–¹æ­£å¥½æƒ³æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªboolå‹çš„å˜é‡optæ¥å†³å®šè¿˜å¦‚ä½•æ›´æ–°è¡Œæ•°ã€‚

äºŒåˆ†æœç´¢æ›´æ–°ï¼šåœ¨æ‰¾ä¸Šä¸‹è¾¹ç•Œæ—¶ï¼Œæ˜¯image[mid][k]ï¼Œå·¦å³è¾¹ç•Œæ—¶ï¼Œæ˜¯image[k][mid]ï¼Œç”¨hè¡¨ç¤ºæ˜¯ä¸Šä¸‹è¾¹ç•Œè¿˜æ˜¯å·¦å³è¾¹ç•Œ
åœ¨æ‰¾ä¸Šã€å·¦è¾¹ç•Œæ—¶ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°1ä¸”posiä¸ºçœŸï¼Œåˆ™i=mid+1ï¼›ä¸‹ã€å³è¾¹ç•Œæ—¶ï¼Œå¦‚æœæ‰¾åˆ°1ï¼Œä¸”posiä¸ºå‡ï¼Œåˆ™i=mid+1ï¼Œç”¨posiè¡¨ç¤ºä¸Šã€å·¦è¿˜æ˜¯ä¸‹ã€å³

```python
def minArea(image, x, y):
    n, m = len(image), len(image[0])
  
    def binary_search(ho, i, j, low, high, ):
        res = 0
        while i<=j:
            mid = (i+j)//2
            k = low
            while k<high and ((h and image[mid][k]=="0") or ((not h) and image[k][mid]=="0")):
                k = k+1
            if k<high ^ posi:
                res = mid
                i = mid+1
            else:
                j = mid-1
        return res     

    up = binary_search(True, 0, x, 0, m, True))
    down = binary_search(True, x, n-1, 0, m, False))
    left = binary_search(False, 0, y, 0, n, True))
    right = binary_search(False, y, m-1, 0, n, False))

    return (down-up+1)*(right-left+1)
```

## 305 å²›å±¿æ•°é‡ II

å¹¶æŸ¥é›†

```python
class Union():
    def __init__(self, m, n):
        self.parent = [[(-1, -1) for _ in range(n)] for _ in range(m)]
        self.rank = [[0 for _ in range(n)] for _ in range(m)]
  
    def find(self, node):
        x, y = node
        if self.parent[x][y]!=(x, y):
            self.parent[x][y] = self.find(self.parent[x][y])
        return self.parent[x][y]
  
    def merge(self, node1, node2):
        x1, y1 = self.find(node1)
        x2, y2 = self.find(node2)
        if (x1, y1)==(x2, y2):
            return False
        if self.rank[x1][y1]==self.rank[x2][y2]:
            self.parent[x2][y2] = (x1, y1)
            self.rank[x1][y1] += 1
        elif self.rank[x1][y1]<self.rank[x2][y2]:
            self.parent[x2][y2] = (x1, y1)
        else:
            self.parent[x1][y1] = (x2, y2)
        return True
```

```python
class Solution():
    def numIslands2(self, m, n, positions):
        nn = m*n
        uni = Union(m, n)
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        res = list()
        cnt = 0
        def in_area(x, y):
            return -1<x<m and -1<y<n

        def merge_dirs(x, y):
            res = 0
            for dx, dy in dirs:
                new_x, new_y = x+dx, y+dy
                if in_area(new_x, new_y) and uni.parent[new_x][new_y]!=(-1, -1) and uni.merge((x, y), (new_x, new_y)):
                    res+=1
            return res
        for x, y in positions:
            print(x, y)
            print(uni.parent)
            cnt+=1
            if uni.parent[x][y]!=(-1, -1):
                res.append(cnt)
                continue
            uni.parent[x][y] = (x, y)
            cnt-=merge_dirs(x, y)
            res.append(cnt)
        return res
```

## 306 ç´¯åŠ æ•°

dfs(i, j, k): i, j, kåˆ†åˆ«æ˜¯ä¸‰ä¸ªæ•°çš„å¼€å§‹ä½ç½®ï¼Œè‡ªç„¶å¯ä»¥ç¡®å®šä¸‰ä¸ªæ•°çš„ç»“æŸä½ç½®ã€‚

```python
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        i = 0
        for j in range(i+1, n):
            for k in range(j+1, n ):
                if self.dfs(num, i, j, k):
                    return True
        return False

    def dfs(self, num, i, j, k):
        n = len(num)
        if j-i>1 and num[i]=="0":
            return False
        if k-j>1 and num[j]=="0":
            return False
        if k==n:
            return True
        sum_ij = str(int(num[i:j])+int(num[j:k]))
        dk = len(sum_ij)
        if k+dk<=n and num[k:k+dk]==sum_ij:
            return self.dfs(num, j, k, k+dk)
        return False
```

## æœ€çŸ­è·ç¦» Dijkstra ç®—æ³•

Dijkstraç®—æ³•ï¼š

1. åœ¨æœªè®¿é—®ç‚¹é›†åˆä¸­æ‰¾å‡ºæœ€çŸ­ç‚¹
2. æ ¹æ®æœ€çŸ­ç‚¹æ›´æ–°æœªè®¿é—®ç‚¹é›†åˆä¸­çš„å…¶ä»–ç‚¹
3. æœ€åè®°å½•çš„æ˜¯æºç‚¹såˆ°å…¶ä»–ç‚¹çš„æƒé‡

O(E log V)

```python
import heapq
import sys
class Solution():
    def maxProbability(self, n: int, edges, succProb, start: int, end: int) -> float:
        e = [[] for _ in range(n)] # é‚»æ¥è¡¨
        visited = [0 for _ in range(n)] # è®°å½•å·²è®¿é—®ç‚¹å’Œæœªè®¿é—®ç‚¹
        dis = [sys.maxsize for _ in range(n)] # è®°å½•æ¯ä¸ªç‚¹çš„æƒé‡

        for (node1, node2), p in zip(edges, succProb):
            e[node1].append((node2, p))
            e[node2].append((node1, p))
    
        q = [(1.0, start)]
        heapq.heapify(q)
        dis[start] = 1.0
        while q:
            p, node = heapq.heappop(q)
            if visited[node]:
                continue
            visited[node] = 1
            for next_node, next_e_p in e[node]:
                if not visited[next_node]:
                    dis[next_node] = min(dis[next_node], dis[node]+next_e_p)
                    heapq.heappush(q, (dis[next_node], next_node))
        return dis[end]
```

## 1515. æœåŠ¡ä¸­å¿ƒçš„æœ€ä½³ä½ç½®

æ•°å­¦è¯æ˜è¿‡ç¨‹ï¼šhttps://leetcode-cn.com/problems/best-position-for-a-service-centre/solution/shu-xue-zheng-ming-by-acw_wangdh15/

è·ç¦»æ˜¯ä¸ªå‡¸å‡½æ•°

æ–¹æ³•ä¸€ï¼šä¸‰åˆ†æ³•

[l, r]=>[l, m1, m2, r]:
f(m1)< f(m2)ï¼šåˆ™æœ€ä¼˜å€¼ä¸€å®šä¸åœ¨(m2, r]ï¼Œä»¤r=m2
f(m1)> f(m1): åˆ™æœ€ä¼˜å€¼ä¸€å®šä¸åœ¨[l, m1)ï¼Œä»¤l=m1

```python
# å†™æ³•ä¸€
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        eps = 10**(-6)
        def dis(mx, my):
            return sum([((mx-x)**2+(my-y)**2)**0.5 for x, y in positions])

        def cal_my(mx):
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                if dis(mx, m1)<dis(mx, m2):
                    r = m2
                else:
                    l = m1
            res = (l+r)/2
            return res

        def cal_mx():
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                y1 = cal_my(m1)
                y2 = cal_my(m2)
                if dis(m1, y1)<dis(m2, y2):
                    r = m2
                else:
                    l = m1
            mx = (l+r)/2
            my = cal_my(mx)
            # print(mx, my)
            return dis(mx, my)
        return cal_mx()

# å†™æ³•äºŒ
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        def dis(mx, my):
            return sum([((mx-x)**2+(my-y)**2)**0.5 for x, y in positions])

        def three_divide(l=0, r=100, f=None, eps=10**(-6)):
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                if f(m1) < f(m2):
                    r = m2
                else:
                    l = m1
            res = (l+r)/2
            return res
    
        def xf(x):
            def yf(y):
                return dis(x, y)
            my = three_divide(f=yf)
            return dis(x, my)

        mx = three_divide(f=xf)
        my = three_divide(f=lambda y:dis(mx, y))
        return dis(mx, my)

# å†™æ³•äºŒæ‰©å±•
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        def dis(mx, my, mz):
            pass

        def three_divide(l=0, r=100, f=None, eps=10**(-6)):
            pass

        def xf(x):
            def yf(y):
                def zf(z):
                    return dis(x, y, z)
                global mz
                mz = three_divide(f=zf)
                return dis(x, y, mz)
            my = three_divide(f=yf)
            return dis(x, my, mz)

        mx = three_divide(f=xf)
        my = three_divide(f=lambda y:dis(mx, y))
        return dis(mx, my)
```

## æ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘ã€å¼€æ ¹å·åˆ†å—

æ ‘çŠ¶æ•°ç»„ï¼šæ±‚å‰ç¼€å’Œï¼Œå¥½å†™ï¼Œä¸”æ—¶é—´å¤æ‚åº¦çš„ç³»æ•°ä½ï¼Œç©ºé—´å° n
çº¿æ®µæ ‘ï¼šæ±‚åŒºé—´å’Œï¼Œæ›´å…¨é¢ï¼Œç©ºé—´ 4nï¼šæ ‘çŠ¶æ•°ç»„èƒ½å†™çš„çº¿æ®µæ ‘éƒ½èƒ½å†™ï¼Œä½†çº¿æ®µæ ‘èƒ½å†™çš„æ ‘çŠ¶æ•°ç»„ä¸ä¸€å®šèƒ½å†™
å¼€æ ¹å·åˆ†å—å…¨èƒ½
å¤šç»´æƒ…å†µæ—¶ æ ‘çŠ¶æ•°ç»„æ›´å¥½ç”¨

æ“ä½œåˆ†ä¸ºï¼šå•ç‚¹ä¿®æ”¹+åŒºé—´æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹+å•ç‚¹æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹+åŒºé—´æŸ¥è¯¢

### æ ‘çŠ¶æ•°ç»„

å‚è€ƒé“¾æ¥ï¼š

https://blog.csdn.net/bestsort/article/details/80796531

ä¿®æ”¹å’ŒæŸ¥è¯¢çš„å¤æ‚åº¦æ˜¯O(lgn)
åŸæ•°ç»„Aå’Œè¾…åŠ©æ•°ç»„Céƒ½æ˜¯ä»1å¼€å§‹è®¡æ•°

é¦–å…ˆç†æ¸…å‡ ä¸ªå…¬å¼ï¼š

å¯¹äºC[i]ï¼Œiçš„æœ€å·¦è¾¹æœ‰å‡ ä¸ª0ï¼Œå°±åœ¨ç¬¬å‡ å±‚

C[1] = A[1]
C[2] = A[1]+A[2]
C[3] = A[3]
C[4] = A[1]+A[2]+A[3]+A[4]
C[i] = A[i-2^k+1]+A[i-2^k+2]...+A[i] å…¶ä¸­kè¡¨ç¤ºiçš„äºŒè¿›åˆ¶ä»ä½ä½å‘é«˜ä½æ•°ï¼Œç¬¬ä¸€ä¸ª1æ‰€åœ¨çš„ä½ç½®ï¼Œ2^k=i&-i

C[i] çš„çˆ¶èŠ‚ç‚¹æ˜¯ C[j]:j=i+i&-i
è¯æ˜ï¼šC[j]=A[j-2^(k_j)+1]+...+A[j], C[i]=A[i-2^(k_i)+1]+...+A[i]ï¼Œj=i+i&-iï¼Œæ˜¾ç„¶j>iï¼Œå…¶æ¬¡è¯æ˜j-2^(k_j)+1< i-2^(k_i)+1ï¼Œj-2^(k_j)+1- (i-2^(k_i)+1)=i&-i+2^(k_i)-2^(k_j)=2^(k_i+1)-2^(k_j)ï¼Œä¸å¦¨å‡è®¾i=010æˆ–è€…110ï¼Œåˆ™i&-i=010ï¼Œj=100æˆ–è€…1000ï¼Œæ˜¾ç„¶jæ˜¯i&-iè‡³å°‘å·¦ç§»ä¸€ä½ï¼Œ2^(k_j)>=2^(k_i+1)ï¼Œæ‰€ä»¥j-2^(k_j)+1<= i-2^(k_i)+1ï¼Œæ‰€ä»¥C[i] çš„çˆ¶èŠ‚ç‚¹æ˜¯ C[j]:j=i+i&-i

C[j] çš„å­èŠ‚ç‚¹æ˜¯ C[i]: i={j-2^0, j-2^1, j-2^2, ...j-2^(k_j-1)}
è¯æ˜ï¼šä¸å¦¨å‡è®¾j=1000, åˆ™ i={0111, 0110, 0100,}åˆ™i=j-1=0111,i+i&-i=1000, i=j-2=0110, i+i&~i=1000, ..., å¾—è¯

sum[i]=C[i]+sum[i-i&(-i)]ï¼Œå…¶ä¸­C[0]=0
è¯æ˜: sum[i]=A[1]+...+A[i]=A[1]+...+A[i-i&(-i)]+A[i-i&(-i)+1]+...+A[i]=A[1]+...+A[i-i&(-i)]+C[i]=sum[i-i&(-i)]+C[i]
æ‰€ä»¥sum[i]=C[i]+sum[i-i&(-i)]

ç»¼ä¸Šæ‰€è¿°ï¼š

1. C[i] = sum( A[i-2^k+1, ..., i]  )
2. sum[i] = C[i] + sum[i-2^k ]

```python
class Solution():
    def __init__(self, arr):
        # å‡è®¾Aå’ŒCéƒ½æ˜¯ä»1å¼€å§‹è®¡æ•°
        self.A = arr
        self.n = len(arr)
        self.C = [0 for _ in range(n)]
        self.build(arr)

    def lowbit(self, x):
        return x&(-x)
  
    def build(self, arr):
        # åˆå§‹åŒ–
        for i in range(1, self.n):
            self.update(i, arr[i])
        return 

    # 1. å•ç‚¹æ›´æ–°ï¼ŒåŒºé—´æŸ¥è¯¢
    def update(self, i, x):
        # å•ç‚¹æ›´æ–°ï¼Œä»å¶å­èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ï¼ŒåŒæ—¶å¯ä»¥ç”¨äºåˆå§‹åŒ–
        # self.arr[i] += x
        while i<self.n:
            self.C[i]+=x
            i = i+lowbit(i)
        return 
  
    def getsum(self, i):
        # åŒºé—´æŸ¥è¯¢ï¼šarr[1,2...i]
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
    def getRangeSum(self, left, right):
        # [left, right]
        return self.getsum(right) - self.getsum(left-1)
    # 2. åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢
    # å·®åˆ†ï¼šä»¤B[i]=A[i]-A[i-1]ï¼ŒA[0]=0ï¼Œåˆå§‹åŒ–ç•¥å¾®ä¸åŒï¼ŒC[i]è¡¨ç¤ºB[i]çš„å‰ç¼€å’Œ
    # å•ç‚¹æŸ¥è¯¢A[i]ç­‰ä»·äºsum[B[1, ..., i]]å‰ç¼€å’Œï¼Œå³åŒºé—´æŸ¥è¯¢
    # åŒºé—´ä¿®æ”¹A[l, ..., r]+=val, ç­‰ä»·äº C[l]+=val, C[r+1]-=valï¼Œå³å•ç‚¹ä¿®æ”¹
    def build2(self, arr):
        # åˆå§‹åŒ–ç•¥å¾®ä¸åŒ
        for i in range(1, self.n):
            self.update(i, arr[i]-arr[i-1])

    def update2_(self, i, x):
        # å•ç‚¹æ›´æ–°ï¼Œä»å¶å­èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ï¼ŒåŒæ—¶å¯ä»¥ç”¨äºåˆå§‹åŒ–
        # self.arr[i] += x
        while i<self.n:
            self.C[i]+=x
            i = i+lowbit(i)
        return 

    def update2(self, l, r, x):
        # åŒºé—´ä¿®æ”¹ï¼šA[l, ..., r]+=x, æ ¹æ®å®šä¹‰C[i]=A[i]-A[i-1]ï¼Œç­‰ä»·äº C[l]+=val, C[r+1]-=valï¼Œå³å•ç‚¹ä¿®æ”¹
        self.update(l, x)
        if r+1<self.n:
            self.update2_(r+1, -x)
  
    def getsum2(self, i):
        # å•ç‚¹æŸ¥è¯¢ A[i]=sum(B[1, ...,i])
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
  
    # 3. åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢
    # å…¬å¼æ¨å¯¼è§é“¾æ¥ https://blog.csdn.net/bestsort/article/details/80796531
    # B1[i] = A[i]-A[i-1], B2[i]=B1[i]*i, C1[i]æ˜¯B1[i]çš„å‰ç¼€å’Œ, C2[i] = B2[i]çš„å‰ç¼€å’Œ
    # sum[p] = (p+1)*sum[B1[1...p]]-sum[B2[1,...i]]
    def build3(self, arr):
        for i in range(self.n):
            self.update3(i, arr[i])

    def update3_(self, i, x):
        # å•ç‚¹æ›´æ–°ï¼Œä»å¶å­èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ï¼ŒåŒæ—¶å¯ä»¥ç”¨äºåˆå§‹åŒ–
        # self.B[i] += x
        while i<self.n:
            self.C1[i]+=x
            self.C2[i]+=i*x
            i = i+lowbit(i)
        return
  
    def update3(self, l, r, x):
        # åŒºé—´æ›´æ–°ï¼Œarr[l, ..., r]+=x
        # B[i] = A[i]-A[i-1]ï¼Œæ‰€ä»¥B[l]+=x, B[r+1]-=x
        self.update3_(l, x)
        if r+1<self.n:
            self.update3_(r+1, x)
  
    def getsum3(self, i):
        # åŒºé—´æŸ¥è¯¢: arr[1,2,...x]
        res=0
        p=i
        while i>0:
            res+=(p+1)*self.C1[i]-self.C2[i]
        return res

    def getsum(self, i):
        # åŒºé—´æŸ¥è¯¢ï¼šarr[1,2...x]
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
```

æ€»ç»“ä¸ºï¼šåŒºé—´ä¿®æ”¹ç”¨å·®åˆ†ï¼Œå•ç‚¹ä¿®æ”¹ç”¨çœŸå€¼ï¼›ä¿®æ”¹ç”¨åŠ (i&-i)ï¼ŒæŸ¥è¯¢ç”¨å‡(i&-i)

æœ‰å…³äºŒç»´çŸ©é˜µçš„æ ‘çŠ¶æ•°ç»„çš„ä½¿ç”¨ç±»ä¼¼

https://blog.csdn.net/bestsort/article/details/80796531

```python
# å•ç‚¹ä¿®æ”¹+åŒºé—´æŸ¥è¯¢
void add(int x, int y, int z){ //å°†ç‚¹(x, y)åŠ ä¸Šz
    int memo_y = y;
    while(x <= n){
        y = memo_y;
        while(y <= n)
            tree[x][y] += z, y += y & -y;
        x += x & -x;
    }
}
void ask(int x, int y){//æ±‚å·¦ä¸Šè§’ä¸º(1,1)å³ä¸‹è§’ä¸º(x,y) çš„çŸ©é˜µå’Œ
    int res = 0, memo_y = y;
    while(x){
        y = memo_y;
        while(y)
            res += tree[x][y], y -= y & -y;
        x -= x & -x;
    }
}
```

```python
# åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢
void add(int x, int y, int z){ 
    for(int i = x; i; i += i & -i)
        for(int j = y; j; j += j & -j)
            tree[x][y] += z
}
void range_add(int xa, int ya, int xb, int yb, int z){
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
void ask(int x, int y){
    int res = 0;
    for(int i = x; i; i -= i & -i)
        for(int j = y; j; j -= j & -j)
            res += tree[x][y]
}
```

```python
# åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;
ll read(){
    char c; bool op = 0;
    while((c = getchar()) < '0' || c > '9')
        if(c == '-') op = 1;
    ll res = c - '0';
    while((c = getchar()) >= '0' && c <= '9')
        res = res * 10 + c - '0';
    return op ? -res : res;
}
const int N = 205;
ll n, m, Q;
ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];
void add(ll x, ll y, ll z){
    for(int X = x; X <= n; X += X & -X)
        for(int Y = y; Y <= m; Y += Y & -Y){
            t1[X][Y] += z;
            t2[X][Y] += z * x;
            t3[X][Y] += z * y;
            t4[X][Y] += z * x * y;
        }
}
void range_add(ll xa, ll ya, ll xb, ll yb, ll z){ //(xa, ya) åˆ° (xb, yb) çš„çŸ©å½¢
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
ll ask(ll x, ll y){
    ll res = 0;
    for(int i = x; i; i -= i & -i)
        for(int j = y; j; j -= j & -j)
            res += (x + 1) * (y + 1) * t1[i][j]
                - (y + 1) * t2[i][j]
                - (x + 1) * t3[i][j]
                + t4[i][j];
    return res;
}
ll range_ask(ll xa, ll ya, ll xb, ll yb){
    return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);
}
int main(){
    n = read(), m = read(), Q = read();
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            ll z = read();
            range_add(i, j, i, j, z);
        }
    }
    while(Q--){
        ll ya = read(), xa = read(), yb = read(), xb = read(), z = read(), a = read();
        if(range_ask(xa, ya, xb, yb) < z * (xb - xa + 1) * (yb - ya + 1))
            range_add(xa, ya, xb, yb, a);
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++)
            printf("%lld ", range_ask(i, j, i, j));
        putchar('\n');
    }
    return 0;
}
```

### çº¿æ®µæ ‘

å°†[1,n]åˆ†è§£æˆè‹¥å¹²ç‰¹å®šçš„å­åŒºé—´(æ•°é‡ä¸è¶…è¿‡4*n)

ç”¨çº¿æ®µæ ‘å¯¹â€œç¼–å·è¿ç»­â€çš„ä¸€äº›ç‚¹ï¼Œè¿›è¡Œä¿®æ”¹æˆ–è€…ç»Ÿè®¡æ“ä½œï¼Œä¿®æ”¹å’Œç»Ÿè®¡çš„å¤æ‚åº¦éƒ½æ˜¯O(log2(n))

ç”¨çº¿æ®µæ ‘ç»Ÿè®¡çš„ä¸œè¥¿ï¼Œå¿…é¡»ç¬¦åˆåŒºé—´åŠ æ³•ï¼Œï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå·²çŸ¥å·¦å³ä¸¤å­æ ‘çš„å…¨éƒ¨ä¿¡æ¯ï¼Œæ¯”å¦‚è¦èƒ½å¤Ÿæ¨å‡ºçˆ¶èŠ‚ç‚¹ï¼‰ï¼›å¦åˆ™ï¼Œä¸å¯èƒ½é€šè¿‡åˆ†æˆçš„å­åŒºé—´æ¥å¾—åˆ°[L,R]çš„ç»Ÿè®¡ç»“æœã€‚

ä¸€ä¸ªé—®é¢˜ï¼Œåªè¦èƒ½åŒ–æˆå¯¹ä¸€äº›â€œè¿ç»­ç‚¹â€çš„ä¿®æ”¹å’Œç»Ÿè®¡é—®é¢˜ï¼ŒåŸºæœ¬å°±å¯ä»¥ç”¨çº¿æ®µæ ‘æ¥è§£å†³äº†

åŒºé—´æ±‚å’Œï¼Œæ±‚æœ€å¤§ï¼Œæ±‚æœ€å°

arr[1,2,...n]ï¼Œå¼€è¾Ÿ4*nç©ºé—´çš„æ•°ç»„

å‚è€ƒé“¾æ¥ï¼š

https://www.cnblogs.com/jason2003/p/9676729.html
https://www.cnblogs.com/iris001999/articles/9058603.html
https://www.cnblogs.com/xenny/p/9801703.html
https://www.cnblogs.com/AC-King/p/7789013.html

å¤‡æ³¨ï¼š

çº¿æ®µæ ‘çš„å‡çº§ï¼šzkwçº¿æ®µæ ‘ https://blog.csdn.net/bestsort/article/details/80796531

```python
# çº¿æ®µæ ‘
# å¤‡æ³¨ï¼šæ ‘çš„èŠ‚ç‚¹ä»1å¼€å§‹è®¡æ•°
# arrä¹Ÿæ˜¯ä»1å¼€å§‹è®¡æ•°
# è‡³å°‘éœ€è¦4nä¸ªç»“ç‚¹ï¼šå±‚é«˜(lgn+1)ï¼Œå¶å­ç»“ç‚¹ä¸ªæ•°2^(lgn+1)ï¼Œæ€»ç»“ç‚¹ä¸ªæ•°2*2^(lgn+1)=4n
class Node():
    def __init__(self):
        # å·¦å³åŒºé—´å’ŒåŒºé—´ç»Ÿè®¡
        self.l = None
        self.r = None
        self.sum = None
        # æ˜¯å¦å»¶è¿Ÿæ›´æ–°
        self.lz = 0
  
    def __add__(self, other):
        res = Node()
        res.l
  

class SegmentTree():
    def __init__(self, arr):
        n = len(arr)
        arr = [0]+arr
        self.arr = arr
        n = len(arr)
        self.tree = [Node() for _ in range(4*len(self.arr))]
        self.build(1,1,n)
  
    def push_up(self, i):
        # èŠ‚ç‚¹æ›´æ–°
        self.tree[i].sum = self.tree[2*i].sum+self.tree[2*i+1].sum
  

    def build(self, i, l, r):
        # å»ºæ ‘
        # èŠ‚ç‚¹iå¯¹åº”çš„åŒºé—´lï¼Œr
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=self.arr[l]
            return
        mid = (l+r)//2
        self.build(2*i, l, mid)
        self.build(2*i+1, mid+1, r)
        self.push_up(i)

    # 1. å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼Œä¸éœ€è¦push_down
    def add(self, i, dis, k):
        # å•ç‚¹ä¿®æ”¹ï¼Œ self.arr[dis]+=k
        # è°ƒç”¨self.add(1, dis, k)
        if self.tree[i].l==self.tree[i].r:
            self.tree[i].sum+=k
            return
        if dis<=self.tree[2*i].r:
            self.add(2*i, dis, k)
        else:
            self.add(2*i+1, dis, k)
        self.push_up(i)
  
    def search(self, i, l, r):
        # åŒºé—´æŸ¥è¯¢(å•ç‚¹ä¿®æ”¹)
        # è°ƒç”¨ self.search(1, l, r)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        if self.tree[i].r<l or r<self.tree[i].l:
            return 0
        s = 0
        if l<=self.tree[2*i].r:
            s = s+self.search(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            s = s+self.search(2*i+1, l, r)
        return s

  
    # 2. åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼šåŒºé—´å†…æ‰€æœ‰æ•°å­—è¿›è¡Œæ›´æ–°ï¼Œæ›´æ–°åæŸä¸ªç‚¹çš„æ›´æ–°æƒ…å†µ
    # https://www.luogu.com.cn/problem/P3368
    # å’Œçº¿æ®µæ ‘çš„å…³ç³»å¹¶ä¸æ˜¯å¾ˆå¤§
    # self.tree[i].sum åˆå§‹åŒ–ä¸º0ï¼Œè®°å½•åŒºé—´å†…æ•°å­—çš„æ›´æ–°æƒ…å†µ
    def build2(self, i, l, r):
        # å»ºæ ‘
        # èŠ‚ç‚¹iå¯¹åº”çš„åŒºé—´lï¼Œr
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=0
            return
        mid = (l+r)//2
        self.build(2*i, l, mid)
        self.build(2*i+1, mid+1, r)
        self.push_up(i)
    def search2(self, i, dis):
        # å•ç‚¹æŸ¥è¯¢
        # ä»æ ¹èŠ‚ç‚¹ä¸€è·¯åŠ åˆ°å¶å­èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å¾—åˆ°è¯¥ä½ç½®æ•°å­—çš„æ›´æ–°æƒ…å†µï¼Œå†åŠ ä¸ŠåŸå§‹å€¼ï¼Œå°±å¯ä»¥å¾—åˆ°æ›´æ–°åçš„æ•°å­—
        self.ans+=self.tree[i].sum
        if self.tree[i].l==self.tree[i].r:
            self.ans += arr[l]
            return;
        if dis<=self.tree[i*2].r:
            self.search2(i*2, dis)
        if dis>=self.tree[i*2+1].l:
            self.search2(i*2+1, dis)
  
    def add2(self, i, l, r, k):
        # åŒºé—´ä¿®æ”¹ self.arr[l]+=k, arr[l+1]+=k, ..., arr[r]+=k
        if l<=self.tree[i].l and self.tree[i].r<=r:
            self.tree[i].sum+=k
            return
        if l<=self.tree[i*2].r:
            self.add2(i*2, l, r, k)
        if self.tree[i*2+1].l<=r:
            self.add2(i*2+1, l, r, k)
        self.push_up(i)

    # 3. å¯¹äºåŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼Œéœ€è¦push_down
    # åˆå§‹åŒ–å’Œ å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ä¸€è‡´ build
    # åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢æ˜¯åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢çš„ç‰¹æ®Šæƒ…å†µï¼Œä¸¤è€…ä»£ç å¯ä»¥åˆå¹¶
    def add3(self, i, l, r, k):
        # ç¬¬iä¸ªèŠ‚ç‚¹ï¼ŒåŒºé—´ä¿®æ”¹, self.arr[l, r]+=k
        # è°ƒç”¨ self.add3(1, l, r, k)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            self.tree[i].sum+=k*(self.tree[i].r-self.tree[i].l+1)
            self.tree[i].lz+=k # è¡¨ç¤ºæœ¬åŒºé—´çš„Sumæ­£ç¡®ï¼Œå­åŒºé—´çš„Sumä»éœ€è¦æ ¹æ®lzçš„å€¼æ¥è°ƒæ•´  
            return
        self.push_down(i)
        # æ­¤æ—¶içš„åŒºé—´å’Œlrè‚¯å®šæœ‰äº¤é›†ï¼Œå¯ä»¥å‡è®¾å­åŒºé—´çš„læˆ–è€…ræ— ç©·
        if self.tree[2*i].r>=l: # å¯¹äº[2*i]çš„å­åŒºé—´ï¼Œä¸€å®šæœ‰self.tree[2*i].left<=rightï¼Œå¦åˆ™içš„åŒºé—´å’Œlræ²¡æœ‰äº¤é›†ï¼Œé”™è¯¯
            self.add3(2*i, l, r, k)
        if self.tree[2*i+1].l<=r:
            self.add3(2*i+1, l, r, k)
        self.push_up(i)
        return
  
    def push_down(self, i):
        # ä¸‹æ¨æ ‡è®°
        # å¦‚æœæ²¡æœ‰ä¸‹æ¨æ ‡è®°æˆ–è€…å¶å­ç»“ç‚¹ï¼Œç»“æŸä¸‹æ¨
        if self.tree[i].lz==0 or self.tree[i].l==self.tree[i].r:
            return
        self.tree[2*i].lz+=self.tree[i].lz
        self.tree[2*i].sum+=(self.tree[2*i].r-self.tree[2*i].l+1)*self.tree[i].lz

        self.tree[2*i+1].lz+=self.tree[i].lz
        self.tree[2*i+1].sum+=(self.tree[2*i+1].r-self.tree[2*i+1].l+1)*self.tree[i].lz

        self.tree[i].lz=0
  
    def search3(self, i, l, r):
        # åŒºé—´æŸ¥è¯¢
        # è°ƒç”¨ self.search3(1, l, r)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        self.push_down(i) #  éœ€è¦ä¸‹æ¨æ ‡è®°
        res = 0
        if l<=self.tree[2*i].r:
            res+=self.search3(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            res+=self.search3(2*i+1, l, r)
        return res
```

## 307. åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„å¯ä¿®æ”¹

å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

æ–¹æ³•ï¼šçº¿æ®µæ ‘

```python
class Node():
    def __init__(self):
        self.l = 0
        self.r = 0 
        self.val = None

class NumArray:

    def __init__(self, nums: List[int]):
        if not nums:
            return 
        self.nums = nums
        n = len(nums)
        self.Tree = [Node() for _ in range(4*n)]
        self.build(1, 0, n-1)
  
    def push_up(self, i):
        self.Tree[i].val = self.Tree[i*2].val + self.Tree[i*2+1].val

    def build(self, i, l, r):
        print(i, len(self.Tree))
        self.Tree[i].l, self.Tree[i].r = l, r 
        if l==r:
            self.Tree[i].val = self.nums[l]
            return 
        mid = (l+r)//2
        self.build(i*2, l, mid)
        self.build(i*2+1, mid+1, r)
        self.push_up(i)

    def update(self, i: int, val: int) -> None:
        self.update2(1, i, val)
        return 

    def update2(self, index, i , val):
        if self.Tree[index].l==self.Tree[index].r:
            self.Tree[index].val=val
            return 
        if self.Tree[2*index].r>=i:
            self.update2(index*2, i, val)
        if self.Tree[2*index+1].l<=i:
            self.update2(index*2+1, i, val)
        self.push_up(index)

    def sumRange(self, i: int, j: int) -> int:
        return self.sumRange2(1, i, j)
    def sumRange2(self, index, i, j):
        if i<=self.Tree[index].l and self.Tree[index].r<=j:
            return self.Tree[index].val
        res = 0
        if self.Tree[2*index].r>=i:
            res+=self.sumRange2(index*2, i, j)
        if self.Tree[2*index+1].l<=j:
            res+=self.sumRange2(index*2+1, i, j)
        return res
```

## 308 äºŒç»´åŒºåŸŸå’Œæ£€ç´¢ - å¯å˜

äºŒç»´çŸ©é˜µï¼šå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

æ–¹æ³•ï¼šæ ‘çŠ¶æ•°ç»„

```python
class NumMatrix():
    def __init__(self, matrix):
        self.m, self.n = len(matrix), len(matrix[0])
        self.C = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                self.update(i, j, matrix[i-1][j-1])
  
    def update(self, i, j, val):
        j_tmp = j
        while i<self.m:
            j = j_tmp
            while j<self.n:
                self.C[i][j]+=val
                j += j&(-j)
            i+=i&(-i)
        return

    def sumRegion(self, i1, j1, i2, j2):
        return self.getsum(i2, j2)-self.getsum(i1, j2)-self.getsum(i2, j1)+self.getsum(i1, j1)
  
    def getsum(self, i, j):
        res = 0
        j_tmp = j
        while i>0:
            j = j_tmp
            while j>0:
                res+=self.C[i][j]
                j-=j&(-j)
            i-=i&(-i)
        return res
```

## ä¹°å–è‚¡ç¥¨æ”¶ç›Šæœ€å¤§é—®é¢˜

https://www.jianshu.com/p/9fa0faff99da

T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

åˆå§‹åŒ–ï¼šT[-1][k][0]=0, T[-1][k][1]=-sys.maxsize

```python
# ä»»æ„k 
import sys
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if not prices:
            return 0
        if k>=n/2:
            Tik0, Tik1 = 0, -sys.maxsize
            for i in range(n):
                Tik0_old = Tik0
                Tik0 = max(Tik0, Tik1+prices[i])
                Tik1 = max(Tik1, Tik0_old-prices[i])
            return Tik0
        Ti0 = [0 for _ in range(k+1)]
        Ti1 = [-sys.maxsize  for _ in range(k+1)]
        for i in range(n):
            for j in range(k, 0, -1):
                Ti0[j] = max(Ti0[j], Ti1[j]+prices[i])
                Ti1[j] = max(Ti1[j], Ti0[j-1]-prices[i])
        return Ti0[-1]
```

```python
# æœ‰ä¸€å¤©çš„å†·é™æœŸ
import sys
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        T_k0, T_k1 = 0, -sys.maxsize
        T_k0_old = 0
        for val in prices:
            T_k0_old_old = T_k0_old
            T_k0_old=T_k0
            T_k0 = max(T_k0, T_k1+val)
            T_k1 = max(T_k1, T_k0_old_old-val)
        return T_k0
```

## 310 æœ€å°é«˜åº¦æ ‘

å®šç†1ï¼šæœ€å°é«˜åº¦æ ‘ç­‰ä»·äºå›¾çš„ç›´å¾„çš„ä¸€åŠï¼Œå…¶ä¸­å›¾çš„ç›´å¾„å®šä¹‰ä¸ºæœ€è¿œçš„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»
è¯æ˜ï¼šä¸å¦¨å‡è®¾å›¾çš„ç›´å¾„ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯a,bï¼Œä¸­é—´èŠ‚ç‚¹æ˜¯c(å¦‚æœæœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå°±æ˜¯c1, c2ï¼Œä¸å½±å“åç»­åˆ†æ)ï¼Œç›´å¾„é•¿åº¦æ˜¯dï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä»¤cä¸ºæ ¹ï¼Œå¾—åˆ°aï¼Œbçš„é«˜åº¦æ˜¯d/2ï¼Œä¸”aï¼Œbçš„é«˜åº¦æ˜¯æ­¤æ—¶é«˜åº¦æ ‘çš„é«˜åº¦ï¼Œå› ä¸ºå…¶ä»–èŠ‚ç‚¹åˆ°cçš„è·ç¦»ä¸å¯èƒ½å¤§äºd/2ï¼Œå¦åˆ™a, bå°±ä¸æ˜¯å›¾çš„ç›´å¾„äº†ã€‚åè¯ï¼šå¦‚æœæœ€å°é«˜åº¦æ ‘çš„æ ¹ä¸åœ¨å›¾çš„ç›´å¾„è·¯å¾„ä¸Šï¼Œé‚£ä¹ˆæ ¹åˆ°cçš„è·ç¦»è‡³å°‘ä¸º1ï¼Œæ ¹åˆ°a,bçš„çš„æœ€å¤§è·ç¦»max(dis(æ ¹-a), dis(æ ¹-b))è‡³å°‘ä¸º2/d+1

å®šç†2ï¼šBFSå¾—åˆ°çš„é«˜åº¦æ ‘æ˜¯æœ€å°é«˜åº¦æ ‘
è¯æ˜ï¼šBFSæ¯æ¬¡åˆ æ‰å›¾ä¸­çš„æ‰€æœ‰å¶å­ç»“ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶å‰©ä¸‹çš„å¶å­èŠ‚ç‚¹éƒ½å¯ä»¥ä¸ºæ ¹èŠ‚ç‚¹ã€‚å…ˆè€ƒè™‘ä¸€ä¸ªç®€å•çš„è¿‡ç¨‹ï¼šå¯¹äºæœ€å°é«˜åº¦æ ‘ï¼Œä¸å¦¨å‡è®¾é«˜åº¦æ˜¯hï¼Œç¬¬ä¸€æ¬¡åªåˆ é™¤é«˜åº¦hçš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶é«˜åº¦h-1çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç¬¬äºŒæ¬¡åªåˆ é™¤é«˜åº¦h-1çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶é«˜åº¦h-2çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç¬¬ä¸‰æ¬¡åªåˆ é™¤é«˜åº¦h-2çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç¬¬hæ¬¡åªåˆ é™¤é«˜åº¦1çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œå‰©ä¸‹é«˜åº¦ä¸º0çš„æ ¹èŠ‚ç‚¹ã€‚å†è€ƒè™‘æ¯”è¾ƒå¤æ‚çš„è¿‡ç¨‹(BFS)ï¼šå¯¹äºç¬¬iæ¬¡ï¼Œä¸ä»…åˆ é™¤é«˜åº¦h-içš„æ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼Œä¹Ÿåˆ é™¤é«˜åº¦å°äºh-içš„å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜è¿™ç§åˆ é™¤æ–¹æ³•ä¸ä¼šæå‰åˆ é™¤æ ¹èŠ‚ç‚¹(ç­‰ä»·äºåˆ é™¤hæ¬¡åæ ¹èŠ‚ç‚¹è¿˜æ˜¯ä¼šè¢«å‰©ä¸‹)ã€‚æ ¹æ®å®šç†1ï¼Œä¸å¦¨å‡è®¾å›¾çš„ç›´å¾„è·¯å¾„ä¸Šåªæœ‰ä¸€ä¸ªä¸­é—´èŠ‚ç‚¹cï¼Œa1-a2-a3-...-c-...-b3-b2-b1ï¼Œæ­¤æ—¶aï¼Œbåˆ°cçš„è·ç¦»ç›¸åŒï¼Œä¹Ÿæ„å‘³ç€åŒæ—¶ä»aï¼Œbå¼€å§‹åˆ é™¤ï¼Œç¬¬i(i< h)æ¬¡åˆ é™¤ai, biåï¼Œè¿˜å‰©ai+1-...-c-...-bi+1ï¼Œæ ¹èŠ‚ç‚¹ä¸ä¼šæå‰æˆä¸ºå¶å­èŠ‚ç‚¹ã€‚å¯¹äºä¸¤ä¸ªä¸­é—´èŠ‚ç‚¹c1, c2: a1-a2-c1-c2-b2-b1ï¼Œåˆ é™¤a1,b1,a2,b2åï¼Œå‰©ä¸‹c1, c2ï¼ŒåŒæ—¶æˆä¸ºå¶å­èŠ‚ç‚¹ï¼Œc1ï¼Œc2ä¹Ÿä¸ä¼šæå‰æˆä¸ºå¶å­èŠ‚ç‚¹è¢«åˆ é™¤ã€‚

å®šç†3ï¼šå½“å›¾ç›´å¾„æ˜¯å¶æ•°(ç›´å¾„çš„èŠ‚ç‚¹æ•°ä¸ºå¥‡æ•°æ—¶)ï¼Œæœ€å°é«˜åº¦æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯ä¸€ä¸ªï¼›å½“å›¾ç›´å¾„æ˜¯å¥‡æ•°(ç›´å¾„çš„èŠ‚ç‚¹æ•°ä¸ºå¶æ•°æ—¶)ï¼Œæœ€å°é«˜åº¦æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯ä¸¤ä¸ª
è¯æ˜ï¼šç”±å®šç†1çš„è¯æ˜æ˜¾ç„¶å¯ä»¥å¾—åˆ°ã€‚

```python
from collections import deque
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if not edges:
            return [0]
        q = deque()
        degree = [0 for _ in range(n)]
        e = [[] for _ in range(n)]

        for n1, n2 in edges:
            e[n1].append(n2)
            e[n2].append(n1)
            degree[n1]+=1
            degree[n2]+=1
        for i, val in enumerate(degree):
            if val==1:
                q.append(i)
            
        q2 = list()
        while q:
            q2 = list(q)
            q_size = len(q)
            for _ in range(q_size):
                node = q.popleft()
                for next_node in e[node]:
                    degree[next_node]-=1
                    if degree[next_node]==1:
                        q.append(next_node)
        return q2
    
```

## 311 ç¨€ç–çŸ©é˜µçš„ä¹˜æ³•

base: ä»¥Aä¸ºæ ¸å¿ƒ

```python
def multiply(A, B):
    for i:
        for k:
            for j:
                C[i][j] += A[i][k]*B[k][j]
```

ä»¥Aä¸ºæ ¸å¿ƒï¼Œè¿›è¡Œä¼˜åŒ–

```python
class Solution {
public:
    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {
        vector<vector<int>> res(A.size(), vector<int>(B[0].size()));
        for (int i = 0; i < A.size(); ++i) {
            for (int k = 0; k < A[0].size(); ++k) {
                if (A[i][k] != 0) {
                    for (int j = 0; j < B[0].size(); ++j) {
                        if (B[k][j] != 0) res[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
        }
        return res;
    }
};
```

ä»¥Aï¼ŒBä¸ºæ ¸å¿ƒï¼Œè€ƒè™‘ç¨€ç–æ€§(æ¨è)
Time O(n^2 * (1 + a * b * n)) = O(n^2 + a * b * n^3)
Space O(b * n^2)

å¯¹äºA[i][k]ï¼ŒæŸ¥çœ‹B[k]ä¸­æœ‰å“ªäº›æœ‰æ•°å­—

```python
def multiply(A, B):
    B_pos = [[] for _ in range(len(B))]
    res = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]
    for k in range(len(B)):
        for j in range(len(B[0])):
            if B[k][j]:
                B_pos[k].append(j)  
    for i in range(len(A)):
        for k in range(len(A[0])):
            if A[i]==0:
                continue
            for j in B_pos[k]:
                res[i][j]+=A[i][k]*B[k][j]
    return res
```

## 312. æˆ³æ°”çƒ

å®šä¹‰ dp[l][r]: è¡¨ç¤ºå¼€åŒºé—´(l,r)ä¹‹é—´çš„æœ€å¤§å€¼ï¼Œå‡è®¾æœ€åä¸€ä¸ªæˆ³çš„æ°”çƒä½ç½®æ˜¯i\in [l+1, r-1]ï¼Œåˆ™dp[l][r]=dp[l][i]+nums[l]* nums[i]* nums[r]+dp[i][r]ï¼Œåˆå§‹åŒ–dp[l][l+1]=0

ä»æœ€åä¸€è¡Œåˆ°ç¬¬ä¸€è¡Œï¼Œä»å·¦åˆ°å³å¼€å§‹éå†è®¡ç®—ï¼Œè¦æ¯”æ–œç€æ›´æ–°å¥½å†™å¤šäº†

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1]+nums+[1]
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for l in range(n-1, -1, -1):
            for r in range(l+2, n):
                for k in range(l+1, r):
                    dp[l][r] = max(dp[l][r], dp[l][k]+nums[l]*nums[k]*nums[r]+dp[k][r])
        return dp[0][-1]
```

## 313. è¶…çº§ä¸‘æ•°

```python
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        primes_pos = [0 for _ in range(len(primes))]
        res = [1]
        for i in range(n-1):
            # print(res)
            tmp = min(res[pos]*primes[index] for index, pos in enumerate(primes_pos))
            res.append(tmp)
            for index, pos in enumerate(primes_pos):
                if tmp ==  res[pos]*primes[index]:
                    primes_pos[index]+=1
        return res[-1]
```

## 314 äºŒå‰æ ‘çš„å‚ç›´éå†

åˆ©ç”¨mapå¾—åˆ°æ¯ä¸€åˆ—çš„èŠ‚ç‚¹ï¼šf(root, col) = map[col].append(root)+f(root.left, col-1)+f(root.right, col+1)

å¯ä»¥ç”¨bfså®ç°

```python
from collections import deque, d 
def verticalOrder(root):
    q = deque([(root, 0)])
    map = dict()
    while q:
        node, col = q.popleft()
        map[col]
```

## 315 è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°

æ–¹æ³•ä¸€ï¼šåˆå¹¶æ’åº

```python
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        n = len(nums)
        self.nums = [[val, i, 0] for i, val in enumerate(nums)]
        self.mergeSort(0, n-1)
        res = [0 for _ in range(n)]
        for val, i, cnt in self.nums:
            res[i]=cnt
        return res
  
    def mergeSort(self, l, r):
        if l==r:
            return
        mid = (l+r)//2
        self.mergeSort(l, mid)
        self.mergeSort(mid+1, r)
        self.merge(l, mid, r)
  
    def merge(self, l, mid, r):
        p1, p2 = l, mid+1
        tmp = [0 for _ in range(r-l+1)]
        p3 = 0
        while p1<=mid or p2<=r:
            if (not p1<=mid) or (p2<=r and self.nums[p1][0]>self.nums[p2][0]):
                tmp[p3]=self.nums[p2]
                p2+=1
            else:
                tmp[p3]=self.nums[p1]
                tmp[p3][2]+=p2-mid-1
                p1+=1
            p3+=1
        self.nums[l:r+1] = tmp
```

æ–¹æ³•äºŒï¼šç¦»æ•£åŒ–+æ ‘çŠ¶æ•°ç»„

å¯¹äºæ•°ç»„ [5,5,6,3]:å¯ä»¥å¾—åˆ°hashset [0,1,2,3,4,5,6]:[0,0,1,0,2,1]ï¼Œå¯¹äºç¬¬ä¸€ä¸ª5è€Œè¨€ï¼Œå°±æ˜¯æ±‚hashsetçš„å‰ç¼€å’Œï¼Œå¯ä»¥åˆ©ç”¨æ ‘çŠ¶æ•°ç»„æ±‚ã€‚

æ–¹æ³•ä¸‰ï¼šäºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘å¯ä»¥å¿«é€Ÿè®¡ç®—å‡ºå°äºvalçš„èŠ‚ç‚¹ä¸ªæ•°ï¼šrootèŠ‚ç‚¹cntä¿å­˜å·¦å­æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œä»å³å‘å·¦éå†
f(root, val):
å¦‚æœval>root:è¯´æ˜æ–°å¢èŠ‚ç‚¹ä½äºæ ¹èŠ‚ç‚¹çš„å³å­æ ‘ï¼Œå¹¶ä¸”æ­¤æ—¶å°äºè¯¥valçš„èŠ‚ç‚¹ä¸ªæ•°(åŸæ•°ç»„å³ä¾§å°äºvalçš„ä¸ªæ•°)=æ ¹èŠ‚ç‚¹çš„cnt+1+f(root.right, val)
å¦‚æœval< rootï¼Œè¯´æ˜æ–°å¢èŠ‚ç‚¹ä½äºæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œæ ¹èŠ‚ç‚¹çš„cnt+=1

```python
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        //åˆå§‹åŒ–
        Integer[] res = new Integer[nums.length];
        Arrays.fill(res, 0);
        List<Integer> list = new ArrayList<>();
        //åå‘æ„é€ äºŒå‰æ ‘ï¼Œç»Ÿè®¡å³è¾¹çš„è¾ƒå°æ•°
        TreeNode root = null;
        for (int i = nums.length - 1; i >= 0; i--){
            root = addAndCount(root, new TreeNode(nums[i]), res, i);
        }
        return Arrays.asList(res);
    }

    public TreeNode addAndCount(TreeNode root, TreeNode node, Integer[] res, int i){
        if(root == null){
            root = node;
            return root;
        }
        //æ ¹èŠ‚ç‚¹çš„å·¦è¾¹ä¿å­˜ä¸å¤§äºæ ¹èŠ‚ç‚¹çš„å…ƒç´ 
        if(root.val >= node.val){ 
            //ç»Ÿè®¡å·¦èŠ‚ç‚¹çš„å…ƒç´ ä¸ªæ•°
            root.count++;
            root.left = addAndCount(root.left, node, res, i);
        }else{
            //èµ°åˆ°å³è¾¹è·å–è¯¥å…ƒç´ å·¦è¾¹çš„ä¸ªæ•°ï¼ˆæ ¹èŠ‚ç‚¹ 1 + å·¦èŠ‚ç‚¹ root.countï¼‰
            res[i] += 1 + root.count;
            //ç»Ÿè®¡å³è¾¹æ˜¯å¦è¿˜æœ‰æ›´å°çš„å…ƒç´ 
            root.right = addAndCount(root.right, node, res, i);
        }
        return root;
    }
}

class TreeNode{
    int val;
    int count;
    TreeNode left, right;

    public TreeNode(int val){
        this.val = val;
        this.count = 0;
        left = null;
        right = null;
    }
}
```

## 316. å»é™¤é‡å¤å­—æ¯

å»é™¤é‡å¤å­—æ¯ï¼Œå¹¶ä¸”å¾—åˆ°çš„ç»“æœå­—å…¸åºæœ€å°

æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ

è´ªå¿ƒï¼šå­—å…¸åºæœ€å°ï¼Œå³ç¬¬ä¸€ä¸ªå­—ç¬¦å°½å¯èƒ½å°ï¼Œç„¶åä¿è¯ç¬¬äºŒä¸ªå­—ç¬¦å°½å¯èƒ½å°ï¼Œä¾æ¬¡ç±»æ¨ã€‚æœ€å·¦ä¾§çš„å­—ç¬¦æ˜¯åœ¨èƒ½ä¿è¯å…¶ä»–å­—ç¬¦è‡³å°‘èƒ½å‡ºç°ä¸€æ¬¡æƒ…å†µä¸‹çš„æœ€å°å­—ç¬¦ã€‚å¯¹äºç¬¬ä¸€ä¸ªå­—ç¬¦s[pos]ï¼Œposä¹‹å³å…¶ä»–æ‰€æœ‰å­—ç¬¦è‡³å°‘å‡ºç°è¿‡ä¸€æ¬¡ã€‚poså¯ä»¥å–å€¼çš„èŒƒå›´[0, ... j]:j=min(j1, j2..)ï¼Œå…¶ä¸­j1æ˜¯s[j1]çš„æœ€åä¸€æ¬¡å‡ºç°ä½ç½®ï¼Œj2åŒç†ï¼Œæ‰€ä»¥ï¼Œjæ˜¯s[j]çš„æœ€åä¸€æ¬¡å‡ºç°ä½ç½®ï¼Œå¹¶ä¸”å¼€åŒºé—´(j,...n)ä¸­å…¶ä»–æ‰€æœ‰å­—ç¬¦è‡³å°‘å‡ºç°è¿‡ä¸€æ¬¡ã€‚å¹¶ä¸”s[pos]=min(s[0]...s[j])
è¯æ˜ï¼šå‡è®¾è¿™ç§è´ªå¿ƒæ–¹æ³•å–å¾—çš„å­—ç¬¦ä¸²"b..."(å¯¹åº”çš„åŸå­—ç¬¦ä¸²ä½ç½®æ˜¯i1)ä¸æ˜¯å­—å…¸åºæœ€å°ï¼Œæœ€å°çš„å­—ç¬¦ä¸²æ˜¯"a.."(å¯¹åº”åŸå­—ç¬¦ä¸²ä½ç½®æ˜¯ k1)ï¼Œå¯¹äºè´ªå¿ƒå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦b(i1)ï¼Œä»¥åŠè´ªå¿ƒçš„è§„åˆ™ï¼Œå¯ä»¥å¾—å‡º[0, j]ä¹‹é—´æ²¡æœ‰å‡ºç°a(k1>j)ï¼Œå¹¶ä¸”jæ˜¯s[j](!=a)æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚æœ€ä¼˜å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯a(k1>j)ï¼Œä¸”æœ€ä¼˜å­—ç¬¦ä¸²ä¸­s[j]çš„ä½ç½®å¤§äºk1ï¼Œä¸è´ªå¿ƒè§„åˆ™ç›¸çŸ›ç›¾ã€‚

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        if not s:
            return ""
        s_map = {val:i for i, val in enumerate(s)}
        cnt = min(s_map.values())
        pos = 0
        for i in range(cnt+1):
            if s[pos]>s[i]:
                pos = i
        return s[pos]+self.removeDuplicateLetters(s[pos:].replace(s[pos], ""))
```

    pre_pos = -1
    s_map = {val: i for i, val in enumerate(s)}
    while s_map:
        s_map = {val: i for i, val in enumerate(s) if val not in seen}
        cnt = min(s_map.values())
        pos = pre_pos+1
        for i in range(pre_pos+1, cnt+1):
            if s[pos]>s[i]:
                pos = i
        seen.add(pos)
        pre_pos = pos

æ–¹æ³•äºŒï¼šè´ªå¿ƒ+å•è°ƒæ ˆ

å•è°ƒæ ˆï¼šåŒºé—´å•è°ƒæ ˆï¼Œæ¯”å¦‚ 1 3 4 7, 5 8, 6 9 å…¶ä¸­1 3 4 7å•è°ƒï¼Œ5 8 å•è°ƒï¼Œ6 9 å•è°ƒï¼Œä¸”7 8 9éƒ½æ˜¯æœ€åä¸€æ¬¡å‡ºç°

å®šä¹‰è´ªå¿ƒ+å•è°ƒæ ˆstackçš„å…¥æ ˆè§„åˆ™ï¼š

1. å¦‚æœarr[cur]åœ¨stackä¸­å‡ºç°ï¼Œè·³è¿‡
2. å¦‚æœarr[cur]æ²¡æœ‰åœ¨stackä¸­å‡ºç°ï¼Œä¸”å°äºstack[-1]ä¸”stack[-1]åœ¨ä¹‹ååœ¨curä¹‹åè¿˜ä¼šå†æ¬¡å‡ºç°ï¼Œåˆ™å¼¹å‡ºæ ˆé¡¶
3. å¦‚æœarr[cur]æ²¡æœ‰åœ¨stackä¸­å‡ºç°ï¼Œä½†æ˜¯ä¸æ»¡è¶³æ¡ä»¶2ï¼Œå‹å…¥

ä¸éš¾å¾—å‡ºï¼Œè¿™ç§å•è°ƒæ ˆå…¥æ ˆè§„åˆ™å¾—åˆ°çš„æ ˆä¸­ï¼Œæˆ–è€…æ»¡è¶³arr[stack[k-1]]< arr[stack[k]]ï¼Œæˆ–è€…last_occur[arr[stack[k-1]]]< stack[k]

å›é¡¾æ–¹æ³•ä¸€ è´ªå¿ƒçš„è®¡ç®—è¿‡ç¨‹ï¼Œå¯ä»¥ç®€åŒ–ä¸ºï¼š
ç¬¬ä¸€æ­¥ï¼šè®¡ç®—jj0=min(j0, j1,..j25)ï¼Œæ±‚å‡ºpos0=min(arr[0]...arr[jj0])
ç¬¬äºŒæ­¥ï¼šè®¡ç®—jj1=min(j0, j1...j24), æ±‚å‡ºpos1=min(arr[pos0+1]...arr[jj1])
ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—jj2=min(j0, j1...j23), æ±‚å‡ºpos2=min(arr[pos1+1]...arr[jj2])
...
ä»”ç»†åˆ†æä¸Šè¿°è¿‡ç¨‹ï¼Œå¯¹äºæ¯ä¸€æ­¥æ±‚å‡ºçš„poskï¼Œéƒ½æœ‰ä¸¤ç§æƒ…å†µ:arr[posk]=arr[jjk]æˆ–è€…arr[posk]!=arr[jjk]ï¼Œå¯¹äºå‰è€…æœ‰jj{k+1}!=jjkï¼Œå¯¹äºåè€…jj{k+1}=jjkï¼Œå³æ ˆåªæœ‰å–åˆ°jjk(å¦‚æœå–åˆ°çš„ä½ç½®æ˜¯jjk'< jjkï¼Œä½†æ˜¯arr[jjk']=arr[jjk]ï¼Œæˆ‘ä»¬å¯ä»¥è§†ä¸ºå–åˆ°çš„æ˜¯jjkä½ç½®çš„å…ƒç´ ï¼Œå› ä¸ºjjk'åˆ°jjkä¹‹é—´çš„å…¶ä»–å­—ç¬¦åœ¨jjkä¹‹åä¸€å®šè¿˜ä¼šå‡ºç°ï¼Œä¸‹ä¸€ä¸ªå­—ç¬¦=min(jjk'+1, jj{k+1})=min(jjk+1, jj{k+1})æ—¶ï¼Œä¸‹ä¸€ä¸ªjjæ‰èƒ½ä¸åŒã€‚æˆ–è€…è¯´ï¼Œå¯¹äºjj0ï¼Œéœ€è¦ä¸€ç›´ä»å°åˆ°å¤§å–å•è°ƒæ ˆåˆ°jj0ï¼Œå†æ±‚jj1ï¼Œå†ä»å°åˆ°å¤§å–å•è°ƒæ ˆåˆ°jj1ï¼Œå†æ±‚jj2...ã€‚ä¸å¦¨å‡è®¾jj0==jj1, jj2==jj3ï¼Œå› æ­¤æœ‰
pos0=min(arr[0]...arr[jj0])ï¼Œ
pos1=min(arr[pos0+1]...arr[jj0])ï¼Œä¸”arr[pos1]==arr[jj0]ï¼Œ
pos2=min(arr[pos1+1]...arr[jj2])ï¼Œ
pos3=min(arr[pos1+1]...arr[jj2])ï¼Œä¸”arr[pos2]==arr[jj2]
ç¬¦åˆå•è°ƒæ ˆçš„æ¨¡å‹å››çš„æ”¹è¿›æ¨¡å‹ã€‚
last_occurå°±æ˜¯seggg

å¦‚æœarr[i]< arr[stack[-1]] ä¸”i<=last_occur[ arr[ stack[-1]]]ï¼Œå¼¹å‡º(while)(å…¶ä¸­last[len(stack)-1]è¡¨ç¤ºstack[-1]å¯¹åº”çš„jk)
å‹å…¥arr[i]

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ–¹æ³•ä¸€ è´ªå¿ƒæ³•çš„è®¡ç®—è¿‡ç¨‹æ¯å¾—åˆ°ä¸€ä¸ªå­—ç¬¦ï¼Œå°±ä¼šåœ¨ä¹‹åçš„å­—ç¬¦ä¸²ä¸­åˆ é™¤è¯¥å­—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬åœ¨å…¥æ ˆçš„æ—¶å€™ï¼Œåœ¨å·²ç»æœ‰stack[0]çš„æƒ…å†µä¸‹ï¼Œé‡åˆ°ç›¸åŒçš„å€¼éœ€è¦è·³è¿‡ã€‚

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = list()
        seen = set()
        last_occur = {val:i for i, val in enumerate(s)}
        for i in range(len(s)):
            if s[i] in seen:
                continue
            while stack and s[i]<stack[-1] and i<last_occur[stack[-1]]:
                tmp = stack.pop()
                seen.discard(tmp)
            stack.append(s[i])
            seen.add(s[i])
        return ''.join(stack)
```

æ–¹æ³•ä¸‰ï¼šå•è°ƒæ ˆ+å¼¹å‡ºé™åˆ¶

æ¯ä¸ªå­—æ¯ç§»é™¤remain_counter[c]-1æ¬¡

```python
class Solution:
    def removeDuplicateLetters(self, s) -> int:
        stack = []
        seen = set()
        remain_counter = collections.Counter(s)

        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 0:
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1
        return ''.join(stack)
```

## å•è°ƒæ ˆ

### ä¸€ã€ç®€å•çš„å•è°ƒæ ˆï¼š

ç»™å®šå­—ç¬¦ä¸²arrï¼Œä»å‰åˆ°åéå†ï¼Œå»ºç«‹å•è°ƒæ ˆ(ä»å°åˆ°å¤§)(stackä¸­è®°å½•çš„æ˜¯åŸæ•°ç»„çš„ä½ç½®)ï¼Œå¾—åˆ°çš„æœ€åå•è°ƒæ ˆstackã€‚ç­‰ä»·äº

å•è°ƒæ ˆå…¥æ ˆè§„åˆ™ï¼š
å¦‚æœarr[i]< arr[stack[-1]]ï¼Œå¼¹å‡ºstack[-1] (while)
å¦‚æœarr[i]> arr[stack[-1]], å‹å…¥

å¯¹äºå»ºç«‹è¿‡ç¨‹ä¸­içš„stackï¼Œæœ‰ï¼š
arr[stack[0]]=min(arr[0]         , ... arr[i])
arr[stack[1]]=min(arr[stack[0]+1], ... arr[i])
arr[stack[2]]=min(arr[stack[1]+1], ... arr[i])

å¯¹äºæœ€ç»ˆç»“æœstackæœ‰ï¼š
arr[stack[0]] =min(arr[0]         , ... arr[n-1])
arr[stack[1]]=min(arr[stack[0]+1], ... arr[n-1])
arr[stack[2]]=min(arr[stack[1]+1], ... arr[n-1])
...
ä¹Ÿå°±æ˜¯stack[i]éƒ½æ˜¯stack[i-1]+1åˆ°n-1çš„æ•°ç»„arræœ€å°å€¼ï¼Œä¸”stack[i]çš„æ•°ç»„arrä»å°åˆ°å¤§

å›¾å½¢

```python
# \       /\     /\
#  \     /  \   /  \
#   \   /    \ /    5
#    \ /      4
#     3
for i in range(n):
    while stack and arr[i]<arr[stack[-1]]:
        stack.pop()
    stack.append(i)
```

### äºŒã€æ»‘åŠ¨çª—å£(çª—å£å›ºå®šå¤§å°)çš„æœ€å°å€¼

å•è°ƒæ ˆstackæ»¡è¶³:
arr[stack[0]] = min(arr[0], ..., arr[w-1])
arr[stack[1]] = min(arr[1], ..., arr[w])
arr[stack[2]] = min(arr[2], ..., arr[w+1]])

å•è°ƒæ ˆï¼šä»å°åˆ°å¤§
é™åˆ¶æ¡ä»¶ï¼šæ ˆåº•å…ƒç´ ä¸å½“å‰ä½ç½®içš„è·ç¦»å°äºçª—å£w

è¯æ˜ï¼šå‡è®¾å·²ç»å¾—åˆ°åŒºé—´[i-w+1, i]çš„å•è°ƒæ ˆstack1ï¼Œå¦‚ä½•å¾—åˆ°åŒºé—´[i-w+2, i+1]çš„å•è°ƒæ ˆstack2ï¼Ÿ
stack1çš„æ ˆåº•å…ƒç´ æœ‰ä¸¤ç§å¯èƒ½ï¼š
ç¬¬ä¸€ç§ï¼šæ ˆåº•stack1[0]å°±æ˜¯i-w+1ï¼Œè¡¨ç¤º[i-w+1, i]çš„æœ€å€¼ï¼ŒåŒæ—¶[stack1]è¡¨ç¤º[stack1[0]+1, i]=[i-w+2, i]çš„æœ€å€¼ï¼Œæ˜¾ç„¶ï¼Œéœ€è¦åˆ é™¤stack1çš„æ ˆåº•ï¼Œåˆ é™¤çš„æ ˆåº•å…ƒç´ è¡¨ç¤º[i-w+2, i]çš„æœ€å€¼, æŒ‰ç…§å•è°ƒæ ˆå…¥æ ˆè§„åˆ™å‹å…¥i+1ï¼Œå¾—åˆ°çš„æ–°æ ˆçš„æ ˆåº•è¡¨ç¤º[i-w+2, i+1]çš„æœ€å€¼ã€‚
ç¬¬äºŒç§ï¼šæ ˆåº•stack1[0]ä¸æ˜¯i-w+1ï¼Œé‚£ä¹ˆæ ˆåº•stack1[0]å¯ä»¥è¡¨ç¤º[i-w+2, i]çš„æœ€å€¼ï¼ŒæŒ‰ç…§å•è°ƒæ ˆå…¥æ ˆè§„åˆ™å‹å…¥i+1ï¼Œå¾—åˆ°çš„æ–°æ ˆçš„æ ˆåº•è¡¨ç¤º[i-w+2, i+1]çš„æœ€å€¼ã€‚
æ ¹æ®ç¬¬ä¸€ç§å’Œç¬¬äºŒç§æƒ…å†µï¼Œå¯ä»¥å¾—å‡ºå¯¹äºå½“å‰iï¼Œéœ€è¦ä¿è¯æ ˆåº•å…ƒç´ åœ¨çª—å£[i-w+1, i]ä¸­

### æ¨¡å‹ä¸‰ã€æˆ‘ä¹Ÿä¸çŸ¥æœ‰å•¥åº”ç”¨åœºæ™¯

å•è°ƒæ ˆstackæ»¡è¶³:
arr[stack[0]] = min(arr[0]         , .., arr[j0])
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j1]])
arr[stack[2]] = min(arr[stack[1]+1], .., arr[j2]])
...
å…¶ä¸­last=[j0, j1, j2 ...]ï¼Œæ»¡è¶³j0<=j1<=j2...,ä¸”jm=n-1

å®šä¹‰ä¿®æ”¹åçš„å•è°ƒæ ˆå…¥æ ˆè§„åˆ™ï¼š
å¦‚æœarr[i]< arr[stack[-1]] ä¸”i<=last[len(stack)-1]ï¼Œå¼¹å‡º(while)(å…¶ä¸­last[len(stack)-1]è¡¨ç¤ºstack[-1]å¯¹åº”çš„jk)
å¦‚æœarr[i]>arr[stack[-1]]ï¼Œå‹å…¥
æœ€åå–stack[:len(last)]

```python
last = [j0, j1, j2]
stack = list()
for i, val in range(arr):
    while stack and i<=last[len(stack)-1] and va<stack[-1]:
        stack.pop()
    stack.append(val)
res = stack[:len(last)]

```

è¯æ˜ä¸Šè¿°çš„å•è°ƒæ ˆå…¥æ ˆè§„åˆ™æ­£ç¡®ã€‚æ•°å­¦å½’çº³æ³•
å¯¹äºstack[0]ï¼šå½“iéå†åˆ°j0ï¼Œä¸Šè¿°å•è°ƒæ ˆå…¥æ ˆè§„åˆ™å¯ä»¥å¾—åˆ°arr[stack[0]] = min(arr[0]        , .., arr[j0])
å‡è®¾å½“iéå†åˆ°j{k-1}æ—¶ï¼Œä¸Šè¿°å•è°ƒæ ˆå…¥æ ˆè§„åˆ™å¯ä»¥å¾—åˆ°stack[0],..., stack[k-1]ã€‚å¤‡æ³¨ï¼šå•è°ƒæ ˆstackä¸­æ­¤æ—¶çš„å…ƒç´ ä¸ªæ•°å¯èƒ½å¤§äºkä¸ªï¼Œä½†æ˜¯åªè¦å‰kä¸ªå…ƒç´ æ˜¯stack[0],..., stack[k-1]ï¼Œä¸”åç»­ä¸ä¼šå‘ç”Ÿæ”¹å˜å³å¯ã€‚
å½“iéå†åˆ°j{k}æ—¶ï¼Œéœ€è¦è¯æ˜å¯ä»¥å¾—åˆ°stack[0],..., stack[k-1], stack[k]ã€‚æˆ‘ä»¬ä»¤iä»0éå†åˆ°stack[k-1]ï¼Œå¯ä»¥å¾—åˆ°stack[0],..., stack[k-1]ã€‚åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š
ç¬¬ä¸€ç§ï¼šstack[k]åœ¨[stack[k-1]+1, j{k-1}]ä¸­ï¼Œæœ‰stack[k]>stack[k-1]ï¼Œé‚£ä¹ˆå½“iä»stack[k-1]+1éå†åˆ°j{k-1}æ—¶ï¼Œå¾—åˆ°stack[k]ï¼Œstack[k-1]ä¸ä¼šå¼¹å‡ºï¼Œå½“iä»j{k-1}éå†åˆ°jkæ—¶ï¼Œå› ä¸ºstack[k]=min(arr[stack[k-1]+1],..., arr[j{k-1}])ï¼Œæ‰€ä»¥stack[k]ä¸ä¼šè¢«å¼¹å‡ºï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å¾—åˆ°stack[0],..., stack[k]ï¼Œå¤‡æ³¨ï¼Œæ­¤æ—¶stack[k]ä¹‹åå¯èƒ½æœ‰ä¸€äº›å…¶ä»–å€¼
ç¬¬äºŒç§ï¼šstack[k]åœ¨[j{k-1}+1, jk]ä¸­ã€‚å½“iä»stack[k-1]éå†åˆ°j{k-1}æ—¶ï¼Œstack[k-1]ä¸ä¼šè¢«å¼¹å‡ºã€‚å½“iä»j{k-1}+1éå†åˆ°stack[k]æ—¶ï¼Œå¦‚æœæ ˆé¡¶æœ‰é™¤stack[k-1]ä¹‹å¤–çš„å…ƒç´ ï¼Œé‚£ä¹ˆstack[k]ä¼šæŠŠè¿™äº›å…ƒç´ å¼¹å‡º(å› ä¸ºæ­¤æ—¶len(stack)>=jk>=i)ï¼Œç›´åˆ°stack[k-1]ï¼Œç„¶åå‹å…¥stack[k]ï¼Œå½“iä»stack[k]+1éå†åˆ°jkæ—¶ï¼Œå› ä¸ºstack[k]æ˜¯[ stack[k], jk]ä¸­çš„æœ€å°å€¼ï¼Œæ‰€ä»¥stack[k]ä¸ä¼šè¢«å¼¹å‡ºã€‚å¾—è¯ã€‚

ä»å¦ä¸€ä¸ªè§’åº¦åˆ†æï¼š
arr[stack[0]] = min(arr[0]         , .., arr[j0])
å½“iä»0éå†åˆ°stack[0]æ—¶ï¼Œå³ä½¿æ ˆé¡¶æœ‰å…¶ä»–å…ƒç´ ï¼Œä¹Ÿä¼šè¢«å¼¹å‡ºï¼Œç„¶åå‹å…¥stack[0]
ä»stack[0]éå†åˆ°j0æ—¶ï¼Œstack[0]ä¸ä¼šè¢«å¼¹å‡ºï¼ŒåŒæ—¶æ ˆé¡¶ä¹Ÿå¯èƒ½ä¼šæœ‰å…¶ä»–å…ƒç´ 
å½“iéå†åˆ°j0ä»¥åæ—¶ï¼Œå› ä¸ºi<=last[len(stack)-1]ï¼Œstack[0]ä¹Ÿä¸ä¼šè¢«å¼¹å‡º
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j1]])
å½“iä»stack[0]+1éå†åˆ°stack[1]æ—¶ï¼Œä¼šå‹å…¥stack[1]
å½“iä»stack[1]éå†åˆ°j1æ—¶ï¼Œstack[1]å› ä¸ºæ˜¯æœ€å°ä¸ä¼šè¢«å¼¹å‡º
å½“iä»j1éå†åˆ°ä»¥åæ—¶ï¼Œstack[1]å› ä¸ºi<=last[len(stack)-1]ï¼Œä¹Ÿä¸ä¼šè¢«å¼¹å‡º
æˆ–è€…åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼šstack[1]åœ¨stack[0]+1åˆ°j0ä¹‹é—´ï¼Œæˆ–è€…stack[1]åœ¨j0åˆ°j1ä¹‹é—´
stack[1]åœ¨stack[0]+1åˆ°j0ä¹‹é—´ï¼šiä»stack[0]éå†åˆ°stack[1]ï¼Œä¼šå¾—åˆ°stack[1]ï¼Œiä»stack[1]éå†åˆ°j1æ—¶ï¼Œå› ä¸ºminä¸ä¼šè¢«å¼¹å‡ºï¼Œiä»j1å¼€å§‹éå†æ—¶ï¼Œå› ä¸ºä¸æ»¡è¶³i<=last[len(stack)-1]ï¼Œä¸ä¼šè¢«å¼¹å‡ºã€‚
stack[1]åœ¨j0åˆ°j1ä¹‹é—´ï¼šiéå†stack[0]åˆ°j0æ—¶ï¼Œä¼šå¾—åˆ°stack[1]çš„å€™é€‰ï¼Œä»j0åˆ°j1æ—¶ï¼Œç¢°åˆ°stack[1]ï¼Œåˆ™ä¼šå¼¹å‡ºstack[1]çš„å€™é€‰ï¼Œå‹å…¥çœŸå€¼stack[1]ï¼Œå¹¶ä¸”ä¹‹åä¸ä¼šè¢«å¼¹å‡ºï¼Œå½“iä»j1å¼€å§‹éå†æ—¶ï¼Œå› ä¸ºä¸æ»¡è¶³i<=last[len(stack)-1]ï¼Œä¸ä¼šè¢«å¼¹å‡º
æ­¤æ—¶stack[1]å¯èƒ½å°äºstack[0]

### æ¨¡å‹å››ã€å»é™¤é‡å¤å­—æ¯ï¼šè´ªå¿ƒ+å•è°ƒæ ˆ

å•è°ƒæ ˆstackæ»¡è¶³:
arr[stack[0]] = min(arr[0]         , .., arr[j0])
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j0]]) (æš—å«stack[1]==j0)
...
arr[stack[2]] = min(arr[j0], .., arr[j1]])
arr[stack[3]] = min(arr[stack[2]+1], .., arr[j1]])
...
å…¶ä¸­j0<=j1<=j2ï¼Œå³ç»™å®šj0ï¼Œå…ˆæ±‚å‡º[0, j0]çš„å•è°ƒæ ˆï¼Œå†æ±‚å‡º[j0+1, j1]çš„å•è°ƒæ ˆï¼Œ...

å®šä¹‰ä¿®æ”¹åçš„å•è°ƒæ ˆå…¥æ ˆè§„åˆ™ï¼š
segg = [j0, j0...j1, j1]ï¼Œlen(segg)==len(arr)ï¼Œå³æŠŠå°äºç­‰äºjkå¤§äºj{k-1}çš„ä½ç½®éƒ½èµ‹å€¼jk
å¦‚æœarr[i]< arr[stack[-1]] ä¸”i<=segg[stack[-1]]ï¼Œå¼¹å‡º(while)(å…¶ä¸­last[len(stack)-1]è¡¨ç¤ºstack[-1]å¯¹åº”çš„jk)
å‹å…¥arr[i]

è¯æ˜ï¼šå½“iä»0éå†åˆ°j0ï¼Œæ±‚å‡º[0, j0]çš„å•è°ƒæ ˆstack[0, 1]ï¼Œå½“iä»j0+1éå†åˆ°n-1æ—¶ï¼Œå› ä¸ºi<=segg[stack[-1]]ï¼Œæ‰€ä»¥stack[0, 1]ä¸ä¼šè¢«å¼¹å‡º
å½“iä»j0éå†åˆ°j1ï¼Œæ±‚å‡º[j0+1, j1]çš„å•è°ƒæ ˆstack[2, 3]ï¼Œå½“iä»j1+1éå†åˆ°n-1æ—¶ï¼Œå› ä¸ºå› ä¸ºi<=segg[stack[-1]]ï¼Œæ‰€ä»¥stack[2, 3]ä¸ä¼šè¢«å¼¹å‡º

æ¨¡å‹å››çš„æ”¹è¿›ç‰ˆ

è¿›ä¸€æ­¥ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰seggg=[ xx, xx,..., j0, x, x, j1]ï¼Œä¸¾ä¾‹ j0=2, j=5ï¼Œn=6ï¼Œseggg[3, 3, 2, 6, 5]ï¼Œåªè¦æ»¡è¶³seggg[j0]=j0, seggg[j1]=j1ï¼Œj{k-1}ä¸j{k}ä¹‹é—´çš„å€¼å¤§äºç­‰äºjkå³å¯

å¦‚æœarr[i]< arr[stack[-1]] ä¸”i<=seggg[stack[-1]]ï¼Œå¼¹å‡º(while)(å…¶ä¸­last[len(stack)-1]è¡¨ç¤ºstack[-1]å¯¹åº”çš„jk)
å‹å…¥arr[i]

è¯æ˜ï¼šå½“iä»0éå†åˆ°j0æ—¶ï¼Œæ±‚å‡º[0, j0]çš„å•è°ƒæ ˆstack[0, 1]ï¼Œå¹¶ä¸”æ˜¾ç„¶arr[j0]ä¸€å®šä¼šåœ¨æ ˆé¡¶(å¦åˆ™æˆ‘ä»¬æ€»æ˜¯å¯ä»¥åœ¨stack[-1]+1åˆ°j0ä¹‹é—´æ‰¾åˆ°æœ€å°å€¼)ï¼Œå½“iä»j0+1éå†åˆ°n-1æ—¶ï¼Œå› ä¸ºstack[1]=arr[j0]ï¼Œseggg[j0]=j0ï¼Œæ‰€ä»¥i<=seggg[stack[-1]]ä½¿å¾—stack[1]æ— æ³•å¼¹å‡º
å½“iä»j0+1éå†åˆ°j1æ—¶ï¼Œå¯ä»¥æ±‚å‡º[j0+1, j1]çš„å•è°ƒæ ˆstack[2, 3]ï¼Œå¹¶ä¸”æ˜¾ç„¶arr[j1]ä¸€å®šä¼šåœ¨æ ˆé¡¶ï¼Œå½“iä»j1+1éå†åˆ°n-1æ—¶ï¼Œi<=seggg[stack[-1]]ä½¿å¾—stack[3]æ— æ³•å¼¹å‡º

æˆ–è€…ç†è§£æˆå½“iå’Œstack[-1]åŒæ—¶å±äºä¸€ä¸ªåŒºé—´æ—¶(i<=last[stack[-1]])ï¼Œæ‰éœ€è¦æ»¡è¶³ä»å°åˆ°å¤§çš„å•è°ƒæ ˆï¼Œå½“iå’Œstack[-1]ä¸å±äºåŒä¸€ä¸ªåŒºé—´æ—¶ï¼Œä¸éœ€è¦å¼¹å‡º

å¤‡æ³¨ï¼šæ¨¡å‹ä¸‰å’Œå››çš„ä¸»è¦åŒºåˆ«åœ¨äºç»™å®šj0ï¼Œarr[j0]æ˜¯å¦ä¸€å®šä¼šè¢«é€‰åˆ°æ ˆä¸­ï¼Œæ¨¡å‹ä¸‰æ²¡æœ‰å¼ºåˆ¶è¦æ±‚ï¼Œæ¨¡å‹å››æš—å«å¼ºåˆ¶è¦æ±‚

### æ¨¡å‹äº”ï¼šå•è°ƒæ ˆ+å¼¹å‡ºé™åˆ¶

https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/

ä¸¤ä¸ªç›¸åŒä½æ•°çš„æ•°å­—å¤§å°å…³ç³»å–å†³äºç¬¬ä¸€ä¸ªä¸åŒçš„æ•°çš„å¤§å°ï¼Œæ‰€ä»¥å¯ä»¥è´ªå¿ƒåœ°åˆ é™¤æ ˆä¸­ç›¸é‚»çš„å­—ç¬¦

402 ç§»æ‰ K ä½æ•°å­—

å•è°ƒæ ˆæœ€å¤šå¼¹å‡ºKæ¬¡

å¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœå¼¹å‡ºæ¬¡æ•°å°äºkï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸¢å¼ƒæˆ–è€…ä¿ç•™ï¼Œå¦åˆ™ä¸å¯ä»¥ä¸¢å¼ƒ

```python
def removeKdigits(self, num, k):
    stack = []
    remain = len(num) - k
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    return ''.join(stack[:remain]).lstrip('0') or '0'
```

316 å»é™¤é‡å¤å­—æ¯

æ¯ä¸ªå­—æ¯cç§»é™¤remain_counter[c]-1æ¬¡

å»ºç«‹ä¸€ä¸ªå­—å…¸ã€‚å…¶ä¸­ key ä¸º å­—ç¬¦ cï¼Œvalue ä¸ºå…¶å‡ºç°çš„å‰©ä½™æ¬¡æ•°ã€‚
ä»å·¦å¾€å³éå†å­—ç¬¦ä¸²ï¼Œæ¯æ¬¡éå†åˆ°ä¸€ä¸ªå­—ç¬¦ï¼Œå…¶å‰©ä½™å‡ºç°æ¬¡æ•° - 1.
å¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœå…¶å¯¹åº”çš„å‰©ä½™å‡ºç°æ¬¡æ•°å¤§äº 1ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸¢å¼ƒï¼ˆä¹Ÿå¯ä»¥é€‰æ‹©ä¸ä¸¢å¼ƒï¼‰ï¼Œå¦åˆ™ä¸å¯ä»¥ä¸¢å¼ƒã€‚
å¦‚æœæ ˆä¸­ç›¸é‚»çš„å…ƒç´ å­—å…¸åºæ›´å¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬é€‰æ‹©ä¸¢å¼ƒç›¸é‚»çš„æ ˆä¸­çš„å…ƒç´ ã€‚

```python
class Solution:
    def removeDuplicateLetters(self, s) -> int:
        stack = []
        seen = set()
        remain_counter = collections.Counter(s)

        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 0:
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1 # å…¥æ ˆçš„æ—¶å€™æå‰ç®—ä¸€æ¬¡ç§»é™¤æ¬¡æ•°
        return ''.join(stack)
        # æˆ–è€…
        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 1:
                    remain_counter[stack[-1]]-=1 # å‡ºæ ˆçš„æ—¶å€™ç®—ä¸€æ¬¡ç§»é™¤æ¬¡æ•°
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            else:
                remain_counter[c] -= 1
```

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = list()
        seen = set()
        last_occur = {val:i for i, val in enumerate(s)}
        for i in range(len(s)):
            if s[i] in seen:
                continue
            while stack and s[i]<stack[-1] and i<last_occur[stack[-1]]:
                tmp = stack.pop()
                seen.discard(tmp)
            stack.append(s[i])
            seen.add(s[i])
        return ''.join(stack)
```

## 402. ç§»æ‰ K ä½æ•°å­—ï¼ˆä¸­ç­‰ï¼‰

ç§»é™¤kä¸ªæ•°å­—ç­‰ä»·äºä¿ç•™n-kä¸ªæ•°å­—

æ–¹æ³•ä¸€ï¼šå•è°ƒæ ˆ+å¼¹å‡ºé™åˆ¶

æœ€å¤šç§»é™¤Kä¸ªæ•°å­—==æœ€å¤šå¼¹å‡ºKæ¬¡
å•è°ƒæ ˆæœ€åå¯èƒ½æœ‰è¶…è¿‡n-kä¸ªæ•°å­—ï¼Œåªéœ€è¦ä¿ç•™n-kä¸ªæ•°å­—å³å¯

```python
class Solution(object):
    def removeKdigits(self, num, k):
        stack = []
        remain = len(num) - k
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
        return ''.join(stack[:remain]).lstrip('0') or '0'
```

æ–¹æ³•äºŒï¼šå•è°ƒæ ˆæ¨¡å‹ä¸‰

ä»¥ 1432219,n=7, k=3ä¸ºä¾‹ï¼Œä¿ç•™4=n-kä¸ªæ•°å­—

ç¬¬ä¸€ä¸ªæ•°å­—pos0=min(arr[0], arr[1], arr[2], arr[3])=min(arr[0],..., arr[k])
ç¬¬äºŒä¸ªæ•°å­—pos1=min(arr[pos0+1],..., arr[4])=min(arr[pos0+1],..., arr[k+1])
ç¬¬ä¸‰ä¸ªæ•°å­—pos2=min(arr[pos1+1],..., arr[5])=min(arr[pos1+1],..., arr[k+2])
ç¬¬å››ä¸ªæ•°å­—pos3=min(arr[pos2+1],..., arr[6])=min(arr[pos2+1],..., arr[k+3])

ç¬¬äº”ä¸ªæ•°å­—pos4=min(arr[pos3+1],..., arr[6])=min(arr[pos3+1],..., arr[n-1])
ä¸€ç›´åˆ°posm=n-1

ä¹‹æ‰€ä»¥ç¬¬ä¸€ä¸ªæ•°å­—å–åˆ°kï¼Œæ˜¯ä¸ºäº†ç»™åç»­çš„æ•°å­—å–å€¼çš„ç©ºé—´ï¼Œå¦åˆ™å¦‚æœç¬¬ä¸€ä¸ªæ•°å­—çš„æœ€å°å€¼åœ¨ç¬¬n-1ä½ï¼Œç¬¬äºŒä¸ªæ•°å­—å°±æ²¡æ³•å–äº†

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        remain = len(num)-k
        for i, digit in enumerate(num):
            while stack and i<len(stack)+k and digit<stack[-1]:
                stack.pop()
            stack.append(digit)
        res = ''.join(stack[:remain]).lstrip('0')
        if not res:
            return "0"
        return res
```

## 317. ç¦»å»ºç­‘ç‰©æœ€è¿‘çš„è·ç¦»

BFSï¼šä»ç›®çš„åœ°å¼€å§‹BFS

éœ€è¦è®°å½•å½“å‰å»ºç­‘ç‰©BFSçš„æ˜¯å¦è®¿é—®å’Œè·ç¦»ï¼Œå¹¶ä¸”è®¡ç®—ç¬¬ä¸€ä¸ªå»ºç­‘ç‰©åˆ°å½“å‰å»ºç­‘ç‰©å¯¹0çš„è®¿é—®æ¬¡æ•°å’Œè·ç¦»

å¯¹äºæœ‰åˆ†å‰²çš„å»ºç­‘ç‰©iå’Œjï¼Œå¯¹iè¿›è¡ŒBFSä¹‹åï¼Œå¯¹jè¿›è¡ŒBFSæ—¶ï¼Œä¼šå‘ç°ç¬¬jä¸ªå»ºç­‘ç‰©å‘¨å›´çš„ç‚¹çš„éå†æ¬¡æ•°ä¸æ˜¯j-1æ¬¡ã€‚

ä¸ºäº†æ–¹ä¾¿æ¯”è¾ƒå»ºç­‘ç‰©å‘¨å›´ç‚¹çš„éå†æ¬¡æ•°ï¼ŒBFSæ—¶ï¼Œæˆ‘ä»¬å¯¹å»ºç­‘ç‰©ä¹Ÿè¿›è¡Œéå†ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒå»ºç­‘ç‰©jè¢«éå†çš„æ¬¡æ•°æ˜¯å¦ç­‰äºj-1æ¬¡å³å¯ã€‚

```python
from collections import deque
import sys
class Solution:
    def shortestDistance(self, grid):
        n, m = len(grid), len(grid[0])
        dist = [[0 for _ in range(m)] for _ in range(n)]
        cnt = [[0 for _ in range(m)] for _ in range(n)]
        buildcnt=0
        delta = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        print

        def in_area(x, y):
            return 0<=x<n and 0<=y<m

        def dfs(i, j):
            nonlocal buildcnt
            print(i, j, buildcnt, cnt[i][j])
            if buildcnt!=cnt[i][j]:
                return False
            buildcnt+=1
            q = deque([(i, j, 0)])
            while q:
                i, j, dis_cur = q.popleft()
                dist[i][j]+=dis_cur
                cnt[i][j]+=1
                for dx, dy in delta:
                    x, y = i+dx, j+dy
                    if in_area(x, y) and grid[x][y]!=2 and cnt[x][y]==buildcnt-1:
                        q.append((x, y, dis_cur+1))
            return True

        for i in range(n):
            for j in range(m):
                if grid[i][j]==1:
                    if not dfs(i, j):
                        return -1

        res = sys.maxsize
        for i in range(n):
            for j in range(m):
                if grid[i][j]==0 and cnt[i][j]==buildcnt:
                    res=min(res, dist[i][j])
        return res
```

## 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯

åˆ©ç”¨bitmaskä»£æ›¿setï¼Œå®Œæˆsetçš„äº¤é›†:x&y==0

```python
from collections import defaultdict
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        hashmap = defaultdict(int)
        for i, word in enumerate(words):
            bitmask = 0
            for c in word:
                bitmask |= 1<<(ord(c)-ord("a"))
            hashmap[bitmask] = max(hashmap[bitmask], len(word))
    
        res = 0
        for x in hashmap:
            for y in hashmap:
                if x&y==0:
                    res = max(res, hashmap[x]*hashmap[y])
        return res

```

## 319 ç¯æ³¡å¼€å…³

å‡è®¾ç¯æ³¡ä»1å¼€å§‹ç¼–å·åˆ°nï¼Œåˆšå¼€å§‹ä¸ºå…³é—­
ç¬¬ä¸€è½®: å…¨éƒ¨æ‰“å¼€
ç¬¬äºŒè½®ï¼šç¬¬2ï¼Œ4ï¼Œ6ï¼Œ8....åˆ‡æ¢å¼€å…³
ç¬¬ä¸‰è½®ï¼šç¬¬3 6 9 12 ...åˆ‡æ¢å¼€å…³
...

å¯¹äºç¬¬iä¸ªç¯æ³¡ï¼Œä¸€å…±è¢«åˆ‡æ¢äº†g(i)æ¬¡ã€‚å…¶ä¸­g(i)è¡¨ç¤ºå› å­æ•°é‡ï¼Œå¦‚æœg(i)ä¸ºå¥‡æ•°ï¼Œåˆ™æœ€åä¸ºå¼€ï¼Œå¦‚æœg(i)ä¸ºå¶æ•°ï¼Œåˆ™æœ€åä¸ºå…³ã€‚

å¯¹äºnï¼Œå¦‚æœmä¸ºnçš„å› å­ï¼Œåˆ™n/mä¹Ÿæ˜¯nçš„å› å­ã€‚å¦‚æœm!=n/mï¼Œåˆ™å¯¹äºæ¯ä¸€ä¸ªméƒ½æœ‰n/mä½œä¸ºå¦ä¸€ä¸ªå› å­ï¼Œå³å› å­æˆå¯¹å‡ºç°ã€‚å¦‚æœå­˜åœ¨m==n/m,åˆ™å¯¹äºnè€Œè¨€ï¼Œæœ‰å¥‡æ•°ä¸ªå› å­ã€‚å½“m=n/mï¼Œæœ‰n=m^2ï¼Œæ˜¯å®Œå…¨å¹³æ–¹æ•°ã€‚

æ‰€ä»¥æœ€åå‰©ä¸‹äº®ç€çš„ç¯æ³¡ä¸ªæ•°ç­‰äºå®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°(1,4,9...),å³sqrt(n)ä¸ª

```python
class Solution:
    def bulbSwitch(self, n: int) -> int:
        res = int(n**0.5)
        return res
```

## 320 åˆ—ä¸¾å•è¯çš„å…¨éƒ¨ç¼©å†™

```python
def generateAbbreviations(word):
    res = list()
    path = list()
    n = len(word)
    def helper(pos):
        if n==pos:
            res.append(''.join(map(str, path)))
            return
        path.append(word[pos])
        helper(pos+1)
        path.pop()
    
        if path and isinstance(path[-1], int):
            path[-1]+=1
            helper(pos+1)
            path[-1]-=1
        else:
            path.append(1)
            helper(pos+1)
            path.pop()
    helper(0)
    return res
```

## 321 æ‹¼æ¥æœ€å¤§æ•°

å¯¹äºkï¼Œåˆ†åˆ«åœ¨nums1å’Œnums2ä¸­å–åˆ°å­—å…¸åºæœ€å¤§ï¼Œç„¶åæŒ‰ç…§å­—å…¸åºæœ€å¤§è¿›è¡Œæ‹¼æ¥

å­—å…¸åºæœ€å¤§æ‹¼æ¥ï¼šæ¯”å¦‚arr1=[6,8]å’Œarr2=[6,7]ï¼Œç¬¬ä¸€ä¸ª6åº”è¯¥å–arr1ï¼Œå› ä¸ºarr1çš„å­—å…¸åºæ¯”arr2å¤§ï¼Œåº”è¯¥å°½é‡å…ˆå–åˆ°8ï¼Œè€Œä¸æ˜¯7ã€‚

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def helper(nums, k):
            n = len(nums)
            drop = n-k
            stack = list()
            for i, val in enumerate(nums):
                while stack and drop and val>stack[-1]:
                    drop-=1
                    stack.pop()
                stack.append(val)
            return stack[:k]
    
        def merge(arr1, arr2):
            res = list()
            pos1, pos2 = 0, 0
            while pos1<len(arr1) or pos2<len(arr2):
                if (not pos2<len(arr2)) or (pos1<len(arr1) and arr1[pos1:]>arr2[pos2:]):
                    res.append(arr1[pos1])
                    pos1+=1
                else:
                    res.append(arr2[pos2])
                    pos2+=1
            return res
    
        res = [0 for _ in range(k)]
        for k1 in range(min(len(nums1), k)+1):
            k2 = k-k1
            if k2>len(nums2):
                continue
            cur = merge(helper(nums1, k1), helper(nums2, k2))
            res = max(res, cur)
        return res
```
